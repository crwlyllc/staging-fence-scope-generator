<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scope Generator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="icon" type="image/svg+xml" href="assets/strong-perimeter-favicon.svg" />
  <style>
  :root{
    --sp-green:#004B3D;
    --sp-ink:#1d1d1f;
    --sp-muted:#6b7280;
    --sp-border:#e5e7eb;
    --sp-bg:#f8fafc;
    --sp-card:#ffffff;
    --sp-radius:14px;
    --sp-stage-bg:#EBEBEB;
    --sp-floating-offset:96px;
  }
  #sp-scope{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";color:var(--sp-ink)}
  #sp-scope *{box-sizing:border-box}

  body{margin:0;background:var(--sp-stage-bg);}  
  body,html{min-height:100%;}
  .sp-container{max-width:1320px;margin:0 auto;padding:24px 24px calc(40px + var(--sp-floating-offset, 0px))}
  .sp-header{display:flex;flex-wrap:wrap;align-items:center;gap:12px;justify-content:space-between;margin-bottom:18px}
  .sp-title{font-size:22px;font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px;line-height:1.2}
  .sp-badge{background:var(--sp-green);color:#fff;padding:4px 10px;border-radius:999px;font-size:12px;font-weight:700}

  .sp-actions{display:flex;gap:10px;flex-wrap:wrap}
  .sp-btn{appearance:none;border:1px solid var(--sp-border);background:#fff;color:var(--sp-ink);padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:transform .02s ease,border-color .2s ease,background .2s ease;min-height:44px;font-size:14px;text-decoration:none}
  .sp-btn:active{transform:translateY(1px)}
  .sp-btn.primary{background:var(--sp-green);color:#fff;border-color:var(--sp-green)}
  .sp-btn.ghost{background:#fff}
  .sp-btn.danger{background:#fff;color:#b91c1c;border-color:#fecaca}
  .sp-btn.danger.is-confirm{background:#b91c1c;color:#fff;border-color:#b91c1c}
  .sp-btn.is-hidden{display:none}

  .sp-sections{display:grid;gap:16px}
  .sp-onboard [data-gated]{
    display:none !important;
  }
  .sp-section-locked [data-section-detail]{
    display:none !important;
  }
  .sp-card{background:var(--sp-card);border:1px solid var(--sp-border);border-radius:var(--sp-radius);padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  #sp-map-card{margin-bottom:16px}
  #sp-crew-card{margin-top:18px;display:none}
  .sp-inline-cards{display:grid;gap:16px;margin-bottom:16px}
  .sp-scope-group{border:1px solid var(--sp-border);background:#f8fafc;border-radius:12px;padding:14px;position:relative;overflow:hidden;gap:10px}
  .sp-scope-head{display:flex;gap:10px;align-items:flex-start;margin-bottom:8px}
  .sp-scope-pill{background:var(--accent, var(--sp-green));color:#fff;font-weight:800;font-size:12px;padding:4px 10px;border-radius:999px;letter-spacing:.4px;text-transform:uppercase}
  .sp-scope-title{font-weight:800;font-size:15px}
  .sp-scope-sub{color:var(--sp-muted);font-size:13px}
  .sp-scope-grid{gap:10px}
  .sp-scope-group.is-basics{--accent:#0f766e;background:#ecfdf3}
  .sp-scope-group.is-wood{--accent:#b45309;background:#fff7ed}
  .sp-scope-group.is-style{--accent:#4338ca;background:#eef2ff}
  .sp-scope-group.is-repair{
    --accent:#9f1239;
    background:#fff1f2;
    margin-block:20px;
  }
  .sp-scope-group.is-gates{--accent:#0ea5e9;background:#f0f9ff}
  .sp-card-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .sp-card-title{font-size:16px;font-weight:800}
  .sp-card.is-collapsed .sp-grid{display:none}

  .sp-grid{display:grid;gap:12px}
  @media(min-width:720px){
    .sp-grid{grid-template-columns:repeat(12,1fr)}
    .col-6{grid-column:span 6}
    .col-4{grid-column:span 4}
    .col-3{grid-column:span 3}
    .col-2{grid-column:span 2}
    .col-8{grid-column:span 8}
    .col-12{grid-column:span 12}
    .sp-inline-cards{grid-template-columns:repeat(2,minmax(0,1fr))}
  }
  @media(max-width:719px){
    .sp-container{padding:20px 16px calc(36px + var(--sp-floating-offset, 0px))}
    .sp-header{flex-direction:column;align-items:flex-start;gap:16px}
    .sp-title{font-size:20px}
    .sp-actions{width:100%;flex-direction:column;align-items:stretch}
    .sp-btn{width:100%}
    .sp-sections{gap:12px}
    .sp-card{padding:14px}
    #sp-map-card{margin-bottom:12px}
    #sp-crew-card{margin-top:16px}
    .sp-card-header{flex-direction:column;align-items:flex-start;gap:10px}
    .sp-card-header .sp-row{width:100%;justify-content:flex-start}
    .sp-card-title{font-size:18px}
    .sp-grid{gap:10px}
    .col-6,.col-4,.col-3,.col-2,.col-8,.col-12{grid-column:span 12}
    .sp-copy-row{flex-direction:column}
    .sp-copy-row .sp-btn{width:100%}
    .sp-row{width:100%;justify-content:flex-start}
    .sp-number{width:100%}
  }

  .sp-field{display:flex;flex-direction:column;gap:6px}
  .sp-label{font-size:12px;font-weight:800;color:var(--sp-muted);letter-spacing:.4px;text-transform:uppercase}
  .sp-input,.sp-select,.sp-textarea{border:1px solid var(--sp-border);border-radius:12px;padding:10px 12px;background:#fff;font-size:14px;width:100%}
  .sp-textarea{min-height:68px;resize:vertical}
  .sp-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  /* Rail row (Rails count + all rail blocks on one row, top-aligned) */
  .sp-rail-row{
    display:grid;
    gap:12px;
    align-items:start;
  }
  .sp-rail-row > .sp-field{ align-self:start; }

  @media(min-width:720px){
    .sp-rail-row{ grid-template-columns: var(--rail-cols, repeat(3, minmax(200px,1fr))); }
  }
  @media(max-width:719px){
    .sp-rail-row{ grid-template-columns: 1fr; }
  }

  /* Number control */
  .sp-number{display:flex;align-items:stretch;border:1px solid var(--sp-border);border-radius:12px;overflow:hidden}
  .sp-number input{border:0;flex:1;min-width:0;padding:10px 12px;font-size:14px;-moz-appearance:textfield}
  .sp-number input::-webkit-outer-spin-button,.sp-number input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}
  .sp-step{min-width:46px;font-weight:900;display:grid;place-items:center;border:0;background:var(--sp-bg);cursor:pointer}
  .sp-step:active{filter:brightness(.95)}

  .sp-small{font-size:12px;color:var(--sp-muted)}
  .sp-output{margin-top:18px; display:grid; gap:16px}
  .sp-output textarea{width:100%;min-height:200px;border:1px solid var(--sp-border);border-radius:12px;padding:12px;background:#fff;font-size:14px}
  .sp-service-list{display:grid;gap:14px}
  .sp-service-line{display:grid;gap:12px}
  .sp-copy-row{display:flex;gap:8px;align-items:stretch}
  .sp-copy-row .sp-input,
  .sp-copy-row .sp-textarea{flex:1}
  .sp-copy-row .sp-textarea{min-height:80px}
  .sp-copy-row .sp-btn{white-space:nowrap}
  .sp-hint{font-size:12px;color:var(--sp-muted);margin-top:6px}
  .sp-hint[data-state="loading"]{color:#2563eb}
  .sp-hint[data-state="success"]{color:#047857}
  .sp-hint[data-state="warn"]{color:#b45309}
  .sp-hint[data-state="error"]{color:#b91c1c}
  .sp-divider{height:1px;background:var(--sp-border);margin:12px 0}
  .sp-chip{border:1px dashed var(--sp-border);padding:4px 8px;border-radius:999px;font-size:12px;color:var(--sp-muted)}
  .sp-chip.is-success{background:#ecfdf5;color:#047857;border-color:#bbf7d0}
  .sp-chip.is-error{background:#fef2f2;color:#b91c1c;border-color:#fecaca}
  .sp-chip.is-info{background:#eff6ff;color:#1d4ed8;border-color:#bfdbfe}
  .sp-chip.is-warn{background:#fffbeb;color:#b45309;border-color:#fde68a}
  .sp-floating-actions{
    position:fixed;
    left:0;
    right:0;
    bottom:0;
    z-index:9998;
    display:flex;
    gap:8px;
    padding:8px 10px;
    background:var(--sp-card);
    border:1px solid var(--sp-border);
    border-radius:0;
    box-shadow:0 4px 12px rgba(0,0,0,.1);
    align-items:center;
    justify-content:center;
    flex-direction:row;
    flex-wrap:nowrap;
    max-width:none;
    width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }
  .sp-floating-actions .sp-fab{
    appearance:none;
    border:1px solid var(--sp-border);
    background:var(--sp-bg);
    color:var(--sp-ink);
    border-radius:12px;
    padding:10px 12px;
    font-weight:800;
    min-width:48px;
    display:flex;
    align-items:center;
    gap:8px;
    cursor:pointer;
    transition:transform .02s ease, border-color .2s ease, background .2s ease;
    width:auto;
    flex:0 0 auto;
    white-space:nowrap;
  }
  .sp-floating-actions .sp-fab.danger{
    background:#ef4444;
    border-color:#b91c1c;
    color:#fff;
  }
  .sp-floating-actions .sp-fab:active{ transform:translateY(1px); }
  .sp-floating-actions .sp-fab-icon{
    display:grid;
    place-items:center;
    width:22px;
    height:22px;
    border-radius:8px;
    background:var(--sp-green);
    color:#fff;
    font-size:12px;
    font-weight:900;
  }
  .sp-floating-actions .sp-fab.danger .sp-fab-icon{
    background:#b91c1c;
  }
  .sp-floating-actions .sp-fab[disabled]{ opacity:0.5; cursor:not-allowed; }
  @media(max-width:719px){
    .sp-floating-actions{
      inset-inline:0;
      transform:none;
      left:0;
      right:0;
      justify-content:center;
      bottom:0;
      flex-direction:row;
      align-items:center;
      width:100%;
      max-width:none;
    }
    .sp-floating-actions .sp-fab{ flex:0 0 auto; justify-content:center; }
  }

  #sp-map{
    width:100%;
    height:580px;
    border-radius:12px;
    overflow:hidden;
  }
  .sp-map-note{
    margin-top:8px;
    font-size:12px;
    color:var(--sp-muted);
  }
  .sp-number.is-map-linked{
    background:#f5f3ff;
    border-color:rgba(79,70,229,0.35);
  }
  .sp-number.is-map-linked input{
    background:transparent;
  }
  .sp-number.is-map-linked .sp-step{
    opacity:0.5;
    cursor:not-allowed;
  }
  .sp-btn[disabled]{
    opacity:0.55;
    cursor:not-allowed;
  }
  /* Fence type visibility */
  .sp-card.is-wood [data-wrought-only]{ display:none !important; }
  .sp-card:not(.is-wood) [data-wood-only]{ display:none !important; }

  .sp-modal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.35);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
    z-index:9999;
  }
  .sp-modal.is-open{ display:flex; }
  .sp-modal-card{
    width:min(680px, 100%);
    max-height:90vh;
    overflow:auto;
    border-radius:var(--sp-radius);
    box-shadow:0 20px 60px rgba(0,0,0,0.16);
  }
  .sp-manual-scenario{
    display:grid;
    gap:12px;
    padding:12px;
    border:1px dashed var(--sp-border);
    border-radius:12px;
    background:#f8fafc;
  }
  @media(min-width:720px){
    .sp-manual-scenario{
      grid-template-columns:160px minmax(0,1fr);
      align-items:center;
    }
  }

  /* === Strong Perimeter redesign (matches mockup) === */
  :root{
    --sp-green:#004B3D;
    --sp-green-dark:#003428;
    --sp-ink:#f4f0e6;
    --sp-muted:#c9d2ca;
    --sp-border:#586F61;
    --sp-bg:#0f3a31;
    --sp-card:#0f3a31;
    --sp-radius:18px;
    --sp-stage-bg:#0b2c25;
    --sp-accent:#C04F23;
    --sp-accent-strong:#A8441D;
    --sp-input-bg:#f4ead8;
    --sp-input-text:#1f2a23;
    --sp-shadow:0 16px 30px rgba(10,18,14,0.35);
    --sp-floating-offset:112px;
  }
  body{
    background:var(--sp-stage-bg);
    background-image:
      radial-gradient(1200px 700px at 10% -20%, rgba(192,79,35,0.18) 0%, rgba(192,79,35,0) 60%),
      radial-gradient(900px 600px at 85% -10%, rgba(88,111,97,0.45) 0%, rgba(88,111,97,0) 55%),
      repeating-linear-gradient(135deg, rgba(255,255,255,0.04) 0px, rgba(255,255,255,0.04) 2px, transparent 2px, transparent 10px);
  }
  #sp-scope{
    font-family:"Work Sans","Segoe UI","Helvetica Neue",sans-serif;
    color:var(--sp-ink);
  }
  .sp-container{
    max-width:1320px;
    padding:28px 24px calc(52px + var(--sp-floating-offset, 0px));
  }
  .sp-header{
    background:var(--sp-green);
    border:1px solid var(--sp-border);
    border-radius:var(--sp-radius);
    padding:18px 20px;
    box-shadow:var(--sp-shadow);
    gap:16px;
    position:relative;
    overflow:hidden;
    width:100%;
  }
  .sp-header::after{
    content:"";
    position:absolute;
    inset:0;
    background:
      radial-gradient(360px 120px at 10% 0%, rgba(192,79,35,0.16), transparent 70%),
      radial-gradient(420px 140px at 90% 10%, rgba(255,255,255,0.06), transparent 75%);
    pointer-events:none;
  }
  .sp-brand{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width:220px;
    position:relative;
    z-index:1;
  }
  .sp-title{
    font-family:"Cinzel","Times New Roman",serif;
    font-size:28px;
    letter-spacing:0.5px;
    display:flex;
    align-items:center;
    gap:12px;
  }
  .sp-title-text{
    font-size:26px;
    letter-spacing:0.5px;
  }
  .sp-logo{
    height:38px;
    width:auto;
    display:block;
  }
  .sp-logo-panel{
    margin-top:12px;
    padding:10px 12px;
    border-radius:12px;
    background:#f4ead8;
    border:1px solid #d6c7ae;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .sp-logo-panel img{
    height:28px;
    width:auto;
  }
  .sp-subtitle{
    font-size:13px;
    color:var(--sp-muted);
    max-width:560px;
    text-transform:uppercase;
    letter-spacing:0.08em;
  }
  .sp-badge{
    background:var(--sp-accent);
    color:#1f1206;
    letter-spacing:0.12em;
    text-transform:uppercase;
  }
  .sp-actions{
    gap:8px;
    position:relative;
    z-index:1;
  }
  .sp-layout{
    display:grid;
    gap:20px;
    align-items:start;
    width:100%;
  }
  .sp-main{
    display:grid;
    gap:16px;
    min-width:0;
  }
  .sp-side{
    display:grid;
    gap:16px;
    min-width:0;
  }
  @media(min-width:980px){
    .sp-layout{ grid-template-columns:minmax(0,1fr) 360px; }
    .sp-side{ position:sticky; top:20px; }
    .sp-onboard .sp-layout{ grid-template-columns:minmax(0,1fr); }
  }
  @media(max-width:719px){
    .sp-container{ padding:20px 16px calc(44px + var(--sp-floating-offset, 0px)); }
    .sp-header{ padding:16px 14px; }
    .sp-title{ font-size:24px; }
    .sp-title-text{ font-size:22px; }
    .sp-logo{ height:32px; }
    .sp-btn{ text-align:center; }
  }
  .sp-inline-cards{
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
  }
  .sp-card{
    padding:18px;
    border-radius:var(--sp-radius);
    background:linear-gradient(180deg, rgba(0,75,61,0.92) 0%, rgba(0,52,40,0.98) 100%);
    border:1px solid var(--sp-border);
    box-shadow:var(--sp-shadow);
    position:relative;
  }
  .sp-card::before{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    pointer-events:none;
    box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);
  }
  .sp-card-header{
    margin-bottom:12px;
    padding-bottom:10px;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .sp-card-title{
    font-family:"Cinzel","Times New Roman",serif;
    font-size:18px;
    color:#f6f2e8;
  }
  .sp-card.is-collapsed .sp-card-header{ margin-bottom:0; }
  .sp-field{ gap:8px; }
  .sp-label{
    font-size:11px;
    letter-spacing:0.18em;
    color:var(--sp-muted);
    text-transform:uppercase;
  }
  .sp-input,.sp-select,.sp-textarea{
    border:1px solid #c8b79f;
    background:var(--sp-input-bg);
    color:var(--sp-input-text);
    border-radius:10px;
    padding:11px 12px;
    font-size:14px;
    transition:border-color .2s ease, box-shadow .2s ease;
  }
  .sp-output-value{
    border:1px dashed rgba(200,183,159,0.65);
    border-radius:10px;
    padding:11px 12px;
    font-size:14px;
    font-weight:600;
    color:var(--sp-ink);
    background:rgba(244,234,216,0.18);
    min-height:42px;
    display:flex;
    align-items:center;
  }
  .sp-output-value:empty::before{
    content:attr(data-placeholder);
    color:#8a7a66;
    font-weight:500;
  }
  .sp-input::placeholder,.sp-textarea::placeholder{
    color:#8a7a66;
  }
  .sp-input:focus,.sp-select:focus,.sp-textarea:focus{
    outline:none;
    border-color:var(--sp-accent);
    box-shadow:0 0 0 3px rgba(192,79,35,0.25);
  }
  .sp-number{
    border-radius:12px;
    border:1px solid #c8b79f;
    background:var(--sp-input-bg);
  }
  .sp-number input{
    background:transparent;
    color:var(--sp-input-text);
  }
  .sp-step{
    background:#e7dcc7;
    color:#1f2a23;
  }
  .sp-hint{
    color:var(--sp-muted);
  }
  .sp-btn{
    border-radius:999px;
    padding:10px 18px;
    font-weight:700;
    border:1px solid var(--sp-border);
    background:var(--sp-green);
    color:#f5efe6;
    box-shadow:0 6px 12px rgba(10,18,14,0.35);
  }
  .sp-btn.primary{
    background:var(--sp-accent);
    border-color:var(--sp-accent-strong);
    color:#1f1206;
    box-shadow:0 10px 18px rgba(192,79,35,0.35);
  }
  .sp-btn.ghost{
    background:transparent;
    border-color:var(--sp-border);
  }
  .sp-btn.danger{
    background:#3a2c2c;
    color:#f9d1d1;
    border-color:#6b3a3a;
  }
  .sp-btn.danger.is-confirm{
    background:#b91c1c;
    border-color:#b91c1c;
    color:#fff;
  }
  .sp-chip{
    border:1px solid var(--sp-border);
    background:rgba(88,111,97,0.25);
    color:#f2e7d4;
  }
  .sp-chip.is-info{
    background:#2a3850;
    color:#cfe0ff;
    border-color:#394e6b;
  }
  .sp-chip.is-success{
    background:#2c3f34;
    color:#ccebd9;
    border-color:#3e5b4c;
  }
  .sp-chip.is-warn{
    background:#4a3b25;
    color:#f5d39b;
    border-color:#6a512e;
  }
  .sp-chip.is-error{
    background:#4a2a2a;
    color:#f7c7c7;
    border-color:#6a3939;
  }
  .sp-scope-group{
    border-radius:14px;
    background:rgba(88,111,97,0.18);
    border:1px solid var(--sp-border);
  }
  .sp-scope-pill{
    letter-spacing:0.16em;
  }
  .sp-scope-group.is-basics{ --accent:#6fb28f; background:#2b3b33; }
  .sp-scope-group.is-wood{ --accent:#d0893a; background:#3a2f24; }
  .sp-scope-group.is-style{ --accent:#8aa3ff; background:#2a3344; }
  .sp-scope-group.is-repair{ --accent:#f36a6a; background:#3a2a2a; }
  .sp-scope-group.is-gates{ --accent:#68b7d8; background:#253642; }

  #sp-map{
    border:1px solid var(--sp-border);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06);
  }

  .sp-output{
    margin-top:0;
  }
  .sp-output textarea{
    min-height:180px;
    background:#f7efdf;
    color:#1f2a23;
  }

  .sp-guide{
    display:grid;
    gap:12px;
  }
  .sp-guide-item{
    display:grid;
    grid-template-columns:32px 1fr;
    gap:12px;
    align-items:start;
  }
  .sp-guide-step{
    width:32px;
    height:32px;
    border-radius:10px;
    background:var(--sp-accent);
    color:#1f1206;
    font-weight:800;
    display:grid;
    place-items:center;
  }
  .sp-guide-title{
    font-weight:700;
  }
  .sp-guide-sub{
    color:var(--sp-muted);
    font-size:13px;
  }
  .sp-jump{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
  }
  .sp-jump-link{
    text-decoration:none;
    color:#f4f0e6;
    background:var(--sp-green);
    border:1px solid var(--sp-border);
    border-radius:999px;
    padding:6px 10px;
    font-size:12px;
    font-weight:700;
  }
  .sp-jump-link:hover{
    border-color:var(--sp-accent);
  }

  .sp-floating-actions{
    background:rgba(0,75,61,0.92);
    backdrop-filter:blur(6px);
    border-top:1px solid var(--sp-border);
    box-shadow:0 -10px 20px rgba(8,14,11,0.45);
  }
  .sp-floating-actions .sp-fab{
    border-radius:999px;
    background:var(--sp-green);
    border-color:var(--sp-border);
    color:#f4f0e6;
  }
  .sp-floating-actions .sp-fab-icon{
    background:var(--sp-accent);
    color:#1f1206;
  }
  .sp-floating-actions .sp-fab.danger{
    background:#3a2c2c;
    color:#f7c7c7;
    border-color:#6a3939;
  }
  .sp-floating-actions .sp-fab.danger .sp-fab-icon{
    background:#b91c1c;
    color:#fff;
  }

  .sp-modal{
    background:rgba(10,16,12,0.7);
  }
  .sp-modal-card{
    background:linear-gradient(180deg, rgba(0,75,61,0.95) 0%, rgba(0,52,40,0.98) 100%);
    border:1px solid var(--sp-border);
  }

  @keyframes sp-fade-up{
    from{ opacity:0; transform:translateY(10px); }
    to{ opacity:1; transform:translateY(0); }
  }
  .sp-card,
  .sp-scope-group{
    animation:sp-fade-up .45s ease both;
  }
  @media (prefers-reduced-motion: reduce){
    .sp-card,
    .sp-scope-group{
      animation:none;
    }
    *{
      transition:none !important;
    }
  }

  /* === Brand palette refresh (clear separation) === */
  :root{
    --sp-green:#004B3D;
    --sp-green-dark:#003328;
    --sp-ink:#1b2a23;
    --sp-muted:#586F61;
    --sp-border:#cfdad3;
    --sp-bg:#f5f7f5;
    --sp-card:#ffffff;
    --sp-radius:16px;
    --sp-stage-bg:#f4f7f5;
    --sp-accent:#C04F23;
    --sp-accent-strong:#A8441D;
    --sp-input-bg:#ffffff;
    --sp-input-text:#1b2a23;
    --sp-shadow:0 10px 22px rgba(0,0,0,0.08);
    --sp-floating-offset:112px;
  }
  body{
    background:var(--sp-stage-bg);
    background-image:
      radial-gradient(900px 480px at 10% -10%, rgba(0,75,61,0.08) 0%, rgba(0,75,61,0) 60%),
      radial-gradient(820px 520px at 90% -20%, rgba(88,111,97,0.18) 0%, rgba(88,111,97,0) 55%),
      repeating-linear-gradient(135deg, rgba(0,0,0,0.02) 0px, rgba(0,0,0,0.02) 2px, transparent 2px, transparent 10px);
  }
  #sp-scope{
    font-family:"Open Sans","Segoe UI","Helvetica Neue",sans-serif;
    color:var(--sp-ink);
  }
  .sp-header{
    background:var(--sp-green);
    border-color:var(--sp-green-dark);
    color:#f4f7f5;
  }
  .sp-title,
  .sp-card-title{
    font-family:"Open Sans","Segoe UI","Helvetica Neue",sans-serif;
    letter-spacing:0.2px;
    color:inherit;
  }
  .sp-title-text{
    font-size:24px;
    font-weight:700;
    color:#ffffff;
  }
  .sp-subtitle{
    color:#d8e5df;
    text-transform:none;
    letter-spacing:0.02em;
  }
  .sp-header .sp-btn{
    background:rgba(255,255,255,0.12);
    border-color:rgba(255,255,255,0.35);
    color:#ffffff;
  }
  .sp-header .sp-btn.primary{
    background:var(--sp-accent);
    border-color:var(--sp-accent-strong);
    color:#1f1206;
  }
  .sp-card{
    background:var(--sp-card);
    border-color:var(--sp-border);
    box-shadow:var(--sp-shadow);
  }
  .sp-card::before{
    box-shadow:none;
  }
  .sp-card-header{
    background:#f1f5f3;
    border:1px solid var(--sp-border);
    border-radius:12px;
    padding:12px 14px;
    margin-bottom:14px;
  }
  .sp-card-title{
    color:var(--sp-ink);
    font-weight:700;
  }
  .sp-label{
    color:var(--sp-muted);
    letter-spacing:0.12em;
  }
  .sp-input,.sp-select,.sp-textarea{
    border:1px solid #c3d0c9;
    background:var(--sp-input-bg);
    color:var(--sp-input-text);
  }
  .sp-input::placeholder,.sp-textarea::placeholder{
    color:#7b8a82;
  }
  .sp-input:focus,.sp-select:focus,.sp-textarea:focus{
    border-color:var(--sp-accent);
    box-shadow:0 0 0 3px rgba(192,79,35,0.18);
  }
  .sp-number{
    background:#fff;
    border-color:#c3d0c9;
  }
  .sp-step{
    background:#eef3f1;
    color:#1b2a23;
  }
  .sp-hint{
    color:var(--sp-muted);
  }
  .sp-btn{
    background:#ffffff;
    color:var(--sp-green);
    border-color:var(--sp-green);
    box-shadow:0 6px 12px rgba(0,0,0,0.08);
  }
  .sp-btn.primary{
    background:var(--sp-accent);
    border-color:var(--sp-accent-strong);
    color:#1f1206;
  }
  .sp-btn.ghost{
    background:transparent;
    border-color:#c3d0c9;
    color:var(--sp-green);
  }
  .sp-header .sp-btn.ghost{
    background:rgba(255,255,255,0.18);
    border-color:rgba(255,255,255,0.55);
    color:#ffffff;
  }
  .sp-card-header .sp-row .sp-btn,
  .sp-copy-row .sp-btn{
    padding:8px 12px;
    font-size:13px;
    min-height:36px;
  }
  @media(min-width:720px){
    .sp-card-header .sp-row{
      flex-wrap:nowrap;
    }
    .sp-card-header .sp-row .sp-btn{
      white-space:nowrap;
    }
  }
  .sp-chip{
    background:#f1f5f3;
    border-color:#d6dfd8;
    color:var(--sp-green);
  }
  .sp-chip.is-info{
    background:#edf4ff;
    color:#1d4ed8;
    border-color:#cfe0ff;
  }
  .sp-chip.is-success{
    background:#e9f6ef;
    color:#0f7b4d;
    border-color:#cbe9d8;
  }
  .sp-chip.is-warn{
    background:#fff3e8;
    color:#a3541c;
    border-color:#f5d4be;
  }
  .sp-chip.is-error{
    background:#ffecec;
    color:#b91c1c;
    border-color:#fecaca;
  }
  .sp-scope-group{
    background:#f6f9f7;
    border-color:#d6dfd8;
  }
  .sp-scope-group.is-basics{ --accent:#0f766e; background:#eef6f3; }
  .sp-scope-group.is-wood{ --accent:#c27b2f; background:#fbf2ea; }
  .sp-scope-group.is-style{ --accent:#1d4ed8; background:#eef2ff; }
  .sp-scope-group.is-repair{ --accent:#b91c1c; background:#fff1f2; }
  .sp-scope-group.is-gates{ --accent:#0284c7; background:#e6f4fb; }
  #sp-map{
    border-color:#c3d0c9;
    box-shadow:inset 0 0 0 1px rgba(0,0,0,0.04);
  }
  .sp-output textarea{
    background:#ffffff;
    color:var(--sp-ink);
  }
  .sp-guide-step{
    background:var(--sp-accent);
    color:#1f1206;
  }
  .sp-jump-link{
    background:#ffffff;
    border-color:#d6dfd8;
    color:var(--sp-green);
  }
  .sp-floating-actions{
    background:rgba(255,255,255,0.95);
    border-top:1px solid #d6dfd8;
    box-shadow:0 -8px 18px rgba(0,0,0,0.08);
  }
  .sp-floating-actions .sp-fab{
    background:#ffffff;
    border-color:#d6dfd8;
    color:var(--sp-green);
  }
  .sp-floating-actions .sp-fab-icon{
    background:var(--sp-green);
    color:#ffffff;
  }
  .sp-floating-actions .sp-fab.danger{
    background:#ffecec;
    border-color:#fecaca;
    color:#b91c1c;
  }
  .sp-floating-actions .sp-fab.danger .sp-fab-icon{
    background:#b91c1c;
    color:#ffffff;
  }
  .sp-card.is-unconfirmed{
    border-color:var(--sp-accent);
    box-shadow:0 0 0 2px rgba(192,79,35,0.28), var(--sp-shadow);
  }
  .sp-modal{
    background:rgba(0,0,0,0.45);
  }
  .sp-modal-card{
    background:#ffffff;
    border:1px solid #d6dfd8;
    color:var(--sp-ink);
  }
  .sp-logo-panel{
    background:#ffffff;
    border-color:#d6dfd8;
  }
  </style>
</head>
<body>
<div id="sp-scope" class="sp-onboard">
    <div class="sp-container">
      <div class="sp-header">
        <div class="sp-brand">
          <div class="sp-title">
            <img class="sp-logo" src="assets/strong-perimeter-logo-white.svg" alt="Strong Perimeter" />
          </div>
          <div class="sp-subtitle">Internal Scope Generator</div>
        </div>
        <div class="sp-actions">
          <button class="sp-btn ghost" id="sp-open-manual" type="button">Manual Quote</button>
          <button class="sp-btn ghost" id="sp-open-import" type="button">Reload from Notes</button>
          <button class="sp-btn is-hidden" id="sp-refresh-materials" type="button" data-gated>Update Material Costs</button>
        </div>
      </div>

    <div class="sp-modal" id="sp-manual-modal" aria-hidden="true" role="dialog" aria-labelledby="sp-manual-title">
      <div class="sp-card sp-modal-card" id="sp-manual-quote-card">
        <div class="sp-card-header">
          <div class="sp-card-title" id="sp-manual-title">Manual Quote</div>
          <div class="sp-row">
            <button class="sp-btn ghost" id="sp-manual-close" type="button">Close</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-cost">Total Material &amp; Equipment Costs</label>
            <div class="sp-row">
              <input class="sp-input" id="sp-manual-cost" type="number" inputmode="decimal" step="0.01" min="0" placeholder="Enter materials &amp; equipment (e.g., 4500)" />
            </div>
            <div class="sp-hint" id="sp-manual-status"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-hours">Total hours (onsite)</label>
            <input class="sp-input" id="sp-manual-hours" type="number" inputmode="decimal" step="0.1" min="0" placeholder="e.g., 6.5" />
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-charge">Recommended Charge</label>
            <div class="sp-row">
              <div class="sp-output-value" id="sp-manual-charge" data-placeholder="$0.00" role="status" aria-live="polite"></div>
              <span class="sp-chip is-info" id="sp-manual-mode" style="display:none">Pricing</span>
            </div>
          </div>
        </div>
        <div class="sp-divider"></div>
        <div class="sp-grid">
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-gross">Total gross</label>
            <div class="sp-output-value" id="sp-manual-gross" data-placeholder="$0.00"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-gross-hour">Gross per hour</label>
            <div class="sp-output-value" id="sp-manual-gross-hour" data-placeholder="$0.00"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-commission">Commission</label>
            <div class="sp-output-value" id="sp-manual-commission" data-placeholder="$0.00"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-net">Net $</label>
            <div class="sp-output-value" id="sp-manual-net" data-placeholder="$0.00"></div>
          </div>
        </div>
        
      </div>
    </div>

    <div class="sp-modal" id="sp-import-modal" aria-hidden="true" role="dialog" aria-labelledby="sp-import-title">
      <div class="sp-card sp-modal-card" id="sp-import-modal-card">
        <div class="sp-card-header">
          <div class="sp-card-title" id="sp-import-title">Reload from Notes</div>
          <div class="sp-row">
            <button class="sp-btn ghost" id="sp-import-close" type="button">Close</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <div class="sp-row">
              <button class="sp-btn" id="sp-import-btn" type="button">Load Notes</button>
              <button class="sp-btn ghost" id="sp-import-clear" type="button">Clear</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-import-text">Paste saved notes</label>
            <textarea class="sp-textarea" id="sp-import-text" placeholder="Paste previously generated notes to restore sections and map info..."></textarea>
            <div class="sp-hint" id="sp-import-status">Paste notes that include the embedded reload key added by this generator.</div>
          </div>
        </div>
      </div>
    </div>

    <div class="sp-layout">
      <div class="sp-main">
        <div class="sp-inline-cards">
      <div class="sp-card" id="sp-hcp-card">
        <div class="sp-card-header">
          <div class="sp-card-title">Housecall Pro Estimate</div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-estimate-number">Estimate Number from Housecall Pro</label>
            <input class="sp-input" id="sp-estimate-number" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="123456" />
            <div class="sp-row" style="margin-top:8px">
              <button class="sp-btn ghost" id="sp-estimate-lookup" type="button">Fetch Estimate Address</button>
              <button class="sp-btn" id="sp-proceed-no-estimate" type="button">Proceed Without Estimate</button>
            </div>
            <div class="sp-hint">Enter the estimate number and click “Fetch Estimate Address” to load the service address from Housecall Pro.</div>
            <div class="sp-hint" id="sp-estimate-status" aria-live="polite"></div>
          </div>
        </div>
      </div>

      <div class="sp-card is-unconfirmed" id="sp-customer-card" data-gated>
        <div class="sp-card-header">
          <div class="sp-card-title">Customer Type</div>
          <div class="sp-row">
            <button class="sp-btn ghost" id="sp-customer-confirm" type="button">Confirm</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-customer-type">Customer Type</label>
            <select class="sp-select" id="sp-customer-type">
              <option value="Residential">Residential</option>
              <option value="Commercial">Commercial</option>
              <option value="City">City</option>
            </select>
            <div class="sp-hint" id="sp-customer-min-hint">Minimum charge: $350</div>
          </div>
        </div>
      </div>
    </div>

    <div class="sp-card is-collapsed" id="sp-map-card" data-gated>
      <div class="sp-card-header">
        <div class="sp-card-title">Map Measurements</div>
        <div class="sp-row">
          <button class="sp-btn ghost" id="sp-map-toggle" type="button" aria-expanded="false">Expand Map</button>
          <button class="sp-btn ghost" id="sp-map-clear" type="button" disabled>Clear Map Sections</button>
        </div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-12">
          <label class="sp-label" for="sp-map-address">Search Address</label>
          <input class="sp-input" id="sp-map-address" type="text" placeholder="Search for a property" autocomplete="off" />
        </div>
        <div class="col-12">
          <div id="sp-map"></div>
          <div class="sp-map-note">Draw polylines to trace each fence run. Segments automatically create scope sections, stay in sync as you edit, and can be cleared with the button above. Right-click a line to remove vertices or delete the entire run.</div>
        </div>
      </div>
    </div>

    <div id="sp-sections" class="sp-sections" data-gated></div>

    <div class="sp-card" id="sp-crew-card" data-gated>
      <div class="sp-card-header">
        <div class="sp-card-title">Labor</div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-6">
          <label class="sp-label">Labor Rate</label>
          <input class="sp-input" id="sp-labor-rate" type="text" readonly />
          <div class="sp-hint">Applies to total time on site and travel time.</div>
        </div>
      </div>
    </div>

      </div>
      <aside class="sp-side" data-gated>
    <div class="sp-output" id="sp-output" style="display:none">
      <div class="sp-card">
        <div class="sp-card-header">
          <div class="sp-card-title">Notes</div>
          <div class="sp-row">
            <span class="sp-chip" id="sp-totals-chip" title="Auto-calculated across sections">Totals included</span>
            <button class="sp-btn" id="sp-copy" type="button">Copy Notes</button>
            <button class="sp-btn primary" id="sp-push-hcp" type="button">Push Notes to HCP</button>
          </div>
        </div>
        <textarea id="sp-notes" readonly></textarea>
        <div class="sp-hint">These notes are formatted for easy paste into your CRM or internal documentation.</div>
      </div>

      <div class="sp-card" id="sp-sub">
        <div class="sp-card-header">
          <div class="sp-card-title">Notes for Sub</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-sub" type="button">Copy Notes</button>
          </div>
        </div>
        <textarea id="sp-notes-sub" readonly></textarea>
        <div class="sp-hint">Crew-facing summary: duration, materials, and total repairs.</div>
      </div>

      <div class="sp-card" id="sp-service-card" style="display:none">
        <div class="sp-card-header">
          <div class="sp-card-title">Service Line Items</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-service" type="button" disabled>Copy All</button>
          </div>
        </div>
        <div class="sp-service-list" id="sp-service-lines"></div>
        <div class="sp-hint">Use the copy buttons to grab titles or descriptions individually.</div>
      </div>
    </div>
      </aside>
    </div>
  </div>
</div>

<div class="sp-floating-actions" id="sp-quick-actions" aria-label="Quick actions" data-gated>
  <button class="sp-fab" id="sp-quick-add" type="button">
    <span class="sp-fab-icon">＋</span>
    <span>Add</span>
  </button>
  <button class="sp-fab" id="sp-quick-dup-first" type="button" aria-label="Copy 1st Style">
    <span class="sp-fab-icon">⧉</span>
    <span>1st</span>
  </button>
  <button class="sp-fab" id="sp-quick-dup-last" type="button" aria-label="Copy Latest Style">
    <span class="sp-fab-icon">⧉</span>
    <span>Latest</span>
  </button>
  <button class="sp-fab danger" id="sp-reset" type="button" aria-label="Reset">
    <span class="sp-fab-icon">⟳</span>
  </button>
  <button class="sp-fab" id="sp-top-btn" type="button" aria-label="Back to top">
    <span class="sp-fab-icon">↑</span>
  </button>
  <button class="sp-fab" id="sp-bottom-btn" type="button" aria-label="Jump to bottom">
    <span class="sp-fab-icon">↓</span>
  </button>
</div>
<script src="https://cdn.jsdelivr.net/npm/iframe-resizer/js/iframeResizer.contentWindow.min.js"></script>
<script>
window._spGoogleMapsReady = window._spGoogleMapsReady || false;
window._spInitializeMap = window._spInitializeMap || null;
window.initMap = function(){
  window._spGoogleMapsReady = true;
  if (typeof window._spInitializeMap === 'function') {
    window._spInitializeMap();
  }
};
document.addEventListener('DOMContentLoaded', function(){
  document.title = 'Scope Generator';
  (function initMaterialsRefresh(){
    var btn = document.getElementById('sp-refresh-materials');
    if(!btn || typeof fetch !== 'function') return;

    var defaultText = 'Update Material Costs';
    var successText = 'Materials Updated';

    function setState(state){
      btn.dataset.state = state;
      btn.disabled = state === 'loading';
      btn.classList.toggle('primary', state === 'success');

      if(state === 'loading'){
        btn.textContent = 'Updating materials...';
      } else if(state === 'success'){
        btn.textContent = successText;
      } else {
        btn.textContent = defaultText;
      }
    }

    btn.addEventListener('click', function(){
      setState('loading');
      fetch('https://api.strongclicks.io/webhook/scopegenerator-get-materials', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
      }).then(function(res){
        if(!res.ok){
          throw new Error('Material refresh failed with status ' + res.status);
        }
        return res.json();
      }).then(function(payload){
        setState('success');
        if(payload){
          console.info('Material catalog refreshed from Housecall Pro.');
        }
      }).catch(function(err){
        setState('idle');
        console.warn('Unable to refresh material catalog', err);
      });
    });
  })();
  (function setBackground(){
    var root = document.documentElement;
    if(!root) return;
    var href = window.location.href || '';
    if(href.indexOf('https://stagescope.strongperimeter.com/') !== -1){
      root.style.setProperty('--sp-stage-bg', '#fdf5c2');
    } else {
      root.style.setProperty('--sp-stage-bg', '#EBEBEB');
    }
  })();
  // Set favicon
  (function setFavicon(){
    var href = 'assets/strong-perimeter-favicon.svg';
    var head = document.head || document.getElementsByTagName('head')[0];
    if (!head) return;
    var olds = head.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
    olds.forEach(function(el){ el.parentNode.removeChild(el); });
    var link = document.createElement('link');
    link.rel = 'icon';
    link.type = 'image/svg+xml';
    link.href = href;
    head.appendChild(link);
  })();
(function(){
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  const SEED = {
    style:["Flat Top","Flat Top w/ Puppy Pickets","Extended Picket","Extended Picket w/ Finials"],
    height:["3ft","4ft","5ft","6ft","8ft"],
    railSize:["1\u201D","3/4\u201D","1/2\u201D","1 \u00BC\u201D","1 \u00BD\u201D","1 \u00BE\u201D","1x2\u201D","2\u201D","3\u201D","Flat Bar 1/4\" x 1\""],
    picketSize:["1/2\u201D","5/8\u201D","3/4\u201D","1\u201D"],
    postSize:["1 1/2\" x 1 1/2\"","2x2","3x3","4x4"],
    postRealignSize:["2x2","3x3"],
    puppy:["None","Puppy Pickets","Puppy Pickets w/ Finials","Puppy Pickets Full Height","Puppy Pickets Full Height w/ Finials"],
    // NEW: finials
    finialStyles:["Quad Star","Banana Split","Boy Scout","Ball"],
    finialMaterials:["Cast Iron","Aluminum","Plastic"],
    // NEW: post caps
    capStyles:["Pyramid","Pressed","Ball"],
    capMaterials:["Cast Iron","Plastic","Metal"],
    capPostSizes:["1 1/2\" x 1 1/2\"","2x2","3x3","4x4"],
  };

  const WOOD_PICKET_WIDTHS = ['3.5"','4"','5.5"','6"'];
  const WOOD_RAIL_SIZES = ['2x3','2x4'];
  const WOOD_TRIM_TYPES = ['1x2','1x4','1x4 & 1x2'];
  const NO_TIES_OPTION = 'No ties';
  const SIMPSON_TIE_OPTIONS = ['1 piece ties','2 piece ties', NO_TIES_OPTION];
  const WOOD_POST_CAP_TYPES = ['Dome cap','Flat cap'];
  const WOOD_POST_METHODS = [
    { value: 'cut-weld', label: 'Cut & Weld' },
    { value: 'dig-straighten', label: 'Dig, straighten, add concrete' }
  ];
  const WOOD_POST_INSTALL_METHODS = [
    { value: 'drive-posts', label: 'Drive the posts' },
    { value: 'dig-set-concrete', label: 'Dig, set, add concrete' }
  ];

  const POST_REALIGN_METHODS = [
    { value: 'concrete', label: 'Concrete' },
    { value: 'cut-weld', label: 'Cut & Weld' }
  ];

  const PUPPY_INSERT_SIZES = ['1/2"','5/8"'];
  const PANEL_REPLACEMENT_STYLES = [...SEED.style, 'Flat Top w/ Puppy Picket Insert'];
  const CUSTOMER_TYPES = ['Residential','Commercial','City'];

  const GATE = {
    latchTypes: [
      'Gravity Latch',
      'Short Pool Latch',
      'Tall Pool Latch',
      'Single Lock Box',
      'Double Lock Box'
    ],
    hingeTypes: [
      'Door Hinges',
      'Bat Wing Hinges',
      'Auto Close Hinges'
    ]
  };
  const DRIVE_GATE_OPERATOR_TYPES = ['Single Swing','Double Swing','Sliding'];
  const DRIVE_GATE_POWER_TYPES = ['Existing Wiring','New Wiring','Solar'];
  const DRIVE_GATE_POWER_TYPES_INSTALL = DRIVE_GATE_POWER_TYPES.filter(t=> t !== 'Existing Wiring');
  const DRIVE_GATE_OPERATOR_DETAILS = {
    'Single Swing': {
      label: 'LiftMaster LA400PKGUL Swing Gate Operator',
      unitCost: 1866.23
    },
    'Double Swing': {
      label: 'LiftMaster LA400PKGUL Dual Swing Gate Operator',
      unitCost: 2601.25
    },
    'Sliding': {
      label: 'LiftMaster CSL24UL 24VDC High Traffic Commercial Slide Gate Operator',
      unitCost: 2596.92
    }
  };
  const DRIVE_GATE_OPERATOR_FALLBACK_LABEL = 'LiftMaster drive gate operator';
  function getDriveGateOperatorLabel(typeLabel){
    const key = String(typeLabel || '').trim();
    const detail = DRIVE_GATE_OPERATOR_DETAILS[key];
    return detail ? detail.label : DRIVE_GATE_OPERATOR_FALLBACK_LABEL;
  }

  const LABOR_RATE = 105;
  const CREW_SETTINGS = {
    minCrew: 1,
    maxCrew: 4,
    maxWelders: 4,
    maxDayHours: 10,
  };
  const ONSITE_CREW_SIZE = 4;
  const JOB_SETUP_HOURS = 0.25;
  const JOB_TEARDOWN_HOURS = 0.25;
  const JOB_SETUP_TEARDOWN_HOURS = JOB_SETUP_HOURS + JOB_TEARDOWN_HOURS;

  const NOTES_DATA_VERSION = 1;
  const NOTES_DATA_START = '[[SP_SCOPE_DATA_START]]';
  const NOTES_DATA_END = '[[SP_SCOPE_DATA_END]]';

  const HQ_ADDRESS = '2233 Franklin Dr Mesquite TX';
  const TRAVEL_SETTINGS = {
    dieselPrice: 3,
    mpg: 13,
    minutesPerMile: 1,
  };

  const state = { sections: [], customerType: 'Residential' };
  const mapState = {
    map: null,
    drawingManager: null,
    polylines: [],
    geocoder: null,
    autocomplete: null,
    marker: null,
    addressLocation: null,
    baseLocation: null,
    baseLocationPromise: null,
    maxZoomService: null,
    nextPolylineId: 1,
    pendingAddress: '',
  };
  let pendingMapRestore = null;
  let mapUpdateScheduled = false;

  const sectionsEl = $('#sp-sections');
  const outputEl   = $('#sp-output');
  const notesEl    = $('#sp-notes');
  const notesSubEl = $('#sp-notes-sub');
  const importTextEl = document.getElementById('sp-import-text');
  const importBtn = document.getElementById('sp-import-btn');
  const importClearBtn = document.getElementById('sp-import-clear');
  const importStatusEl = document.getElementById('sp-import-status');
  const estimateNumberInput = document.getElementById('sp-estimate-number');
  const estimateLookupBtn = document.getElementById('sp-estimate-lookup');
  const proceedWithoutEstimateBtn = document.getElementById('sp-proceed-no-estimate');
  const mapAddressInput = document.getElementById('sp-map-address');
  const mapCardEl = document.getElementById('sp-map-card');
  const mapToggleBtn = document.getElementById('sp-map-toggle');
  const estimateStatusEl = document.getElementById('sp-estimate-status');
  const defaultEstimateStatus = estimateStatusEl ? estimateStatusEl.textContent : '';
  const manualCostInput = document.getElementById('sp-manual-cost');
  const manualCalcBtn = document.getElementById('sp-manual-calc');
  const manualChargeOutput = document.getElementById('sp-manual-charge');
  const manualModeChip = document.getElementById('sp-manual-mode');
  const manualStatusEl = document.getElementById('sp-manual-status');
  const manualHoursInput = document.getElementById('sp-manual-hours');
  const manualGrossOutput = document.getElementById('sp-manual-gross');
  const manualGrossHourOutput = document.getElementById('sp-manual-gross-hour');
  const manualCommissionOutput = document.getElementById('sp-manual-commission');
  const manualNetOutput = document.getElementById('sp-manual-net');
  
  const customerTypeSelect = document.getElementById('sp-customer-type');
  const customerMinHint = document.getElementById('sp-customer-min-hint');
  const customerCardEl = document.getElementById('sp-customer-card');
  const customerConfirmBtn = document.getElementById('sp-customer-confirm');
  const manualModal = document.getElementById('sp-manual-modal');
  const manualOpenBtn = document.getElementById('sp-open-manual');
  const manualCloseBtn = document.getElementById('sp-manual-close');
  const importModal = document.getElementById('sp-import-modal');
  const importOpenBtn = document.getElementById('sp-open-import');
  const importCloseBtn = document.getElementById('sp-import-close');
  const pushHcpBtn = document.getElementById('sp-push-hcp');
  const serviceCardEl = $('#sp-service-card');
  const serviceListEl = $('#sp-service-lines');
  const serviceCopyAllBtn = $('#sp-copy-service');
  const laborRateInput = document.getElementById('sp-labor-rate');
  const estimateLookupBtnLabel = estimateLookupBtn ? estimateLookupBtn.textContent : '';
  const scopeEl = document.getElementById('sp-scope');
  let gateUnlocked = false;
  let lastServiceLines = [];
  let autoGenerateTimer = null;
  let isGeneratingNotes = false;
  let estimateLookupController = null;
  let lastEstimateLookupNumber = '';
  let lastEstimateAddress = '';
  let lastEstimateExists = false;
  let customerTypeConfirmed = false;

  function setGateUnlocked(unlocked){
    gateUnlocked = !!unlocked;
    if(!scopeEl){
      return;
    }
    scopeEl.classList.toggle('sp-onboard', !gateUnlocked);
  }

  function setCustomerTypeConfirmed(confirmed){
    customerTypeConfirmed = !!confirmed;
    if(customerCardEl){
      customerCardEl.classList.toggle('is-unconfirmed', !customerTypeConfirmed);
    }
    if(customerConfirmBtn){
      customerConfirmBtn.textContent = customerTypeConfirmed ? 'Confirmed' : 'Confirm';
      customerConfirmBtn.classList.toggle('primary', !customerTypeConfirmed);
      customerConfirmBtn.disabled = customerTypeConfirmed;
    }
  }

  setGateUnlocked(false);
  setCustomerTypeConfirmed(false);

  if(laborRateInput){
    laborRateInput.value = `$${money(LABOR_RATE)}/hr (crew rate)`;
  }

  function uid(){ return 'sec_' + Math.random().toString(36).slice(2,9); }

  function sanitizeEstimateNumber(value){
    return (value || '').replace(/[^0-9]/g, '');
  }

  function encodePayloadForNotes(payload){
    try{
      const json = JSON.stringify(payload);
      return btoa(unescape(encodeURIComponent(json)));
    }catch(err){
      console.error('Failed to encode notes payload', err);
      return '';
    }
  }

  function decodePayloadFromNotes(encoded){
    try{
      const json = decodeURIComponent(escape(atob(encoded)));
      return JSON.parse(json);
    }catch(err){
      console.error('Failed to decode notes payload', err);
      return null;
    }
  }

  function extractEmbeddedNotesData(text){
    if(!text) return '';
    const start = text.indexOf(NOTES_DATA_START);
    const end = text.indexOf(NOTES_DATA_END);
    if(start === -1 || end === -1 || end <= start) return '';
    return text.slice(start + NOTES_DATA_START.length, end).trim();
  }

  function parseLegacyNotesSnapshot(text){
    if(!text) return null;

    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const sections = [];
    let current = null;

    const parseNumber = (value)=>{
      const match = String(value||'').replace(/,/g,'').match(/-?\d+(?:\.\d+)?/);
      return match ? parseFloat(match[0]) : NaN;
    };

    const pushCurrent = ()=>{
      if(current){
        sections.push(current);
        current = null;
      }
    };

    lines.forEach(rawLine => {
      const line = normalizeLabelText(rawLine);
      if(!line) return;

      const sectionMatch = line.match(/^Section\s+\d+\s*-\s*(.+)$/i);
      if(sectionMatch){
        pushCurrent();
        const labelText = sectionMatch[1].trim();
        current = createSectionBase({});
        current.label = labelText;
        if(/map run/i.test(labelText)){
          current.mapGeneratedLabel = labelText;
        }
        return;
      }

      if(!current) return;

      const scopeMatch = line.match(/^-\s*Scope:\s*(.+)$/i);
      if(scopeMatch){
        const rawScope = scopeMatch[1].toLowerCase();
        if(/install/.test(rawScope)) current.scopeType = 'install';
        else if(/replace/.test(rawScope)) current.scopeType = 'replace';
        else current.scopeType = 'repair';
        return;
      }

      const styleMatch = line.match(/^-\s*Style:\s*(.+)$/i);
      if(styleMatch){
        current.style = styleMatch[1].trim();
        return;
      }

      const heightMatch = line.match(/^-\s*Height:\s*(.+)$/i);
      if(heightMatch){
        current.height = heightMatch[1].trim();
        return;
      }

      const railsMatch = line.match(/^-\s*Rails:\s*Top\s*Rail:\s*([^;]+);\s*Bottom\s*Rail:\s*(.+)$/i);
      if(railsMatch){
        const topRaw = railsMatch[1].trim();
        const bottomRaw = railsMatch[2].trim();
        const topStacked = /stacked/i.test(topRaw);
        const topSizes = topRaw.replace(/\(stacked\)/i,'').split('+').map(part => normalizeSize(part));
        const topSize = topSizes[0] || SEED.railSize[0];
        const topSize2 = topStacked ? (topSizes[1] || topSizes[0] || SEED.railSize[0]) : (topSizes[1] || topSizes[0]);
        const bottomSize = normalizeSize(bottomRaw || SEED.railSize[0]);
        current.rails = [
          { size: topSize, stacked: topStacked || (!!topSizes[1]), size2: topSize2 || topSize, patches:0, replacements:0 },
          { size: bottomSize || SEED.railSize[0], stacked:false, size2: bottomSize || SEED.railSize[0], patches:0, replacements:0 },
        ];
        current.railsCount = current.rails.length;
        return;
      }

      const picketMatch = line.match(/^-\s*Picket:\s*(.+)$/i);
      if(picketMatch){
        const clean = normalizeSize(picketMatch[1]);
        current.picketSize = clean || current.picketSize;
        return;
      }

      const puppyMatch = line.match(/^-\s*Puppy\s*Pickets:\s*(.+)$/i);
      if(puppyMatch){
        const val = puppyMatch[1].trim();
        current.puppy = val && !/none/i.test(val) ? 'Puppy Pickets' : 'None';
        return;
      }

      const paintingMatch = line.match(/^-\s*Painting:\s*(.+)$/i);
      if(paintingMatch){
        current.painting = paintingMatch[1].trim();
        return;
      }

      const paintMethodMatch = line.match(/^-\s*Paint\s*application:\s*(.+)$/i);
      if(paintMethodMatch){
        current.paintingApplication = paintMethodMatch[1].trim();
        return;
      }

      const prepMatch = line.match(/^-\s*Prep\s*needs:\s*(.+)$/i);
      if(prepMatch){
        current.paintingPrepExtra = /more|extra|yes|true/i.test(prepMatch[1]);
        return;
      }

      const lengthMatch = line.match(/^-\s*Length:\s*(.+)$/i);
      if(lengthMatch){
        const num = parseNumber(lengthMatch[1]);
        if(isFinite(num)) current.length = num;
        return;
      }

      const hardscapeMatch = line.match(/^-\s*Over\s*hardscape:\s*(.+)$/i);
      if(hardscapeMatch){
        const num = parseNumber(hardscapeMatch[1]);
        if(isFinite(num)) current.hardscape = num;
        return;
      }

      const trimMatch = line.match(/^-\s*Trim:\s*(.+)$/i);
      if(trimMatch){
        const num = parseNumber(trimMatch[1]);
        if(isFinite(num)) current.trim = num;
        return;
      }

      const digMatch = line.match(/^-\s*Dig\s*out:\s*(.+)$/i);
      if(digMatch){
        const num = parseNumber(digMatch[1]);
        if(isFinite(num)) current.digOut = num;
        return;
      }

      const repairPicketsMatch = line.match(/^-\s*Pickets\s*to\s*replace:\s*(.+)$/i);
      if(repairPicketsMatch){
        const num = parseNumber(repairPicketsMatch[1]);
        if(isFinite(num)) current.wiPickets = num;
        return;
      }
    });

    pushCurrent();

    if(!sections.length){
      return null;
    }

    return {
      version: NOTES_DATA_VERSION,
      generatedAt: new Date().toISOString(),
      state: { sections, customerType: getCustomerType() },
      map: { address: '', polylines: [], nextPolylineId: 1 },
      estimate: { number: '', address: '' }
    };
  }

  function updateEstimateStatus(message, state){
    if(!estimateStatusEl){
      return;
    }
    const nextState = state || (message ? 'info' : '');
    if(message){
      estimateStatusEl.textContent = message;
    }else{
      estimateStatusEl.textContent = defaultEstimateStatus || '';
    }
    if(nextState){
      estimateStatusEl.setAttribute('data-state', nextState);
    }else{
      estimateStatusEl.removeAttribute('data-state');
    }
  }

  function updateImportStatus(message, state){
    if(!importStatusEl){
      return;
    }
    importStatusEl.textContent = message || 'Paste notes that include the embedded reload key added by this generator.';
    if(state){
      importStatusEl.setAttribute('data-state', state);
    } else {
      importStatusEl.removeAttribute('data-state');
    }
  }

  function formatEstimateAddress(address){
    if(!address || typeof address !== 'object'){
      return '';
    }
    const segments = [];
    if(address.street){
      segments.push(address.street);
    }
    if(address.street_line_2){
      segments.push(address.street_line_2);
    }
    const cityState = [address.city, address.state].filter(Boolean).join(', ');
    if(cityState){
      segments.push(cityState);
    }
    if(address.zip){
      segments.push(address.zip);
    }
    if(address.country && address.country.toLowerCase() !== 'usa' && address.country.toLowerCase() !== 'us'){
      segments.push(address.country);
    }
    return segments.join(', ');
  }

  function extractEstimateAddressPayload(payload){
    if(!payload){
      return { formatted: '', hasAddress: false };
    }

    if(typeof payload === 'string'){
      const formatted = payload.trim();
      return { formatted, hasAddress: !!formatted };
    }

    if(Array.isArray(payload)){
      for(const item of payload){
        const result = extractEstimateAddressPayload(item);
        if(result.hasAddress){
          return result;
        }
      }
      return { formatted: '', hasAddress: false };
    }

    const candidates = [payload];
    ['data', 'result', 'estimate'].forEach(key=>{
      if(payload && payload[key]){
        candidates.push(payload[key]);
      }
    });

    for(const candidate of candidates){
      if(!candidate || typeof candidate !== 'object'){
        continue;
      }
      if(typeof candidate.address === 'string'){
        const formatted = candidate.address.trim();
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      if(candidate.formatted_address){
        const formatted = String(candidate.formatted_address).trim();
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      if(candidate.address && typeof candidate.address === 'object'){
        const formatted = formatEstimateAddress(candidate.address);
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      const streetLike = candidate.street || candidate.address_line_1 || candidate.address1 || candidate.line1;
      const cityLike = candidate.city;
      const stateLike = candidate.state || candidate.region;
      const zipLike = candidate.zip || candidate.postal_code || candidate.zipcode;
      if(streetLike || candidate.street_line_2 || cityLike || stateLike || zipLike){
        const formatted = formatEstimateAddress({
          street: streetLike,
          street_line_2: candidate.street_line_2 || candidate.address_line_2 || candidate.address2 || candidate.line2,
          city: cityLike,
          state: stateLike,
          zip: zipLike,
          country: candidate.country,
        });
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
    }

    return { formatted: '', hasAddress: false };
  }

  function isEstimateNotFound(payload){
    if(!payload || typeof payload !== 'object'){
      return !payload;
    }
    if(payload.found === false || payload.notFound === true){
      return true;
    }
    if(payload.success === false && typeof payload.error === 'string' && payload.error.toLowerCase().includes('not found')){
      return true;
    }
    const nestedKeys = ['data', 'result', 'estimate'];
    return nestedKeys.some(key=>{
      const value = payload[key];
      return value && typeof value === 'object' ? isEstimateNotFound(value) : false;
    });
  }

  function normalizeEstimateId(value){
    if(value == null){
      return '';
    }
    const text = String(value).trim();
    if(!text){
      return '';
    }
    if(/^\d+$/.test(text)){
      return '';
    }
    return text;
  }

  function extractEstimateId(payload){
    if(!payload){
      return '';
    }
    if(typeof payload === 'string' || typeof payload === 'number'){
      return '';
    }
    if(Array.isArray(payload)){
      for(const item of payload){
        const candidate = extractEstimateId(item);
        if(candidate){
          return candidate;
        }
      }
      return '';
    }

    const candidates = [payload];
    ['data', 'result', 'estimate'].forEach(key=>{
      if(payload && payload[key]){
        candidates.push(payload[key]);
      }
    });

    const pending = [...candidates];
    const seen = new Set();

    while(pending.length){
      const candidate = pending.shift();
      if(!candidate || typeof candidate !== 'object' || seen.has(candidate)){
        continue;
      }
      seen.add(candidate);

      const idCandidate = candidate.id
        || candidate.estimateId
        || candidate.estimate_id
        || candidate.estimateID
        || candidate.estimateNumber
        || candidate.estimate_number;
      const normalized = normalizeEstimateId(idCandidate);
      if(normalized){
        return normalized;
      }

      for(const value of Object.values(candidate)){
        if(value && typeof value === 'object'){
          pending.push(value);
        }
      }
    }

    return '';
  }

  function zoomMapToMax(location){
    if(!mapState.map || !location){
      return;
    }
    const fallbackZoom = 21;
    const hasGoogle = typeof google !== 'undefined' && google && google.maps;
    const service = mapState.maxZoomService;
    if(hasGoogle && service && typeof service.getMaxZoomAtLatLng === 'function' && google.maps.MaxZoomStatus){
      service.getMaxZoomAtLatLng(location, result=>{
        if(result && result.status === google.maps.MaxZoomStatus.OK && typeof result.zoom === 'number'){
          mapState.map.setZoom(result.zoom);
        }else{
          mapState.map.setZoom(fallbackZoom);
        }
      });
    }else{
      mapState.map.setZoom(fallbackZoom);
    }
  }

  function focusMapOnAddress(address){
    const value = (address || '').trim();
    if(!value){
      mapState.pendingAddress = '';
      updateMapAddressMarker(null);
      return;
    }
    if(!addressesMatch(mapState.pendingAddress, value)){
      mapState.addressLocation = null;
    }
    mapState.pendingAddress = value;
    if(!mapState.map || !mapState.geocoder){
      return;
    }
    mapState.geocoder.geocode({ address: value }, (results, status)=>{
      if(status === 'OK' && results && results[0]){
        const geometry = results[0].geometry || {};
        const viewport = geometry.viewport;
        let loc = geometry.location;
        if(!loc && viewport && typeof viewport.getCenter === 'function'){
          loc = viewport.getCenter();
        }
        if(viewport){
          mapState.map.fitBounds(viewport);
        }
        if(loc){
          mapState.map.setCenter(loc);
          zoomMapToMax(loc);
        }
        if(loc){
          updateMapAddressMarker(loc);
        }
      }else{
        console.warn('Geocode failed for address', value, status);
      }
    });
  }

  function setMapAddressFromEstimate(address){
    if(!address){
      return;
    }
    if(mapAddressInput){
      mapAddressInput.value = address;
    }
    setMapCollapsed(false);
    focusMapOnAddress(address);
    persist();
  }

  function normalizeAddressText(addr){
    return (addr || '').trim();
  }

  function geocodeAddress(address){
    return new Promise(resolve => {
      const value = normalizeAddressText(address);
      if(!value || !mapState.geocoder){
        resolve(null);
        return;
      }
      mapState.geocoder.geocode({ address: value }, (results, status)=>{
        if(status === 'OK' && results && results[0] && results[0].geometry && results[0].geometry.location){
          resolve(results[0].geometry.location);
        }else{
          resolve(null);
        }
      });
    });
  }

  async function getBaseLocation(){
    if(mapState.baseLocation){
      return mapState.baseLocation;
    }
    if(mapState.baseLocationPromise){
      return mapState.baseLocationPromise;
    }
    mapState.baseLocationPromise = geocodeAddress(HQ_ADDRESS).then(loc=>{
      mapState.baseLocation = loc;
      mapState.baseLocationPromise = null;
      return loc;
    });
    return mapState.baseLocationPromise;
  }

  function addressesMatch(a, b){
    return normalizeAddressText(a).toLowerCase() === normalizeAddressText(b).toLowerCase();
  }

  async function resolveJobLocation(jobAddress){
    const normalized = normalizeAddressText(jobAddress);
    if(!normalized){
      return null;
    }
    if(mapState.addressLocation && addressesMatch(mapState.pendingAddress, normalized)){
      return mapState.addressLocation;
    }
    return geocodeAddress(normalized);
  }

  function milesBetween(locA, locB){
    if(typeof google === 'undefined' || !google.maps || !google.maps.geometry || !google.maps.geometry.spherical){
      return 0;
    }
    if(!locA || !locB) return 0;
    const meters = google.maps.geometry.spherical.computeDistanceBetween(locA, locB);
    return meters / 1609.34;
  }

  async function computeTravelDayInfo(jobAddress){
    const result = { roundTripMiles: 0, hoursPerDay: 0, included: false, reason: '' };

    const normalizedAddress = normalizeAddressText(jobAddress);
    if(!normalizedAddress){
      result.reason = 'address';
      return result;
    }

    const [baseLoc, jobLoc] = await Promise.all([
      getBaseLocation(),
      resolveJobLocation(normalizedAddress)
    ]);

    if(!baseLoc || !jobLoc){
      result.reason = 'geocode';
      return result;
    }

    const milesOneWay = milesBetween(baseLoc, jobLoc);
    if(!milesOneWay || !isFinite(milesOneWay)){
      result.reason = 'distance';
      return result;
    }

    const roundTripMiles = milesOneWay * 2;
    const travelMinutesPerDay = roundTripMiles * TRAVEL_SETTINGS.minutesPerMile;
    result.roundTripMiles = roundTripMiles;
    result.hoursPerDay = travelMinutesPerDay / 60;
    result.included = true;
    return result;
  }

  async function computeTravelCost({ crewSchedule, jobAddress, travelDayInfo }){
    const result = { cost: 0, breakdown: [], hours: 0, included: false };
    const travelInfo = travelDayInfo || await computeTravelDayInfo(jobAddress);

    if(!travelInfo.included){
      if(travelInfo.reason === 'address'){
        result.breakdown.push('- Travel: Address required to calculate fuel and drive time.');
      }else if(travelInfo.reason === 'geocode'){
        result.breakdown.push('- Travel: Unable to locate job address; travel cost not included.');
      }else if(travelInfo.reason === 'distance'){
        result.breakdown.push('- Travel: Unable to calculate distance; travel cost not included.');
      }
      return result;
    }

    const travelDays = crewSchedule.filter(day => (day.crew||0) > 0).length;
    if(travelDays <= 0){
      return result;
    }

    const roundTripMiles = travelInfo.roundTripMiles;
    const fuelPerDay = (roundTripMiles / TRAVEL_SETTINGS.mpg) * TRAVEL_SETTINGS.dieselPrice;
    const totalFuelCost = fuelPerDay * travelDays;
    const travelHours = travelInfo.hoursPerDay * travelDays;
    const travelLaborCost = travelHours * LABOR_RATE;

    const cost = totalFuelCost + travelLaborCost;
    result.cost = cost;
    result.hours = travelHours;
    result.included = true;
    result.breakdown.push(`- Travel: ${roundTripMiles.toFixed(1)} miles round trip x ${travelDays} day(s) = $${money(cost)} (fuel $${money(totalFuelCost)}, travel labor $${money(travelLaborCost)} @ $${money(LABOR_RATE)}/hr)`);
    return result;
  }

  async function fetchEstimateByNumber(estimateNumber, options){
    const opts = options || {};
    const signal = opts.signal;
    const response = await fetch('https://api.strongclicks.io/webhook/get-estimate-address', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ estimateNumber, includeEstimateId: true }),
      signal,
    });

    if(signal && signal.aborted){
      throw new DOMException('Aborted', 'AbortError');
    }

    if(!response.ok){
      const text = await response.text();
      throw new Error(text || `Estimate lookup failed with status ${response.status}`);
    }

    try{
      return await response.json();
    }catch(err){
      console.error('Failed to parse estimate lookup response', err);
      throw new Error('Received an invalid response while fetching the estimate address.');
    }
  }

  async function lookupEstimateAddress(estimateNumber){
    if(!estimateNumber){
      return;
    }
    if(estimateLookupController && typeof estimateLookupController.abort === 'function'){
      estimateLookupController.abort();
    }
    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
    estimateLookupController = controller;

    updateEstimateStatus('Looking up estimate address…', 'loading');
    if(estimateLookupBtn){
      estimateLookupBtn.disabled = true;
      estimateLookupBtn.textContent = 'Fetching…';
    }

    try{
      const estimate = await fetchEstimateByNumber(estimateNumber, controller ? { signal: controller.signal } : {});
      if(controller && controller.signal && controller.signal.aborted){
        return;
      }
      const addressResult = extractEstimateAddressPayload(estimate);
      if(addressResult.hasAddress){
        const formatted = addressResult.formatted;
        lastEstimateLookupNumber = estimateNumber;
        lastEstimateAddress = formatted;
        lastEstimateExists = true;
        if(formatted){
          setMapAddressFromEstimate(formatted);
          updateEstimateStatus('Address loaded from Housecall Pro.', 'success');
        }else{
          updateEstimateStatus('Estimate found but no address was provided.', 'warn');
        }
      }else if(estimate){
        const notFound = isEstimateNotFound(estimate);
        if(notFound){
          lastEstimateLookupNumber = estimateNumber;
          lastEstimateAddress = '';
          lastEstimateExists = false;
          updateEstimateStatus('No matching estimate found in Housecall Pro.', 'warn');
        }else{
          lastEstimateLookupNumber = estimateNumber;
          lastEstimateAddress = '';
          lastEstimateExists = true;
          updateEstimateStatus('Estimate found but no address was provided.', 'warn');
        }
      }else{
        lastEstimateLookupNumber = estimateNumber;
        lastEstimateAddress = '';
        lastEstimateExists = false;
        updateEstimateStatus('No matching estimate found in Housecall Pro.', 'warn');
      }
      setGateUnlocked(true);
    }catch(err){
      if(controller && controller.signal && controller.signal.aborted){
        return;
      }
      console.error('Estimate lookup failed', err);
      lastEstimateLookupNumber = '';
      lastEstimateAddress = '';
      lastEstimateExists = false;
      updateEstimateStatus('Unable to load estimate address. Please try again.', 'error');
    }finally{
      if(estimateLookupController === controller){
        estimateLookupController = null;
      }
      if(estimateLookupBtn){
        estimateLookupBtn.disabled = false;
        estimateLookupBtn.textContent = estimateLookupBtnLabel || 'Fetch Estimate Address';
      }
    }
  }

  function runEstimateLookup(){
    if(!estimateNumberInput){
      return;
    }
    const digits = sanitizeEstimateNumber(estimateNumberInput.value || '');
    if(!digits){
      lastEstimateLookupNumber = '';
      lastEstimateAddress = '';
      lastEstimateExists = false;
      updateEstimateStatus('', '');
      return;
    }
    if(digits === lastEstimateLookupNumber){
      if(lastEstimateAddress && mapAddressInput && !mapAddressInput.value.trim()){
        setMapAddressFromEstimate(lastEstimateAddress);
        updateEstimateStatus('Address loaded from Housecall Pro.', 'success');
      }
      return;
    }
    lookupEstimateAddress(digits);
  }

  function createSectionBase(data={}){
    const scope = data.scopeType || 'repair';
    const initialFenceType = data.fenceType || 'Wrought Iron';
    const normalizedType = initialFenceType.toLowerCase();
    const defaultPainting = normalizedType === 'wood'
      ? 'None'
      : ((scope === 'install' || scope === 'replace') ? 'Spot Paint Welds' : 'Paint Section');
    const base = {
      id: uid(),
      collapsed:false,
      fenceType: initialFenceType,
      railsCount:2,
      rails:[
        {size:SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0},
        {size:SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0},
      ],
      puppyPicketSize: SEED.picketSize[0],
      puppyPicketHeight: '',
      puppyPicketReplace: 0,
      postSize: '2x2',
      postReplacements: [],
      postRealignments: [],
      weldRedos: 0,
      gapAdditions: [],
      diagonalBraces: [],
      walkGates: 0,
      walkGatesRealign: 0,
      walkGatesHardware: 0,
      walkGatesRebuild: 0,
      walkLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkRebuildFrame: SEED.railSize[0],
      walkRebuildPicket: SEED.picketSize[0],
      walkRebuildLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkRebuildHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkGatesAdd: 0,
      walkAddType: 'Single Swing Walk Gate',
      walkAddPostSize: '2x2',
      walkAddFrameSize: SEED.railSize[0],
      walkAddPicketSize: SEED.picketSize[0],
      walkAddLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkAddHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      driveGateChainReplace: 0,
      driveGateOperatorReplace: 0,
      driveGateOperatorType: DRIVE_GATE_OPERATOR_TYPES[0],
      driveGateOperatorPower: DRIVE_GATE_POWER_TYPES[0],
      driveGateOperatorInstall: 0,
      driveGateOperatorInstallType: DRIVE_GATE_OPERATOR_TYPES[0],
      driveGateOperatorInstallPower: DRIVE_GATE_POWER_TYPES_INSTALL[0],
      driveGateOperatorInstallPlatform: false,
      scopeType: 'repair',
      postSpacing: '8',
      panelAttachment: 'Welding',
      installFinialStyle: SEED.finialStyles[0],
      finials: [],
      caps: [],
      panels: [],
      puppyInserts: [],
      mapGenerated: false,
      mapSegmentId: '',
      mapGeneratedLabel: '',
      notes: '',
      painting: defaultPainting,
      paintingApplication: 'By Hand',
      paintingPrepExtra: false,
      woodHeight: '6ft',
      woodStyle: 'Side by Side',
      woodPicketWidth: '5.5"',
      woodRailSize: '2x4',
      woodPost: 'Round Steel',
      woodType: 'Cedar',
      woodFinish: 'Oil Based Stain',
      woodKickBoardSize: '2x6',
      woodKickBoardStack: '1',
      woodTopCapSize: '2x6',
      woodTrimType: '1x4',
      woodPostRealignments: [],
      woodRepairPicketReplace: 0,
      woodRepairPicketInstall: 0,
      woodRepairRailReplace: 0,
      woodRepairRailInstall: 0,
      woodRepairPostReplace: 0,
      woodRepairPostReplaceTie: SIMPSON_TIE_OPTIONS[0],
      woodRepairPostReplaceCap: '',
      woodRepairPostInstall: 0,
      woodRepairPostInstallMethod: WOOD_POST_INSTALL_METHODS[1].value,
      woodRepairPostInstallTie: SIMPSON_TIE_OPTIONS[0],
      woodRepairPanelReplace: 0,
      woodRepairPanelWidth: 8,
      woodRepairWalkGateCount: 0,
      woodRepairWalkGateHinges: false,
      woodRepairWalkGateLatch: false,
      woodRepairWalkGateWood: false,
      woodRepairGateStrengthen: 0,
      woodRepairGateReplace: 0,
      woodRepairTopCapReplaceLf: 0,
      woodRepairTopCapReplaceSize: '2x6',
      woodRepairTrimReplaceLf: 0,
      woodRepairTrimReplaceSize: '1x4',
      woodRepairKickReplaceLf: 0,
      woodRepairKickReplaceSize: '2x6',
      woodRepairKickReplaceStack: '1',
      woodRepairStain: 'none',
      woodAddKickBoard: false,
      woodAddTopCap: false,
      woodAddTrim: false,
      retainingWallLength: 0,
      retainingWallHeight: 0,
    };
    const merged = { ...base, ...data };
    if(!Object.prototype.hasOwnProperty.call(data, 'woodRepairPostReplaceTie')){
      merged.woodRepairPostReplaceTie = defaultTieForWoodPost(merged.woodPost);
    }
    if(!Object.prototype.hasOwnProperty.call(data, 'woodRepairPostInstallTie')){
      merged.woodRepairPostInstallTie = defaultTieForWoodPost(merged.woodPost);
    }
    if(!Object.prototype.hasOwnProperty.call(data, 'woodRepairPostReplaceCap')){
      merged.woodRepairPostReplaceCap = defaultCapForWoodPost(merged.woodPost);
    }
    return merged;
  }

  function isSectionPristine(section){
    if(!section) return false;
    const clean = v => String(v||'').trim();
    return !section.mapGenerated &&
      !clean(section.label) &&
      Number(section.length||0) === 0 &&
      Number(section.hardscape||0) === 0 &&
      Number(section.trim||0) === 0 &&
      Number(section.digOut||0) === 0 &&
      Number(section.puppyPicketReplace||0) === 0 &&
      Number(section.walkGates||0) === 0 &&
      Number(section.driveGateChainReplace||0) === 0 &&
      Number(section.driveGateOperatorReplace||0) === 0 &&
      Number(section.driveGateOperatorInstall||0) === 0 &&
      clean(section.notes) === '' &&
      (!section.postReplacements || section.postReplacements.length === 0) &&
      (!section.postRealignments || section.postRealignments.length === 0) &&
      (!section.gapAdditions || section.gapAdditions.length === 0) &&
      (!section.diagonalBraces || section.diagonalBraces.length === 0) &&
      (!section.panels || section.panels.length === 0) &&
      (!section.puppyInserts || section.puppyInserts.length === 0) &&
      (!section.finials || section.finials.length === 0) &&
      (!section.caps || section.caps.length === 0);
  }

  function sectionBasicsComplete(card){
    if(!card) return false;
    const label = (card.querySelector('[data-field="label"]')?.value || '').trim();
    const lengthInput = card.querySelector('[data-field="length"] input');
    const length = lengthInput ? parseFloat(lengthInput.value || '0') : 0;
    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').trim();
    const scopeType = (card.querySelector('[data-field="scopeType"]')?.value || '').trim();
    return !!(label && isFinite(length) && length > 0 && fenceType && scopeType);
  }

  function updateSectionBasicsGate(card){
    if(!card) return;
    card.classList.toggle('sp-section-locked', !sectionBasicsComplete(card));
  }

  function updateMapControlsUI(){
    const clearBtn = document.getElementById('sp-map-clear');
    if(clearBtn){
      const hasLinkedSections = state.sections.some(sec=>sec.mapGenerated);
      clearBtn.disabled = mapState.polylines.length === 0 && !hasLinkedSections;
    }
  }

  function setMapCollapsed(collapsed){
    if(!mapCardEl) return;
    mapCardEl.classList.toggle('is-collapsed', collapsed);
    if(mapToggleBtn){
      mapToggleBtn.textContent = collapsed ? 'Expand Map' : 'Collapse Map';
      mapToggleBtn.setAttribute('aria-expanded', (!collapsed).toString());
    }
    if(!collapsed && mapState.map && typeof google !== 'undefined' && google.maps && google.maps.event){
      google.maps.event.trigger(mapState.map, 'resize');
    }
  }

  function clearMapDrawing(options={}){
    mapState.polylines.forEach(poly=>poly.setMap(null));
    mapState.polylines = [];
    updateMapControlsUI();
    if(!options.skipSections){
      applySegmentsToSections([]);
    }
  }

  function updateMapAddressMarker(location){
    if(typeof google === 'undefined' || !google.maps || !mapState.map){
      return;
    }
    mapState.addressLocation = location || null;
    if(!location){
      if(mapState.marker){
        mapState.marker.setMap(null);
      }
      return;
    }
    if(!mapState.marker){
      mapState.marker = new google.maps.Marker({
        map: mapState.map,
        clickable: false,
      });
    }
    mapState.marker.setMap(mapState.map);
    mapState.marker.setPosition(location);
  }

  function scheduleMapSectionsUpdate(){
    if(mapUpdateScheduled) return;
    mapUpdateScheduled = true;
    const run = ()=>{
      mapUpdateScheduled = false;
      refreshSectionsFromMap();
    };
    if(typeof requestAnimationFrame === 'function'){
      requestAnimationFrame(run);
    }else{
      setTimeout(run, 80);
    }
  }

  function refreshSectionsFromMap(){
    if(!mapState.polylines.length){
      updateMapControlsUI();
      applySegmentsToSections([]);
      return;
    }
    if(typeof google === 'undefined' || !google.maps || !google.maps.geometry){
      return;
    }
    mapState.polylines = mapState.polylines.filter(poly=>!!poly.getMap());
    updateMapControlsUI();
    const segments = [];
    mapState.polylines.forEach((polyline, runIndex)=>{
      const path = polyline.getPath();
      if(!path) return;
      const length = path.getLength();
      for(let i=0;i<length-1;i++){
        const start = path.getAt(i);
        const end = path.getAt(i+1);
        if(!start || !end) continue;
        const meters = google.maps.geometry.spherical.computeDistanceBetween(start, end);
        const feet = meters * 3.28084;
        if(!isFinite(feet) || feet <= 0.1) continue;
        const segId = `${polyline.__spPolylineId}:${i}`;
        segments.push({
          id: segId,
          label: `Map Run ${runIndex+1} – Segment ${i+1}`,
          lengthFeet: feet
        });
      }
    });
    applySegmentsToSections(segments);
  }

  function applySegmentsToSections(segments){
    syncStateFromDOM();
    let needsRender = false;
    let manualSections = [];
    const existingMapSections = new Map();
    state.sections.forEach(sec=>{
      if(sec.mapGenerated){
        existingMapSections.set(sec.mapSegmentId, sec);
      }else{
        manualSections.push(sec);
      }
    });

    if(segments.length>0 && manualSections.length===1 && isSectionPristine(manualSections[0])){
      manualSections = [];
      needsRender = true;
    }

    const updatedMapSections = [];
    segments.forEach(segment=>{
      const lengthFeet = Math.round(segment.lengthFeet);
      if(!lengthFeet) return;
      const existing = existingMapSections.get(segment.id);
      if(existing){
        const prevLength = Number(existing.length)||0;
        const prevLabel = existing.label||'';
        const prevGeneratedLabel = existing.mapGeneratedLabel||'';
        if(prevLength !== lengthFeet) needsRender = true;
        existing.length = lengthFeet;
        existing.mapGenerated = true;
        existing.mapSegmentId = segment.id;
        existing.mapGeneratedLabel = segment.label;
        if(!prevLabel.trim() || prevLabel === prevGeneratedLabel || prevLabel.startsWith('Map Run ')){
          if(prevLabel !== segment.label) needsRender = true;
          existing.label = segment.label;
        }
        updatedMapSections.push(existing);
        existingMapSections.delete(segment.id);
      }else{
        const newSection = createSectionBase({
          label: segment.label,
          length: lengthFeet,
          scopeType: 'repair',
          mapGenerated: true,
          mapSegmentId: segment.id,
          mapGeneratedLabel: segment.label,
        });
        updatedMapSections.push(newSection);
        needsRender = true;
      }
    });

    if(existingMapSections.size>0){
      needsRender = true;
    }

    const nextSections = manualSections.concat(updatedMapSections);
    if(needsRender || nextSections.length !== state.sections.length){
      state.sections = nextSections;
      render();
      persist();
    }
  }

  function attachMapPolyline(polyline){
    polyline.__spPolylineId = polyline.__spPolylineId || `poly-${mapState.nextPolylineId++}`;
    mapState.polylines.push(polyline);
    updateMapControlsUI();
    const path = polyline.getPath();
    ['insert_at','set_at','remove_at'].forEach(evt=>{
      google.maps.event.addListener(path, evt, scheduleMapSectionsUpdate);
    });
    google.maps.event.addListener(polyline, 'rightclick', evt=>{
      if(typeof evt.vertex === 'number'){
        path.removeAt(evt.vertex);
        return;
      }
      if(confirm('Remove this fence run?')){
        polyline.setMap(null);
        mapState.polylines = mapState.polylines.filter(p=>p!==polyline);
        scheduleMapSectionsUpdate();
      }
    });
    scheduleMapSectionsUpdate();
  }

  function serializePolylinePath(polyline){
    if(!polyline || typeof polyline.getPath !== 'function'){
      return [];
    }
    const path = polyline.getPath();
    if(!path || typeof path.getLength !== 'function') return [];
    const coords = [];
    const len = path.getLength();
    for(let i=0;i<len;i++){
      const pt = path.getAt(i);
      if(pt && typeof pt.lat === 'function' && typeof pt.lng === 'function'){
        coords.push({ lat: pt.lat(), lng: pt.lng() });
      }
    }
    return coords;
  }

  function serializeMapDrawing(){
    const polylines = [];
    if(mapState.polylines && mapState.polylines.length && typeof google !== 'undefined' && google.maps){
      mapState.polylines.forEach(poly=>{
        const coords = serializePolylinePath(poly);
        if(coords.length >= 2){
          polylines.push({ id: poly.__spPolylineId || '', path: coords });
        }
      });
    }
    const address = mapAddressInput ? (mapAddressInput.value || '').trim() : '';
    return { address, polylines, nextPolylineId: mapState.nextPolylineId || 1 };
  }

  function applyPendingMapRestore(){
    if(!pendingMapRestore || !mapState.map || typeof google === 'undefined' || !google.maps || !google.maps.Polyline){
      return;
    }

    const restore = pendingMapRestore;
    pendingMapRestore = null;
    clearMapDrawing({ skipSections: true });

    const baseOpts = { editable: true, draggable: true, strokeColor: '#d97706', strokeWeight: 3 };
    let maxId = restore.nextPolylineId || mapState.nextPolylineId || 1;
    (restore.polylines || []).forEach(data=>{
      if(!data || !Array.isArray(data.path) || data.path.length < 2) return;
      const path = data.path.map(pt => ({ lat: pt.lat, lng: pt.lng })).filter(pt=>isFinite(pt.lat) && isFinite(pt.lng));
      if(path.length < 2) return;
      const polyline = new google.maps.Polyline({ ...baseOpts, map: mapState.map, path });
      polyline.__spPolylineId = data.id || `poly-${mapState.nextPolylineId++}`;
      const numericId = parseInt(String(polyline.__spPolylineId).replace(/[^0-9]/g,''),10);
      if(isFinite(numericId)){
        maxId = Math.max(maxId, numericId + 1);
      }
      attachMapPolyline(polyline);
    });
    mapState.nextPolylineId = Math.max(mapState.nextPolylineId || 1, maxId);
    scheduleMapSectionsUpdate();
  }

  function restoreMapFromSnapshot(mapData){
    clearMapDrawing({ skipSections: true });
    if(!mapData || !mapData.polylines || !mapData.polylines.length){
      pendingMapRestore = null;
      updateMapControlsUI();
      return;
    }
    pendingMapRestore = mapData;
    applyPendingMapRestore();
  }

  function initializeMap(){
    if(mapState.map) return;
    if(typeof google === 'undefined' || !google.maps || !google.maps.drawing) return;
    const mapEl = document.getElementById('sp-map');
    if(!mapEl) return;
    mapState.map = new google.maps.Map(mapEl, {
      zoom: 11,
      mapTypeId: 'hybrid',
      center: { lat: 32.922, lng: -96.549 },
      zoomControl: true,
      streetViewControl: false,
      mapTypeControl: false,
    });
    mapState.maxZoomService = (typeof google.maps.MaxZoomService === 'function') ? new google.maps.MaxZoomService() : null;
    mapState.drawingManager = new google.maps.drawing.DrawingManager({
      drawingMode: null,
      drawingControl: true,
      drawingControlOptions: {
        position: google.maps.ControlPosition.TOP_CENTER,
        drawingModes: [google.maps.drawing.OverlayType.POLYLINE]
      },
      polylineOptions: {
        editable: true,
        draggable: true,
        strokeColor: '#d97706',
        strokeWeight: 3
      }
    });
    mapState.drawingManager.setMap(mapState.map);
    google.maps.event.addListener(mapState.drawingManager, 'polylinecomplete', polyline=>{
      attachMapPolyline(polyline);
      mapState.drawingManager.setDrawingMode(null);
    });

    mapState.geocoder = new google.maps.Geocoder();
    if(mapState.pendingAddress){
      focusMapOnAddress(mapState.pendingAddress);
    }
    if(mapAddressInput){
      mapState.autocomplete = new google.maps.places.Autocomplete(mapAddressInput);
      mapState.autocomplete.addListener('place_changed', ()=>{
        const place = mapState.autocomplete.getPlace();
        if(place && place.geometry){
          const viewport = place.geometry.viewport;
          let loc = place.geometry.location;
          if(!loc && viewport && typeof viewport.getCenter === 'function'){
            loc = viewport.getCenter();
          }
          if(viewport){
            mapState.map.fitBounds(viewport);
          }
          if(loc){
            mapState.map.setCenter(loc);
            zoomMapToMax(loc);
            updateMapAddressMarker(loc);
          }
          mapState.pendingAddress = mapAddressInput.value.trim();
          persist();
        }
      });
      mapAddressInput.addEventListener('keydown', evt=>{
        if(evt.key === 'Enter'){
          evt.preventDefault();
          const value = mapAddressInput.value.trim();
          if(!value || !mapState.geocoder) return;
          mapState.geocoder.geocode({ address: value }, (results, status)=>{
            let hasLocation = false;
            if(status === 'OK' && results && results[0]){
              const geometry = results[0].geometry || {};
              const viewport = geometry.viewport;
              let loc = geometry.location;
              if(!loc && viewport && typeof viewport.getCenter === 'function'){
                loc = viewport.getCenter();
              }
              if(loc){
                mapState.map.setCenter(loc);
              }
              if(viewport){
                mapState.map.fitBounds(viewport);
              }
              if(loc){
                zoomMapToMax(loc);
                updateMapAddressMarker(loc);
                hasLocation = true;
              }else if(viewport && typeof viewport.getCenter === 'function'){
                const center = viewport.getCenter();
                if(center){
                  zoomMapToMax(center);
                  updateMapAddressMarker(center);
                  hasLocation = true;
                }
              }
            }
            mapState.pendingAddress = value;
            if(!hasLocation){
              mapState.addressLocation = null;
            }
            persist();
          });
        }
      });
      mapAddressInput.addEventListener('input', ()=>{
        if(!mapAddressInput.value.trim()){
          updateMapAddressMarker(null);
          mapState.pendingAddress = '';
          persist();
        }
      });
    }
    applyPendingMapRestore();
    updateMapControlsUI();
  }

  function escapeHtml(t){ return String(t).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function escapeAttr(t){ return escapeHtml(t).replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

  function createSelect(options){
    return options.map(v=>`<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`).join('');
  }

  function numberControl(name, placeholder='', min=0){
    return (
      '<div class="sp-number" data-field="'+name+'">'+
        '<button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>'+
        '<input type="number" inputmode="numeric" step="1" min="'+min+'" value="" placeholder="'+placeholder+'" />'+
        '<button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>'+
      '</div>'
    );
  }

  function sectionTemplate(id, index){
    return `
    <div class="sp-card" data-id="${id}">
      <div class="sp-card-header">
        <div class="sp-card-title">Section ${index+1}</div>
        <div class="sp-row">
          <button class="sp-btn ghost sp-toggle" type="button" aria-expanded="true">Collapse</button>
          <button class="sp-btn ghost sp-dup" type="button">Duplicate</button>
          <button class="sp-btn danger sp-del" type="button">Remove</button>
        </div>
      </div>
      <div class="sp-grid">
        <div class="sp-scope-group col-12 is-basics">
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Basics</div>
            <div>
              <div class="sp-scope-title">Section Layout</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-field col-6">
              <label class="sp-label">Section Label (e.g., Front Right, Right Side, Back Right, etc)</label>
              <input class="sp-input" data-field="label" placeholder="Enter a label" />
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Fence Type</label>
              <select class="sp-select" data-field="fenceType">
                <option value="Wrought Iron">Wrought Iron</option>
                <option value="Wood">Wood</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Section Scope</label>
              <select class="sp-select" data-field="scopeType">
                <option value="repair">Repair Existing</option>
                <option value="replace">Replace Section</option>
                <option value="install">Install New Section</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Section Length (ft)</label>
              ${numberControl('length','e.g., 48')}
            </div>
          </div>
        </div>
        <div class="sp-scope-group col-12 is-wood" data-section-detail data-wood-only>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Wood</div>
            <div>
              <div class="sp-scope-title">Wood Build & Finish</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-field col-2">
              <label class="sp-label">Fence Height</label>
              <select class="sp-select" data-field="woodHeight">
                <option value="6ft">6ft</option>
                <option value="8ft">8ft</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Construction</label>
              <select class="sp-select" data-field="woodStyle">
                <option value="Board on Board">Board on Board</option>
                <option value="Side by Side">Side by Side</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Picket Width</label>
              <select class="sp-select" data-field="woodPicketWidth">${createSelect(WOOD_PICKET_WIDTHS)}</select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Rail Size</label>
              <select class="sp-select" data-field="woodRailSize">${createSelect(WOOD_RAIL_SIZES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Posts</label>
              <select class="sp-select" data-field="woodPost">
                <option value="Wood 4x4">Wood 4x4</option>
                <option value="Round Steel">Round Steel</option>
                <option value="Postmaster">Postmaster</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Wood Type</label>
              <select class="sp-select" data-field="woodType">
                <option value="Cedar">Cedar</option>
                <option value="Pressure Treated">Pressure Treated</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Finish Type</label>
              <select class="sp-select" data-field="woodFinish">
                <option value="Oil Based Stain">Oil Based Stain</option>
                <option value="Water Based Stain">Water Based Stain</option>
                <option value="Painted">Painted</option>
                <option value="Unfinished">Unfinished</option>
              </select>
            </div>
            <div class="sp-field col-12">
              <label class="sp-label">Add-ons</label>
              <div class="sp-row">
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddKickBoard" /> Kick Board</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddTopCap" /> Top Cap</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddTrim" /> Trim</label>
              </div>
            </div>

            <div class="sp-grid col-12" data-wood-only data-kickboard-settings style="display:none">
              <div class="sp-field col-2">
                <label class="sp-label">Kick Board Size</label>
                <select class="sp-select" data-field="woodKickBoardSize">
                  <option value="2x6">2x6</option>
                  <option value="2x8">2x8</option>
                  <option value="2x10">2x10</option>
                  <option value="2x12">2x12</option>
                </select>
              </div>
              <div class="sp-field col-2">
                <label class="sp-label">Kick Board Stack Height</label>
                <select class="sp-select" data-field="woodKickBoardStack">
                  <option value="1">1 Board</option>
                  <option value="2">2 Board Stack</option>
                  <option value="3">3 Board Stack</option>
                  <option value="4">4 Board Stack</option>
                </select>
              </div>
            </div>

            <div class="sp-grid col-12" data-wood-only data-topcap-settings style="display:none">
              <div class="sp-field col-2">
                <label class="sp-label">Top Cap Size</label>
                <select class="sp-select" data-field="woodTopCapSize">
                  <option value="2x6">2x6</option>
                  <option value="2x8">2x8</option>
                  <option value="2x10">2x10</option>
                </select>
              </div>
            </div>

            <div class="sp-grid col-12" data-wood-only data-trim-settings style="display:none">
              <div class="sp-field col-3">
                <label class="sp-label">Trim Type</label>
                <select class="sp-select" data-field="woodTrimType">${createSelect(WOOD_TRIM_TYPES)}</select>
              </div>
            </div>
          </div>
        </div>

        <div class="sp-scope-group col-12 is-repair" data-section-detail data-wood-only data-repair-only>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Wood Repairs</div>
            <div>
              <div class="sp-scope-title">Touch-ups, replacements, and rebuilds</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Picket Replacement</label>
              ${numberControl('woodRepairPicketReplace','0')}
              <div class="sp-hint">Remove damaged pickets and install new ones.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Picket Installation</label>
              ${numberControl('woodRepairPicketInstall','0')}
              <div class="sp-hint">Install missing pickets to close gaps.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Rail Replacement</label>
              ${numberControl('woodRepairRailReplace','0')}
              <div class="sp-hint">Replace broken rails (${WOOD_RAIL_SIZES.join(' / ')}).</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Rail Installation</label>
              ${numberControl('woodRepairRailInstall','0')}
              <div class="sp-hint">Add rails where missing (${WOOD_RAIL_SIZES.join(' / ')}).</div>
            </div>

            <div class="sp-field col-3">
              <label class="sp-label">Post Replacement</label>
              ${numberControl('woodRepairPostReplace','0')}
              <div class="sp-row">
                <select class="sp-select" data-field="woodRepairPostReplaceTie">${createSelect(SIMPSON_TIE_OPTIONS)}</select>
                <select class="sp-select" data-field="woodRepairPostReplaceCap">
                  <option value="">No cap</option>
                  ${createSelect(WOOD_POST_CAP_TYPES)}
                </select>
              </div>
            </div>
            <div class="sp-field col-12">
              <label class="sp-label">Post Realignments</label>
              <div data-wood-post-realign></div>
              <div class="sp-row" style="margin-top:6px">
                <button class="sp-btn ghost" type="button" data-wood-post-realign-add>+ Add Post Realignment</button>
                <span class="sp-hint">Add leaning posts and choose the realignment method.</span>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Post Installation</label>
              ${numberControl('woodRepairPostInstall','0')}
              <div class="sp-row">
                <select class="sp-select" data-field="woodRepairPostInstallMethod">${WOOD_POST_INSTALL_METHODS.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}</select>
                <select class="sp-select" data-field="woodRepairPostInstallTie">${createSelect(SIMPSON_TIE_OPTIONS)}</select>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Panel Replacement</label>
              ${numberControl('woodRepairPanelReplace','0')}
              <input class="sp-input" data-field="woodRepairPanelWidth" type="number" min="1" step="0.1" placeholder="Panel width (ft)" />
              <div class="sp-hint">Most panels are 8 ft wide.</div>
            </div>

            <div class="sp-field col-3">
              <label class="sp-label">Walk Gate Repair</label>
              ${numberControl('woodRepairWalkGateCount','0')}
              <div class="sp-row" style="gap:10px; margin-top:6px">
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateHinges" /> Replace hinges</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateLatch" /> Replace latch</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateWood" /> Replace wood</label>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Walk Gate Strengthen</label>
              ${numberControl('woodRepairGateStrengthen','0')}
              <div class="sp-hint">Add framing (2x4) to beef up the gate.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Walk Gate Replace</label>
              ${numberControl('woodRepairGateReplace','0')}
              <div class="sp-hint">Remove and rebuild with new hardware.</div>
            </div>

            <div class="sp-field col-3">
              <label class="sp-label">Top Cap Replacement (lf)</label>
              ${numberControl('woodRepairTopCapReplaceLf','0')}
              <select class="sp-select" data-field="woodRepairTopCapReplaceSize">
                <option value="2x6">2x6</option>
                <option value="2x8">2x8</option>
                <option value="2x10">2x10</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Trim Replacement (lf)</label>
              ${numberControl('woodRepairTrimReplaceLf','0')}
              <select class="sp-select" data-field="woodRepairTrimReplaceSize">${createSelect(WOOD_TRIM_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Kick Board Replacement (lf)</label>
              ${numberControl('woodRepairKickReplaceLf','0')}
              <div class="sp-row">
                <select class="sp-select" data-field="woodRepairKickReplaceSize">
                  <option value="2x6">2x6</option>
                  <option value="2x8">2x8</option>
                  <option value="2x10">2x10</option>
                  <option value="2x12">2x12</option>
                </select>
                <select class="sp-select" data-field="woodRepairKickReplaceStack">
                  <option value="1">1 Board</option>
                  <option value="2">2 Board Stack</option>
                  <option value="3">3 Board Stack</option>
                  <option value="4">4 Board Stack</option>
                </select>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Staining</label>
              <select class="sp-select" data-field="woodRepairStain">
                <option value="none">No staining</option>
                <option value="outside">Stain outside</option>
                <option value="inside">Stain inside</option>
                <option value="both">Stain both sides</option>
                <option value="wash-outside">Wash &amp; Stain outside</option>
                <option value="wash-inside">Wash &amp; Stain inside</option>
                <option value="wash-both">Wash &amp; Stain both sides</option>
                <option value="wash-hail-outside">Wash Hail &amp; Stain outside</option>
                <option value="wash-hail-inside">Wash Hail &amp; Stain inside</option>
                <option value="wash-hail-both">Wash Hail &amp; Stain both sides</option>
              </select>
            </div>
          </div>
        </div>

        <div class="sp-scope-group col-12 is-style" data-section-detail data-style-group>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Style, Finish & Patches</div>
            <div>
              <div class="sp-scope-title">Fence style, layout & finishing touches</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
        <div class="sp-grid col-12" data-retaining-wall data-install-only style="display:none">
          <div class="sp-field col-3">
            <label class="sp-label">Retaining Wall Length (ft)</label>
            ${numberControl('retainingWallLength','0')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Retaining Wall Height (ft)</label>
            <input class="sp-input" data-field="retainingWallHeight" type="number" inputmode="decimal" step="0.1" min="0" placeholder="e.g., 2.5" />
            <div class="sp-hint">In-House 4 pours the wall only at $35/sq ft ($1,500 min) including wall materials & labor; Jesus' crew installs the fence. Posts in the wall are set during the pour (no extra concrete bags).</div>
          </div>
        </div>

        <div class="sp-grid col-12" data-wrought-only>
          <div class="sp-field col-2">
            <label class="sp-label">Style</label>
            <select class="sp-select" data-field="style">${createSelect(SEED.style)}</select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Height</label>
            <select class="sp-select" data-field="height">${createSelect(SEED.height)}</select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Post Size</label>
            <select class="sp-select" data-field="postSize">${createSelect(SEED.postSize)}</select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Post Spacing (ft)</label>
            <select class="sp-select" data-field="postSpacing">
              <option value="4">4 ft</option>
              <option value="5">5 ft</option>
              <option value="6">6 ft</option>
              <option value="8">8 ft</option>
              <option value="10">10 ft</option>
            </select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Panel Attachment</label>
            <select class="sp-select" data-field="panelAttachment">
              <option value="Welding">Welding</option>
              <option value="Brackets">Brackets</option>
            </select>
          </div>
          <div class="sp-field col-2" data-install-finials style="display:none">
            <label class="sp-label">Finial Style</label>
            <select class="sp-select" data-field="installFinialStyle">${createSelect(SEED.finialStyles)}</select>
          </div>

          <div class="sp-field col-3">
            <label class="sp-label">LF Over Hardscape</label>
            ${numberControl('hardscape','e.g., 12')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">LF to Trim</label>
            ${numberControl('trim','e.g., 6')}
          </div>
          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label">LF to Dig Out</label>
            ${numberControl('digOut','e.g., 10')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Painting</label>
            <select class="sp-select" data-field="painting">
              <option value="Paint Section">Paint Section</option>
              <option value="Prime and Paint">Prime and Paint</option>
              <option value="Spot Paint Welds">Spot Paint Welds</option>
              <option value="None">None</option>
            </select>
          </div>
          <div class="sp-field col-3" data-painting-application style="display:none">
            <label class="sp-label">Paint Application</label>
            <select class="sp-select" data-field="paintingApplication">
              <option value="By Hand">By Hand</option>
              <option value="Spray">Spray</option>
            </select>
          </div>
          <div class="sp-field col-3" data-painting-prep style="display:none">
            <label class="sp-label">Prep Needs</label>
            <label class="sp-row" style="gap:6px">
              <input type="checkbox" data-field="paintingPrepExtra" />
              More than usual prep
            </label>
          </div>

          <div class="col-12 sp-divider"></div>

          <!-- ========== GROUP: Rails ========== -->
          <div class="sp-field col-12" data-rails-wrap>
            <div class="sp-rail-row" data-rails-row>
              <div class="sp-field" data-rail-count>
                <label class="sp-label">Rails</label>
                <select class="sp-select" data-field="railsCount">
                  <option value="2">2 Rail</option>
                  <option value="3">3 Rail</option>
                  <option value="4">4 Rail</option>
                </select>
              </div>
            </div>
          </div>

          <!-- ========== GROUP: Pickets & Finials ========== -->
          <div class="sp-field col-3">
            <label class="sp-label">Picket Size</label>
            <select class="sp-select" data-field="picketSize">${createSelect(SEED.picketSize)}</select>
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Picket Height (inches)</label>
            ${numberControl('picketHeight','e.g., 54')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Puppy Pickets</label>
            <select class="sp-select" data-field="puppy">${createSelect(SEED.puppy)}</select>
          </div>
        </div>
        </div>
        <div class="sp-scope-group col-12 is-repair" data-section-detail>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Repairs</div>
            <div>
              <div class="sp-scope-title">Posts, caps, panels & patch work</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
          <div class="sp-field col-12" data-repair-only>
            <label class="sp-label">Rail Repairs</label>
            <div class="sp-rail-row" data-rail-repair-row></div>
          </div>

          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label"># Pickets to Replace</label>
            ${numberControl('wiPickets','0')}
          </div>
          <div class="sp-field col-3" data-repair-only data-wrought-only data-puppy-repair>
            <label class="sp-label">Puppy Picket Size</label>
            <select class="sp-select" data-field="puppyPicketSize">${createSelect(SEED.picketSize)}</select>
          </div>
          <div class="sp-field col-3" data-repair-only data-wrought-only data-puppy-repair>
            <label class="sp-label">Puppy Picket Height (inches)</label>
            ${numberControl('puppyPicketHeight','e.g., 24')}
          </div>
          <div class="sp-field col-3" data-repair-only data-wrought-only data-puppy-repair>
            <label class="sp-label"># Puppy Pickets to Replace</label>
            ${numberControl('puppyPicketReplace','0')}
          </div>
          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label">Weld Redos</label>
            ${numberControl('weldRedos','0')}
            <div class="sp-hint">Redo broken welds (no new material). ~5 minutes each for a welder.</div>
          </div>

        <!-- Finial replacements (kept as a block) -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Finial Replacements</label>
          <div data-finials></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-finial-add>+ Add Finial Replacement</button>
            <span class="sp-hint">Each replacement adds ~30 seconds of labor. Unit cost: $1.25.</span>
          </div>
        </div>

        <!-- ========== GROUP: Posts & Caps ========== -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Replacements</label>
          <div data-post-replacements></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-post-replacement-add>+ Add Post Replacement</button>
            <span class="sp-hint">List each post size and quantity to replace.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Realignments</label>
          <div data-post-realign></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-post-realign-add>+ Add Post Realignment</button>
            <span class="sp-hint">Track leaning posts and choose the realignment method.</span>
          </div>
        </div>

        <!-- Post Cap replacements (kept as a block) -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Cap Replacements</label>
          <div data-caps></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-cap-add>+ Add Cap Replacement</button>
            <span class="sp-hint">Each cap adds ~20 seconds of labor. Pricing varies by size & style.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Diagonal Braces</label>
          <div data-diagonal-braces></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-diagonal-brace-add>+ Add Diagonal Brace</button>
            <span class="sp-hint">Each brace uses 4 ft of picket steel.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Full Rail Gap Fillers</label>
          <div data-gap-additions></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-gap-addition-add>+ Add Full Rail Gap Filler</button>
            <span class="sp-hint">Record each rail size and quantity to close open spans.</span>
          </div>
        </div>

        <div class="col-12 sp-divider"></div>

        <!-- ========== GROUP: Panel Replacements ========== -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Panel Replacements</label>
          <div data-panels></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-panel-add>+ Add Panel Replacement</button>
            <span class="sp-hint">Prefab panel eligible if width ≤ 96&quot; (8 ft), 1&quot; rails, and 1/2&quot; or 5/8&quot; pickets. Install = 30 min per panel; custom build+paint = 1.5 hr per panel.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Puppy Picket Inserts</label>
          <div data-puppy-inserts></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-puppy-insert-add>+ Add Puppy Picket Insert</button>
            <span class="sp-hint">Each insert takes a welder + helper about 30 minutes. Unit cost: $62.59 plus picket plugs.</span>
          </div>
        </div>

        <div class="col-12 sp-divider"></div>

          </div>
        </div>
        <div class="sp-scope-group col-12 is-gates" data-section-detail>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Gates</div>
            <div>
              <div class="sp-scope-title">Gate repairs & new openings</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
        <!-- ========== GROUP: Gates (unchanged, follows after above groups) ========== -->
        <div class="sp-field col-3" data-repair-only>
          <label class="sp-label"># Walk Gates</label>
          ${numberControl('walkGates','0')}
        </div>
        <div class="sp-field col-12" data-wg-wrap data-repair-only style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gates to Realign</label>
              ${numberControl('walkGatesRealign','0')}
            </div>
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gate Hardware Replacements</label>
              ${numberControl('walkGatesHardware','0')}
            </div>
            <div class="sp-field col-6" data-wg-hw-wrap style="display:none">
              <div class="sp-grid">
                <div class="sp-field col-6">
                  <label class="sp-label">Latch Type</label>
                  <select class="sp-select" data-field="walkLatch">${createSelect(GATE.latchTypes)}</select>
                </div>
                <div class="sp-field col-6">
                  <label class="sp-label">Hinges</label>
                  <select class="sp-select" data-field="walkHinges">${createSelect(GATE.hingeTypes)}</select>
                </div>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gates to Rebuild</label>
              ${numberControl('walkGatesRebuild','0')}
            </div>
            <div class="sp-field col-12" data-wg-rebuild-wrap style="display:none">
              <div class="sp-grid">
                <div class="sp-field col-3">
                  <label class="sp-label">Gate Frame Size</label>
                  <select class="sp-select" data-field="walkRebuildFrame">${createSelect(SEED.railSize)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Gate Picket Size</label>
                  <select class="sp-select" data-field="walkRebuildPicket">${createSelect(SEED.picketSize)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Latch Type</label>
                  <select class="sp-select" data-field="walkRebuildLatch">${createSelect(GATE.latchTypes)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Hinges</label>
                  <select class="sp-select" data-field="walkRebuildHinges">${createSelect(GATE.hingeTypes)}</select>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- NEW: Add a Walk Gate (into existing fence) -->
        <div class="sp-field col-3">
          <label class="sp-label"># Walk Gates to Add</label>
          ${numberControl('walkGatesAdd','0')}
        </div>
        <div class="sp-field col-12" data-wg-add-wrap style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Gate Type</label>
              <select class="sp-select" data-field="walkAddType">
                <option value="Single Swing Walk Gate">Single Swing Walk Gate</option>
                <option value="Double Swing Gate">Double Swing Gate</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Post Size</label>
              <select class="sp-select" data-field="walkAddPostSize">${createSelect(SEED.postSize)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Frame Size</label>
              <select class="sp-select" data-field="walkAddFrameSize">${createSelect(SEED.railSize)}</select>
            </div>
            <div class="sp-field col-3" data-wg-add-pickets>
              <label class="sp-label">Gate Picket Size</label>
              <select class="sp-select" data-field="walkAddPicketSize">${createSelect(SEED.picketSize)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Latch Type</label>
              <select class="sp-select" data-field="walkAddLatch">${createSelect(GATE.latchTypes)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Hinges</label>
              <select class="sp-select" data-field="walkAddHinges">${createSelect(GATE.hingeTypes)}</select>
            </div>
          </div>
          <div class="sp-hint">Single swing: adds 2 labor hours, 1 post, 1 bag concrete, and 2× 12ft rails per rail size. Double swing: adds 3 labor hours, 1 post, 1 bag concrete, and 4× 12ft rails per rail size.</div>
        </div>

        <!-- NEW: Replace Sliding Drive Gate Chain -->
        <div class="sp-field col-3" data-repair-only>
          <label class="sp-label"># Sliding Drive Gate Chains to Replace</label>
          ${numberControl('driveGateChainReplace','0')}
          <div class="sp-hint">Adds $150 materials and 1 crew hour per chain.</div>
        </div>

        <!-- NEW: Replace Drive Gate Operator -->
        <div class="sp-field col-3">
          <label class="sp-label"># Drive Gate Operators to Replace</label>
          ${numberControl('driveGateOperatorReplace','0')}
        </div>
        <div class="sp-field col-12" data-drive-operator-wrap style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Drive Gate Type</label>
              <select class="sp-select" data-field="driveGateOperatorType">${createSelect(DRIVE_GATE_OPERATOR_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Power Type</label>
              <select class="sp-select" data-field="driveGateOperatorPower">${createSelect(DRIVE_GATE_POWER_TYPES)}</select>
            </div>
          </div>
          <div class="sp-hint">Includes removal, haul away, and disposal of the old operator. LiftMaster only.</div>
        </div>

        <!-- NEW: Install Drive Gate Operator -->
        <div class="sp-field col-3">
          <label class="sp-label"># Drive Gate Operators to Install</label>
          ${numberControl('driveGateOperatorInstall','0')}
        </div>
        <div class="sp-field col-12" data-drive-operator-install-wrap style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Drive Gate Type</label>
              <select class="sp-select" data-field="driveGateOperatorInstallType">${createSelect(DRIVE_GATE_OPERATOR_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Power Type</label>
              <select class="sp-select" data-field="driveGateOperatorInstallPower">${createSelect(DRIVE_GATE_POWER_TYPES_INSTALL)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Platform Needed</label>
              <label class="sp-row" style="gap:6px">
                <input type="checkbox" data-field="driveGateOperatorInstallPlatform" />
                Build operator platform
              </label>
            </div>
          </div>
          <div class="sp-hint">LiftMaster only. No existing wiring option for installs.</div>
        </div>

        </div>

          </div>
        </div>
        <!-- Notes (section-specific) - LAST -->
        <div class="sp-field col-12">
          <label class="sp-label">Notes (section-specific)</label>
          <textarea class="sp-textarea" data-field="notes" placeholder="Any custom notes for this section..."></textarea>
        </div>
      </div>
    </div>`;
  }

  function addSection(data={}){
    syncStateFromDOM();
    state.sections.push(createSectionBase(data));
    render();
  }
  function duplicateSection(id){
    syncStateFromDOM();
    const src = state.sections.find(s=>s.id===id);
    if(!src) return;
    const copy = JSON.parse(JSON.stringify(src));
    copy.id = uid();
    copy.collapsed = false;
    copy.mapGenerated = false;
    delete copy.mapSegmentId;
    delete copy.mapGeneratedLabel;
    state.sections.push(copy);
    render();
  }

  const STYLE_FIELDS = [
    'fenceType','scopeType','style','height','postSize','postSpacing','panelAttachment','installFinialStyle','railsCount','rails',
    'picketSize','picketHeight','puppy','puppyPicketSize','puppyPicketHeight','puppyPicketReplace','painting','paintingApplication','paintingPrepExtra','woodHeight','woodStyle','woodPicketWidth','woodRailSize',
    'woodPost','woodType','woodFinish','woodKickBoardSize','woodKickBoardStack','woodTopCapSize','woodTrimType','woodAddKickBoard',
    'woodAddTopCap','woodAddTrim','woodRepairStain','walkLatch','walkHinges','walkRebuildFrame',
    'walkRebuildPicket','walkRebuildLatch','walkRebuildHinges','walkAddType','walkAddPostSize','walkAddFrameSize',
    'walkAddPicketSize','walkAddLatch','walkAddHinges','driveGateChainReplace','driveGateOperatorReplace','driveGateOperatorType',
    'driveGateOperatorPower','driveGateOperatorInstall','driveGateOperatorInstallType','driveGateOperatorInstallPower',
    'driveGateOperatorInstallPlatform','woodRepairPostReplaceTie','woodRepairPostReplaceCap',
    'woodPostRealignments','woodRepairPostInstallMethod','woodRepairPostInstallTie'
  ];

  function createSectionFromStyle(source){
    if(!source) return null;
    const base = createSectionBase({
      fenceType: source.fenceType,
      scopeType: source.scopeType,
      painting: source.painting
    });
    STYLE_FIELDS.forEach(key=>{
      if(typeof source[key] === 'undefined') return;
      const value = source[key];
      if(key === 'rails' && Array.isArray(value)){
        base.rails = value.map(rail=>({
          size: rail.size,
          stacked: !!rail.stacked,
          size2: rail.size2 || rail.size,
          patches: 0,
          replacements: 0,
        }));
        return;
      }
      const shouldClone = Array.isArray(value) || (value && typeof value === 'object');
      base[key] = shouldClone ? JSON.parse(JSON.stringify(value)) : value;
    });
    return base;
  }

  function duplicateSectionStyleFrom(source){
    const nextSection = createSectionFromStyle(source);
    if(!nextSection) return;
    state.sections.push(nextSection);
    render();
  }
  function duplicateFirstSectionStyle(){
    syncStateFromDOM();
    if(!state.sections.length) return;
    duplicateSectionStyleFrom(state.sections[0]);
  }
  function duplicateLatestSectionStyle(){
    syncStateFromDOM();
    if(!state.sections.length) return;
    duplicateSectionStyleFrom(state.sections[state.sections.length-1]);
  }
  function removeSection(id){
    syncStateFromDOM();
    state.sections = state.sections.filter(s=>s.id!==id);
    render();
  }

  function readSectionFromDOM(card){
    const id = card.getAttribute('data-id');
    function val(field){
      const el = card.querySelector(`[data-field="${field}"]`);
      if(!el) return '';
      if(el.classList.contains('sp-number')){
        return parseInt(el.querySelector('input').value||'0',10) || 0;
      }
      if(el.type==='checkbox'){ return !!el.checked; }
      if(el.tagName==='INPUT' || el.tagName==='TEXTAREA' || el.tagName==='SELECT') return el.value;
      return '';
    }

    const railsCount = parseInt(val('railsCount') || '2', 10);
    const rails = [];
    for(let i=0;i<railsCount;i++){
      rails.push({
        size: val(`railSize_${i}`),
        stacked: !!val(`railStacked_${i}`),
        size2: val(`railSize2_${i}`),
        patches: val(`railPatches_${i}`),
        replacements: val(`railRepl_${i}`)
      });
    }

    // NEW: Finials (dynamic rows)
    const finials = [];
    const finCont = card.querySelector('[data-finials]');
    if (finCont){
      const rows = Array.from(finCont.querySelectorAll('[data-finial-row]'));
      rows.forEach(row => {
        const qty = parseInt((row.querySelector('[data-finial-qty] input')?.value)||'0',10) || 0;
        const style = (row.querySelector('[data-finial-style]')?.value) || (SEED.finialStyles && SEED.finialStyles[0]);
        const material = (row.querySelector('[data-finial-material]')?.value) || (SEED.finialMaterials && SEED.finialMaterials[0]);
        const picketSize = (row.querySelector('[data-finial-picket]')?.value) || (SEED.picketSize && SEED.picketSize[0]);
        if(qty>0){ finials.push({ qty, style, material, picketSize }); }
      });
    }

    const puppyInserts = [];
    const puppyCont = card.querySelector('[data-puppy-inserts]');
    if(puppyCont){
      const rows = Array.from(puppyCont.querySelectorAll('[data-puppy-insert-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-puppy-insert-qty] input')?.value)||'0',10) || 0;
        const picketSize = (row.querySelector('[data-puppy-insert-size]')?.value) || PUPPY_INSERT_SIZES[0];
        if(qty>0){ puppyInserts.push({ qty, picketSize }); }
      });
    }

    // NEW: Caps (dynamic rows)
    const caps = [];
    const capCont = card.querySelector('[data-caps]');
    if (capCont){
      const rows = Array.from(capCont.querySelectorAll('[data-cap-row]'));
      rows.forEach(row => {
        const qty = parseInt((row.querySelector('[data-cap-qty] input')?.value)||'0',10) || 0;
        const style = (row.querySelector('[data-cap-style]')?.value) || (SEED.capStyles && SEED.capStyles[0]);
        const material = (row.querySelector('[data-cap-material]')?.value) || (SEED.capMaterials && SEED.capMaterials[0]);
        const postSize = (row.querySelector('[data-cap-post]')?.value) || (SEED.capPostSizes && SEED.capPostSizes[0]);
        if(qty>0){ caps.push({ qty, style, material, postSize }); }
      });
    }

    // PANELs (dynamic rows)
    const panels = [];
    const panelsCont = card.querySelector('[data-panels]');
    if(panelsCont){
      const rows = Array.from(panelsCont.querySelectorAll('[data-panel-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-panel-qty] input')?.value)||'0',10) || 0;
        const height = (row.querySelector('[data-panel-height]')?.value) || SEED.height[1];
        const style  = (row.querySelector('[data-panel-style]')?.value) || SEED.style[0];
        const railSize = (row.querySelector('[data-panel-rail]')?.value) || SEED.railSize[0];
        const picketSize = (row.querySelector('[data-panel-picket]')?.value) || SEED.picketSize[0];
        const widthIn = parseInt((row.querySelector('[data-panel-width] input')?.value)||'0',10) || 0;
        const hasFinials = /Finials/i.test(style);
        const finialStyle = hasFinials
          ? ((row.querySelector('[data-panel-finial-style]')?.value) || SEED.finialStyles[0])
          : '';
        if(qty>0){ panels.push({ qty, height, style, railSize, picketSize, widthIn, finialStyle }); }
      });
    }

    const gapAdditions = [];
    const gapCont = card.querySelector('[data-gap-additions]');
    if(gapCont){
      const rows = Array.from(gapCont.querySelectorAll('[data-gap-addition-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-gap-addition-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-gap-addition-size]')?.value) || SEED.railSize[0];
        if(qty>0){ gapAdditions.push({ qty, size }); }
      });
    }

    const diagonalBraces = [];
    const braceCont = card.querySelector('[data-diagonal-braces]');
    if(braceCont){
      const rows = Array.from(braceCont.querySelectorAll('[data-diagonal-brace-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-diagonal-brace-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-diagonal-brace-size]')?.value) || SEED.picketSize[0];
        if(qty>0){ diagonalBraces.push({ qty, size }); }
      });
    }

    const postReplacements = [];
    const postRepCont = card.querySelector('[data-post-replacements]');
    if(postRepCont){
      const rows = Array.from(postRepCont.querySelectorAll('[data-post-replacement-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-post-replacement-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-post-replacement-size]')?.value) || SEED.postSize[0];
        if(qty>0){ postReplacements.push({ qty, size }); }
      });
    }

    const postRealignments = [];
    const postRealignCont = card.querySelector('[data-post-realign]');
    if(postRealignCont){
      const rows = Array.from(postRealignCont.querySelectorAll('[data-post-realign-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-post-realign-qty] input')?.value)||'0',10) || 0;
        const rawMethod = (row.querySelector('[data-post-realign-method]')?.value) || 'concrete';
        const method = rawMethod === 'cut-weld' ? 'cut-weld' : 'concrete';
        const size = method === 'cut-weld'
          ? ''
          : ((row.querySelector('[data-post-realign-size]')?.value) || SEED.postRealignSize[0]);
        if(qty>0){
          const entry = { qty, method, size };
          postRealignments.push(entry);
        }
      });
    }

    const woodPostRealignments = [];
    const woodPostRealignCont = card.querySelector('[data-wood-post-realign]');
    if(woodPostRealignCont){
      const rows = Array.from(woodPostRealignCont.querySelectorAll('[data-wood-post-realign-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-wood-post-realign-qty] input')?.value)||'0',10) || 0;
        const method = (row.querySelector('[data-wood-post-realign-method]')?.value) || 'dig-straighten';
        if(qty>0){
          woodPostRealignments.push({ qty, method });
        }
      });
    }

    const currentFenceType = val('fenceType') || 'Wrought Iron';
    const normalizedFence = currentFenceType.toLowerCase();
    const paintingSelection = normalizedFence === 'wood' ? 'None' : val('painting');
    const paintingMethod = normalizedFence === 'wood' ? '' : val('paintingApplication');
    const paintingPrepExtra = paintingSelection === 'Paint Section' ? val('paintingPrepExtra') : false;

    return {
      id,
      label: val('label').trim(),
      fenceType: currentFenceType,
      scopeType: val('scopeType') || 'repair',
      style: val('style'),
      height: val('height'),
      postSize: val('postSize'),
      postSpacing: val('postSpacing'),
      panelAttachment: val('panelAttachment'),
      installFinialStyle: val('installFinialStyle'),
      postReplacements,
      postRealignments,

      railsCount,
      rails,
      gapAdditions,
      diagonalBraces,

      railSize: rails[0]?.size || '',
      railStacked: !!rails[0]?.stacked,
      railSize2: rails[0]?.size2 || '',

      picketSize: val('picketSize'),
      picketHeight: val('picketHeight'),
      puppy: val('puppy'),
      puppyPicketSize: val('puppyPicketSize'),
      puppyPicketHeight: val('puppyPicketHeight'),
      puppyPicketReplace: val('puppyPicketReplace'),
      painting: paintingSelection,
      paintingApplication: paintingMethod,
      paintingPrepExtra,
      woodHeight: val('woodHeight'),
      woodStyle: val('woodStyle'),
      woodPicketWidth: val('woodPicketWidth'),
      woodRailSize: val('woodRailSize'),
      woodPost: val('woodPost'),
      woodType: val('woodType'),
      woodFinish: val('woodFinish'),
      woodKickBoardSize: val('woodKickBoardSize'),
      woodKickBoardStack: val('woodKickBoardStack'),
      woodTopCapSize: val('woodTopCapSize'),
      woodTrimType: val('woodTrimType'),
      woodPostRealignments,
      woodRepairPicketReplace: val('woodRepairPicketReplace'),
      woodRepairPicketInstall: val('woodRepairPicketInstall'),
      woodRepairRailReplace: val('woodRepairRailReplace'),
      woodRepairRailInstall: val('woodRepairRailInstall'),
      woodRepairPostReplace: val('woodRepairPostReplace'),
      woodRepairPostReplaceTie: val('woodRepairPostReplaceTie'),
      woodRepairPostReplaceCap: val('woodRepairPostReplaceCap'),
      woodRepairPostInstall: val('woodRepairPostInstall'),
      woodRepairPostInstallMethod: val('woodRepairPostInstallMethod'),
      woodRepairPostInstallTie: val('woodRepairPostInstallTie'),
      woodRepairPanelReplace: val('woodRepairPanelReplace'),
      woodRepairPanelWidth: val('woodRepairPanelWidth'),
      woodRepairWalkGateCount: val('woodRepairWalkGateCount'),
      woodRepairWalkGateHinges: val('woodRepairWalkGateHinges'),
      woodRepairWalkGateLatch: val('woodRepairWalkGateLatch'),
      woodRepairWalkGateWood: val('woodRepairWalkGateWood'),
      woodRepairGateStrengthen: val('woodRepairGateStrengthen'),
      woodRepairGateReplace: val('woodRepairGateReplace'),
      woodRepairTopCapReplaceLf: val('woodRepairTopCapReplaceLf'),
      woodRepairTopCapReplaceSize: val('woodRepairTopCapReplaceSize'),
      woodRepairTrimReplaceLf: val('woodRepairTrimReplaceLf'),
      woodRepairTrimReplaceSize: val('woodRepairTrimReplaceSize'),
      woodRepairKickReplaceLf: val('woodRepairKickReplaceLf'),
      woodRepairKickReplaceSize: val('woodRepairKickReplaceSize'),
      woodRepairKickReplaceStack: val('woodRepairKickReplaceStack'),
      woodRepairStain: val('woodRepairStain'),
      woodAddKickBoard: val('woodAddKickBoard'),
      woodAddTopCap: val('woodAddTopCap'),
      woodAddTrim: val('woodAddTrim'),
      retainingWallLength: val('retainingWallLength'),
      retainingWallHeight: val('retainingWallHeight'),
      length: val('length'),
      hardscape: val('hardscape'),
      trim: val('trim'),
      digOut: val('digOut'),
      wiPickets: val('wiPickets'),
      weldRedos: val('weldRedos'),
      walkGates: val('walkGates'),
      walkGatesRealign: val('walkGatesRealign'),
      walkGatesHardware: val('walkGatesHardware'),
      walkGatesRebuild: val('walkGatesRebuild'),
      walkLatch: val('walkLatch'),
      walkHinges: val('walkHinges'),
      walkRebuildFrame: val('walkRebuildFrame'),
      walkRebuildPicket: val('walkRebuildPicket'),
      walkRebuildLatch: val('walkRebuildLatch'),
      walkRebuildHinges: val('walkRebuildHinges'),

      // NEW
      walkGatesAdd: val('walkGatesAdd'),
      walkAddType: val('walkAddType'),
      walkAddPostSize: val('walkAddPostSize'),
      walkAddFrameSize: val('walkAddFrameSize'),
      walkAddPicketSize: val('walkAddPicketSize'),
      walkAddLatch: val('walkAddLatch'),
      walkAddHinges: val('walkAddHinges'),
      driveGateChainReplace: val('driveGateChainReplace'),
      driveGateOperatorReplace: val('driveGateOperatorReplace'),
      driveGateOperatorType: val('driveGateOperatorType'),
      driveGateOperatorPower: val('driveGateOperatorPower'),
      driveGateOperatorInstall: val('driveGateOperatorInstall'),
      driveGateOperatorInstallType: val('driveGateOperatorInstallType'),
      driveGateOperatorInstallPower: val('driveGateOperatorInstallPower'),
      driveGateOperatorInstallPlatform: val('driveGateOperatorInstallPlatform'),

      // NEW: finials
      finials,
      // NEW: puppy picket inserts
      puppyInserts,
      // NEW: caps
      caps,
      // NEW: panels
      panels,

      mapGenerated: card.dataset.mapGenerated === 'true',
      mapSegmentId: card.dataset.mapSegmentId || '',
      mapGeneratedLabel: card.dataset.mapGeneratedLabel || '',

      notes: val('notes').trim()
    };
  }

  function syncStateFromDOM(){
    const cards = $$('.sp-card', sectionsEl);
    if(!cards.length) return;
    const newSections = cards.map(readSectionFromDOM);
    newSections.forEach(ns=>{
      const old = state.sections.find(s=>s.id===ns.id);
      if(old){
        if('collapsed' in old) ns.collapsed = old.collapsed;
      }
    });
    state.sections = newSections;
  }

  function writeSectionToDOM(card, data){
    function set(field, value){
      const el = card.querySelector(`[data-field="${field}"]`);
      if(!el) return;
      if(el.classList.contains('sp-number')){
        el.querySelector('input').value = value ?? '';
      } else if(el.type==='checkbox'){
        el.checked = Boolean(value);
      } else if(el.tagName==='SELECT' || el.tagName==='INPUT' || el.tagName==='TEXTAREA'){
        el.value = value ?? '';
      }
    }
    card.dataset.mapGenerated = data.mapGenerated ? 'true' : 'false';
    if(data.mapSegmentId){
      card.dataset.mapSegmentId = data.mapSegmentId;
    }else{
      delete card.dataset.mapSegmentId;
    }
    if(data.mapGeneratedLabel){
      card.dataset.mapGeneratedLabel = data.mapGeneratedLabel;
    }else{
      delete card.dataset.mapGeneratedLabel;
    }
    set('label', data.label||'');
    set('fenceType', data.fenceType || 'Wrought Iron');
    set('scopeType', data.scopeType||'repair');
    set('style', data.style||SEED.style[0]);
    set('height', data.height||'4ft');
    set('postSize', data.postSize||'2x2');
    set('postSpacing', data.postSpacing||'8');
    set('panelAttachment', data.panelAttachment||'Welding');
    set('installFinialStyle', data.installFinialStyle||SEED.finialStyles[0]);

    set('railsCount', data.railsCount || 2);
    renderRailsControls(card, data);
    renderGapAdditionsControls(card, data);
    renderDiagonalBracesControls(card, data);

    set('picketSize', data.picketSize||SEED.picketSize[0]);
    set('picketHeight', data.picketHeight||'');
    set('puppy', data.puppy||SEED.puppy[0]);
    set('puppyPicketSize', data.puppyPicketSize || data.picketSize || SEED.picketSize[0]);
    set('puppyPicketHeight', data.puppyPicketHeight || '');
    set('puppyPicketReplace', data.puppyPicketReplace || '');
    const normalizedFenceType = (data.fenceType || 'Wrought Iron').toLowerCase();
    const scopeForPaint = data.scopeType || 'repair';
    const attachmentMethod = data.panelAttachment || 'Welding';
    const defaultPainting = normalizedFenceType === 'wood'
      ? 'None'
      : (!data.painting && (scopeForPaint === 'install' || scopeForPaint === 'replace'))
        ? (attachmentMethod === 'Brackets' ? 'None' : 'Spot Paint Welds')
        : (data.painting || 'Paint Section');
    set('painting', defaultPainting);
    set('paintingApplication', data.paintingApplication || 'By Hand');
    set('paintingPrepExtra', Boolean(data.paintingPrepExtra));
    set('woodHeight', data.woodHeight || '6ft');
    set('woodStyle', data.woodStyle || 'Side by Side');
    set('woodPicketWidth', data.woodPicketWidth || '5.5"');
    set('woodRailSize', data.woodRailSize || '2x4');
    const woodPostVal = data.woodPost || 'Round Steel';
    set('woodPost', woodPostVal);
    set('woodType', data.woodType || 'Cedar');
    set('woodFinish', data.woodFinish || 'Oil Based Stain');
    set('woodKickBoardSize', data.woodKickBoardSize || '2x6');
    set('woodKickBoardStack', data.woodKickBoardStack || '1');
    set('woodTopCapSize', data.woodTopCapSize || '2x6');
    set('woodTrimType', data.woodTrimType || '1x4');
    set('woodRepairPicketReplace', data.woodRepairPicketReplace || '');
    set('woodRepairPicketInstall', data.woodRepairPicketInstall || '');
    set('woodRepairRailReplace', data.woodRepairRailReplace || '');
    set('woodRepairRailInstall', data.woodRepairRailInstall || '');
    set('woodRepairPostReplace', data.woodRepairPostReplace || '');
    const defaultTie = defaultTieForWoodPost(woodPostVal);
    set('woodRepairPostReplaceTie', data.woodRepairPostReplaceTie || defaultTie);
    const hasPostCap = Object.prototype.hasOwnProperty.call(data, 'woodRepairPostReplaceCap');
    set('woodRepairPostReplaceCap', hasPostCap ? data.woodRepairPostReplaceCap : defaultCapForWoodPost(woodPostVal));
    set('woodRepairPostInstall', data.woodRepairPostInstall || '');
    set('woodRepairPostInstallMethod', data.woodRepairPostInstallMethod || WOOD_POST_INSTALL_METHODS[1].value);
    set('woodRepairPostInstallTie', data.woodRepairPostInstallTie || defaultTie);
    set('woodRepairPanelReplace', data.woodRepairPanelReplace || '');
    set('woodRepairPanelWidth', data.woodRepairPanelWidth || '');
    set('woodRepairWalkGateCount', data.woodRepairWalkGateCount || '');
    set('woodRepairWalkGateHinges', Boolean(data.woodRepairWalkGateHinges));
    set('woodRepairWalkGateLatch', Boolean(data.woodRepairWalkGateLatch));
    set('woodRepairWalkGateWood', Boolean(data.woodRepairWalkGateWood));
    set('woodRepairGateStrengthen', data.woodRepairGateStrengthen || '');
    set('woodRepairGateReplace', data.woodRepairGateReplace || '');
    set('woodRepairTopCapReplaceLf', data.woodRepairTopCapReplaceLf || '');
    set('woodRepairTopCapReplaceSize', data.woodRepairTopCapReplaceSize || data.woodTopCapSize || '2x6');
    set('woodRepairTrimReplaceLf', data.woodRepairTrimReplaceLf || '');
    set('woodRepairTrimReplaceSize', data.woodRepairTrimReplaceSize || data.woodTrimType || WOOD_TRIM_TYPES[1]);
    set('woodRepairKickReplaceLf', data.woodRepairKickReplaceLf || '');
    set('woodRepairKickReplaceSize', data.woodRepairKickReplaceSize || data.woodKickBoardSize || '2x6');
    set('woodRepairKickReplaceStack', data.woodRepairKickReplaceStack || data.woodKickBoardStack || '1');
    set('woodRepairStain', data.woodRepairStain || 'none');
    set('woodAddKickBoard', Boolean(data.woodAddKickBoard));
    set('woodAddTopCap', Boolean(data.woodAddTopCap));
    set('woodAddTrim', Boolean(data.woodAddTrim));
    set('retainingWallLength', data.retainingWallLength || '');
    set('retainingWallHeight', data.retainingWallHeight || '');
    updateWoodAddonsConditional(card);
    set('length', data.length||'');
    set('hardscape', data.hardscape||'');
    set('trim', data.trim||'');
    set('digOut', data.digOut||'');
    set('wiPickets', data.wiPickets||'');
    set('weldRedos', data.weldRedos||'');
    set('walkGates', data.walkGates||'');
    set('walkGatesRealign', data.walkGatesRealign||'');
    set('walkGatesHardware', data.walkGatesHardware||'');
    set('walkGatesRebuild', data.walkGatesRebuild||'');
    set('walkLatch', data.walkLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkHinges', data.walkHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');
    set('walkRebuildFrame', data.walkRebuildFrame || SEED.railSize[0]);
    set('walkRebuildPicket', data.walkRebuildPicket || SEED.picketSize[0]);
    set('walkRebuildLatch', data.walkRebuildLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkRebuildHinges', data.walkRebuildHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');

    set('walkGatesAdd', data.walkGatesAdd||'');
    set('walkAddType', data.walkAddType || 'Single Swing Walk Gate');
    set('walkAddPostSize', data.walkAddPostSize || data.postSize || '2x2');
    set('walkAddFrameSize', data.walkAddFrameSize || SEED.railSize[0]);
    set('walkAddPicketSize', data.walkAddPicketSize || SEED.picketSize[0]);
    set('walkAddLatch', data.walkAddLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkAddHinges', data.walkAddHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');
    set('driveGateChainReplace', data.driveGateChainReplace || '');
    set('driveGateOperatorReplace', data.driveGateOperatorReplace || '');
    set('driveGateOperatorType', data.driveGateOperatorType || DRIVE_GATE_OPERATOR_TYPES[0]);
    set('driveGateOperatorPower', data.driveGateOperatorPower || DRIVE_GATE_POWER_TYPES[0]);
    set('driveGateOperatorInstall', data.driveGateOperatorInstall || '');
    set('driveGateOperatorInstallType', data.driveGateOperatorInstallType || DRIVE_GATE_OPERATOR_TYPES[0]);
    const installPower = DRIVE_GATE_POWER_TYPES_INSTALL.includes(data.driveGateOperatorInstallPower)
      ? data.driveGateOperatorInstallPower
      : DRIVE_GATE_POWER_TYPES_INSTALL[0];
    set('driveGateOperatorInstallPower', installPower);
    set('driveGateOperatorInstallPlatform', Boolean(data.driveGateOperatorInstallPlatform));

    set('notes', data.notes||'');

    // NEW: render post groups
    renderPostReplacementControls(card, data);
    renderPostRealignControls(card, data);
    renderWoodPostRealignControls(card, data);
    // NEW: render finial rows
    renderFinialsControls(card, data);
    renderPuppyInsertControls(card, data);
    // NEW: render cap rows
    renderCapsControls(card, data);
    // NEW: render panel rows
    renderPanelsControls(card, data);
    const toggleBtn = card.querySelector('.sp-toggle');
    const isCollapsed = Boolean(data.collapsed);
    card.classList.toggle('is-collapsed', isCollapsed);
    if(toggleBtn){
      toggleBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      toggleBtn.setAttribute('aria-expanded', (!isCollapsed).toString());
    }
  }
  // === NEW: cap row rendering & persistence ===
  function renderPostGroups(card, data, cfg){
    const cont = card.querySelector(cfg.container);
    if(!cont) return;
    cont.innerHTML = '';
    const options = Array.isArray(cfg.options) && cfg.options.length ? cfg.options : SEED.postSize;
    const arr = Array.isArray(data[cfg.prop]) ? data[cfg.prop] : [];

    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute(cfg.rowAttr, '');
      row.innerHTML = `
        <div class="sp-field col-3">
          <label class="sp-label">Qty</label>
          <div class="sp-number" ${cfg.qtyAttr}>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Post Size</label>
          <select class="sp-select" ${cfg.sizeAttr}>${createSelect(options)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" ${cfg.removeAttr} type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector(cfg.sizeSel);
      if(sizeSel){
        sizeSel.value = item.size || options[0];
      }
    });

    const addBtn = card.querySelector(cfg.addBtn);
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s[cfg.prop])) s[cfg.prop] = [];
        const defaultSize = typeof cfg.defaultSize === 'function'
          ? cfg.defaultSize(s)
          : cfg.defaultSize;
        const nextSize = defaultSize || options[0] || '';
        s[cfg.prop].push({ qty: 1, size: nextSize });
        renderPostGroups(card, s, cfg);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest(cfg.removeSel);
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll(cfg.rowSel));
      const row = btn.closest(cfg.rowSel);
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s[cfg.prop])) return;
      if(idx >= 0){
        s[cfg.prop].splice(idx,1);
        renderPostGroups(card, s, cfg);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches(cfg.sizeSel)){
        persistPostGroupsFromDOM(card, cfg);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest(cfg.qtySel)){
        persistPostGroupsFromDOM(card, cfg);
        persist();
      }
    });
    updateMapControlsUI();
  }

  function persistPostGroupsFromDOM(card, cfg){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector(cfg.container);
    const rows = cont ? Array.from(cont.querySelectorAll(cfg.rowSel)) : [];
    const options = Array.isArray(cfg.options) && cfg.options.length ? cfg.options : SEED.postSize;
    s[cfg.prop] = rows.map(row=>{
      const qty = parseInt((row.querySelector(`${cfg.qtySel} input`)?.value)||'0',10) || 0;
      const size = (row.querySelector(cfg.sizeSel)?.value) || options[0] || '';
      return { qty, size };
    });
  }

  function persistPostRealignmentsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-post-realign]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-post-realign-row]')) : [];
    s.postRealignments = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-post-realign-qty] input')?.value)||'0',10) || 0;
      const rawMethod = (row.querySelector('[data-post-realign-method]')?.value) || 'concrete';
      const method = rawMethod === 'cut-weld' ? 'cut-weld' : 'concrete';
      const size = method === 'cut-weld'
        ? ''
        : ((row.querySelector('[data-post-realign-size]')?.value) || SEED.postRealignSize[0] || '');
      return { qty, method, size };
    });
  }

  function persistWoodPostRealignmentsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-wood-post-realign]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-wood-post-realign-row]')) : [];
    s.woodPostRealignments = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-wood-post-realign-qty] input')?.value)||'0',10) || 0;
      const method = (row.querySelector('[data-wood-post-realign-method]')?.value) || 'dig-straighten';
      return { qty, method };
    });
  }

  function renderPostReplacementControls(card, data){
    renderPostGroups(card, data, {
      prop: 'postReplacements',
      container: '[data-post-replacements]',
      rowAttr: 'data-post-replacement-row',
      rowSel: '[data-post-replacement-row]',
      qtyAttr: 'data-post-replacement-qty',
      qtySel: '[data-post-replacement-qty]',
      sizeAttr: 'data-post-replacement-size',
      sizeSel: '[data-post-replacement-size]',
      removeAttr: 'data-post-replacement-remove',
      removeSel: '[data-post-replacement-remove]',
      addBtn: '[data-post-replacement-add]',
      options: SEED.postSize,
      defaultSize: (section)=> section.postSize || SEED.postSize[0]
    });
  }

  function updatePostRealignRowState(row){
    if(!row) return;
    const methodSel = row.querySelector('[data-post-realign-method]');
    const sizeWrap = row.querySelector('[data-post-realign-size-wrap]');
    const sizeSel = row.querySelector('[data-post-realign-size]');
    const method = (methodSel?.value) || 'concrete';
    const isCutWeld = method === 'cut-weld';
    if(sizeWrap){
      sizeWrap.style.display = isCutWeld ? 'none' : '';
    }
    if(sizeSel){
      sizeSel.disabled = isCutWeld;
    }
  }

  function renderPostRealignControls(card, data){
    const cont = card.querySelector('[data-post-realign]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.postRealignments) ? data.postRealignments : [];
    const methodOptions = POST_REALIGN_METHODS.map(opt=>`<option value="${escapeAttr(opt.value)}">${escapeHtml(opt.label)}</option>`).join('');

    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-post-realign-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-post-realign-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Method</label>
          <select class="sp-select" data-post-realign-method>${methodOptions}</select>
        </div>
        <div class="sp-field col-4" data-post-realign-size-wrap>
          <label class="sp-label">Post Size</label>
          <select class="sp-select" data-post-realign-size>${createSelect(SEED.postRealignSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-post-realign-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const methodSel = row.querySelector('[data-post-realign-method]');
      if(methodSel){
        const normalized = String(item.method || 'concrete').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'concrete';
        methodSel.value = normalized;
      }
      const sizeSel = row.querySelector('[data-post-realign-size]');
      if(sizeSel){ sizeSel.value = item.size || SEED.postRealignSize[0]; }
      updatePostRealignRowState(row);
    });

    const addBtn = card.querySelector('[data-post-realign-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.postRealignments)) s.postRealignments = [];
        const defaultSize = SEED.postRealignSize[0] || '2x2';
        s.postRealignments.push({ qty: 1, size: defaultSize, method: 'concrete' });
        renderPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-post-realign-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-post-realign-row]'));
      const row = btn.closest('[data-post-realign-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.postRealignments)) return;
      if(idx >= 0){
        s.postRealignments.splice(idx,1);
        renderPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      const methodSel = e.target.closest('[data-post-realign-method]');
      const sizeSel = e.target.closest('[data-post-realign-size]');
      if(methodSel){
        const row = methodSel.closest('[data-post-realign-row]');
        updatePostRealignRowState(row);
        persistPostRealignmentsFromDOM(card);
        persist();
      } else if(sizeSel){
        persistPostRealignmentsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-post-realign-qty]')){
        persistPostRealignmentsFromDOM(card);
        persist();
      }
    });
  }

  function renderWoodPostRealignControls(card, data){
    const cont = card.querySelector('[data-wood-post-realign]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.woodPostRealignments) ? data.woodPostRealignments : [];
    const fallbackDig = parseInt(data.woodRepairPostRealignDig || 0, 10) || 0;
    const fallbackCut = parseInt(data.woodRepairPostRealignCutWeld || 0, 10) || 0;
    if(!arr.length && (fallbackDig || fallbackCut)){
      const temp = [];
      if(fallbackDig){ temp.push({ qty: fallbackDig, method: 'dig-straighten' }); }
      if(fallbackCut){ temp.push({ qty: fallbackCut, method: 'cut-weld' }); }
      data.woodPostRealignments = temp;
    }

    const methodOptions = WOOD_POST_METHODS.map(opt=>`<option value="${escapeAttr(opt.value)}">${escapeHtml(opt.label)}</option>`).join('');

    data.woodPostRealignments.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-wood-post-realign-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-wood-post-realign-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-6">
          <label class="sp-label">Method</label>
          <select class="sp-select" data-wood-post-realign-method>${methodOptions}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-wood-post-realign-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const methodSel = row.querySelector('[data-wood-post-realign-method]');
      if(methodSel){
        const normalized = String(item.method || 'dig-straighten').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'dig-straighten';
        methodSel.value = normalized;
      }
    });

    const addBtn = card.querySelector('[data-wood-post-realign-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.woodPostRealignments)) s.woodPostRealignments = [];
        s.woodPostRealignments.push({ qty: 1, method: 'dig-straighten' });
        renderWoodPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-wood-post-realign-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-wood-post-realign-row]'));
      const row = btn.closest('[data-wood-post-realign-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.woodPostRealignments)) return;
      if(idx >= 0){
        s.woodPostRealignments.splice(idx,1);
        renderWoodPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.closest('[data-wood-post-realign-method]')){
        persistWoodPostRealignmentsFromDOM(card);
        persist();
        updateWoodRepairControls(card);
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-wood-post-realign-qty]')){
        persistWoodPostRealignmentsFromDOM(card);
        persist();
      }
    });
  }

  const POST_SIZE_KEY = {
    '1 1/2" x 1 1/2"': 'posts1p5',
    '2x2': 'posts2x2',
    '3x3': 'posts3x3',
    '4x4': 'posts4x4'
  };
  const POST_KEY_LABEL = {
    posts1p5: '1 1/2" x 1 1/2"',
    posts2x2: '2x2',
    posts3x3: '3x3',
    posts4x4: '4x4'
  };
  const CAP_LABEL_RE = /^caps - (.+?) - (.+?) \((.+?)\)$/; // material, style, postSize

  function postSizeKey(size){
    const raw = String(size||'').trim();
    if(POST_SIZE_KEY[raw]) return POST_SIZE_KEY[raw];
    const compact = raw
      .toLowerCase()
      .replace(/×/g,'x')
      .replace(/\s+/g,'')
      .replace(/inch|\"/g,'');
    if(compact === '11/2x11/2' || compact === '1.5x1.5') return 'posts1p5';
    if(compact === '2x2') return 'posts2x2';
    if(compact === '3x3') return 'posts3x3';
    if(compact === '4x4') return 'posts4x4';
    return null;
  }

  function countPostGroups(arr){
    const counts = { posts1p5:0, posts2x2:0, posts3x3:0, posts4x4:0 };
    (Array.isArray(arr) ? arr : []).forEach(item=>{
      const qty = parseInt(item?.qty,10) || 0;
      if(qty <= 0) return;
      if((item?.method || 'concrete') === 'cut-weld') return;
      const key = postSizeKey(item?.size || item?.postSize);
      if(key && Object.prototype.hasOwnProperty.call(counts, key)){
        counts[key] += qty;
      }
    });
    return counts;
  }

  function postKeyToLabel(key){
    return POST_KEY_LABEL[key] || '';
  }

  function countRealignCutWeld(arr){
    let total = 0;
    (Array.isArray(arr) ? arr : []).forEach(item=>{
      const qty = parseInt(item?.qty,10) || 0;
      if(qty <= 0) return;
      if((item?.method || 'concrete') === 'cut-weld'){
        total += qty;
      }
    });
    return total;
  }

  function addPostCounts(target, counts){
    Object.keys(counts).forEach(key=>{
      target[key] = (target[key]||0) + (parseInt(counts[key],10) || 0);
    });
  }

  function renderCapsControls(card, data){
    const cont = card.querySelector('[data-caps]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.caps) ? data.caps : [];
    arr.forEach((c)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-cap-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-cap-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${c.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-cap-style>${createSelect(SEED.capStyles)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Material</label>
          <select class="sp-select" data-cap-material>${createSelect(SEED.capMaterials)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Post Size</label>
          <select class="sp-select" data-cap-post>${createSelect(SEED.capPostSizes)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-cap-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const styleSel = row.querySelector('[data-cap-style]'); if(styleSel) styleSel.value = c.style || SEED.capStyles[0];
      const matSel   = row.querySelector('[data-cap-material]'); if(matSel) matSel.value = c.material || SEED.capMaterials[0];
      const postSel  = row.querySelector('[data-cap-post]'); if(postSel) postSel.value = c.postSize || SEED.capPostSizes[0];
    });

    const addBtn = card.querySelector('[data-cap-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.caps)) s.caps = [];
        s.caps.push({ qty: 1, style: SEED.capStyles[0], material: SEED.capMaterials[0], postSize: SEED.capPostSizes[0] });
        renderCapsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-cap-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-cap-row]'));
      const row = btn.closest('[data-cap-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.caps)) return;
      s.caps.splice(idx,1);
      renderCapsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-cap-style], [data-cap-material], [data-cap-post]')){
        persistCapsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-cap-qty]')){
        persistCapsFromDOM(card);
        persist();
      }
    });
  }

  function persistCapsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-caps]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-cap-row]')) : [];
    s.caps = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-cap-qty] input')?.value)||'0',10) || 0;
      const style = (row.querySelector('[data-cap-style]')?.value) || SEED.capStyles[0];
      const material = (row.querySelector('[data-cap-material]')?.value) || SEED.capMaterials[0];
      const postSize = (row.querySelector('[data-cap-post]')?.value) || SEED.capPostSizes[0];
      return { qty, style, material, postSize };
    });
  }

  // ===== Rails helpers/handlers =====
  function railLabels(count){
    const n = parseInt(count||2,10);
    if(n===4) return ['Top Rail','Second Rail','Third Rail','Bottom Rail'];
    if(n===3) return ['Top Rail','Middle Rail','Bottom Rail'];
    return ['Top Rail','Bottom Rail'];
  }

  function sectionRailSizes(section){
    const sizes = new Set();
    const rails = Array.isArray(section?.rails) ? section.rails : [];
    const count = section?.railsCount || rails.length;
    for(let i=0;i<count;i++){
      const r = rails[i] || {};
      if(r.size) sizes.add(r.size);
      if(r.stacked && r.size2) sizes.add(r.size2);
    }
    const gaps = Array.isArray(section?.gapAdditions) ? section.gapAdditions : [];
    gaps.forEach(g=>{ if(g && g.size) sizes.add(g.size); });
    if(!sizes.size){
      if(section?.railSize) sizes.add(section.railSize);
      if(section?.railStacked && section?.railSize2) sizes.add(section.railSize2);
    }
    return Array.from(sizes).filter(Boolean);
  }

  function renderRailsControls(card, data){
    const row  = card.querySelector('[data-rails-row]');
    const repairRow = card.querySelector('[data-rail-repair-row]');
    if(!row) return;
    $$('[data-rail-block]', row).forEach(el=> el.remove());
    if(repairRow) $$('[data-rail-block]', repairRow).forEach(el=> el.remove());
    const count = parseInt((data.railsCount!=null?data.railsCount:2),10);
    const labels = railLabels(count);
    const rails = Array.isArray(data.rails) ? data.rails : [];
    row.style.setProperty('--rail-cols', `repeat(${count+1}, minmax(200px, 1fr))`);
    if(repairRow){
      repairRow.style.setProperty('--rail-cols', `repeat(${count}, minmax(200px, 1fr))`);
    }
    labels.forEach((label,i)=>{
      const block = document.createElement('div');
      block.className = `sp-field`;
      block.setAttribute('data-rail-block','');
      const patchesHtml = numberControl('railPatches_'+i,'0');
      const replHtml    = numberControl('railRepl_'+i,'0');
      block.innerHTML = `
        <label class="sp-label">${label} Size</label>
        <select class="sp-select" data-field="railSize_${i}">${createSelect(SEED.railSize)}</select>
        <div class="sp-row" style="margin-top:6px">
          <label class="sp-row" style="gap:6px; align-items:center">
            <input type="checkbox" data-field="railStacked_${i}" />
            <span>Stacked</span>
          </label>
        </div>
        <div class="sp-field" data-if="railStacked_${i}" style="display:none; margin-top:6px">
          <label class="sp-label">Second ${label} Size</label>
          <select class="sp-select" data-field="railSize2_${i}">${createSelect(SEED.railSize)}</select>
        </div>
      `;
      row.appendChild(block);
      if(repairRow){
        const repairBlock = document.createElement('div');
        repairBlock.className = 'sp-field';
        repairBlock.setAttribute('data-rail-block','');
        repairBlock.innerHTML = `
          <label class="sp-label">${label} Repairs</label>
          <div class="sp-field" data-rail-repair style="margin-top:6px">
            <label class="sp-label"># Rail Patches (${label})</label>
            ${patchesHtml}
          </div>
          <div class="sp-field" data-rail-repair style="margin-top:6px">
            <label class="sp-label"># Full Rail Replacements (${label})</label>
            ${replHtml}
          </div>
        `;
        repairRow.appendChild(repairBlock);
      }
      const r = rails[i] || {};
      const sizeEl    = card.querySelector(`[data-field="railSize_${i}"]`);
      const stackEl   = card.querySelector(`[data-field="railStacked_${i}"]`);
      const size2El   = card.querySelector(`[data-field="railSize2_${i}"]`);
      const patchesBox= card.querySelector(`[data-field="railPatches_${i}"]`);
      const replBox   = card.querySelector(`[data-field="railRepl_${i}"]`);
      if(sizeEl) sizeEl.value = r.size || SEED.railSize[0];
      if(stackEl) stackEl.checked = Boolean(r.stacked);
      if(size2El) size2El.value = r.size2 || SEED.railSize[0];
      if(patchesBox) patchesBox.querySelector('input').value = r.patches || 0;
      if(replBox)    replBox.querySelector('input').value    = r.replacements || 0;
      const cond = card.querySelector(`[data-if="railStacked_${i}"]`);
      if(cond && stackEl) cond.style.display = stackEl.checked ? 'block' : 'none';
    });
  }

  function renderGapAdditionsControls(card, data){
    const cont = card.querySelector('[data-gap-additions]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.gapAdditions) ? data.gapAdditions : [];
    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-gap-addition-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-gap-addition-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-gap-addition-size>${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-gap-addition-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-gap-addition-size]');
      if(sizeSel) sizeSel.value = item.size || SEED.railSize[0];
    });

    const addBtn = card.querySelector('[data-gap-addition-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.gapAdditions)) s.gapAdditions = [];
        s.gapAdditions.push({ qty:1, size: SEED.railSize[0] });
        renderGapAdditionsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-gap-addition-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-gap-addition-row]'));
      const row = btn.closest('[data-gap-addition-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.gapAdditions)) return;
      s.gapAdditions.splice(idx,1);
      renderGapAdditionsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-gap-addition-size]')){
        persistGapAdditionsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-gap-addition-qty]')){
        persistGapAdditionsFromDOM(card);
        persist();
      }
    });
  }

  function persistGapAdditionsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-gap-additions]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-gap-addition-row]')) : [];
    s.gapAdditions = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-gap-addition-qty] input')?.value)||'0',10) || 0;
      const size = (row.querySelector('[data-gap-addition-size]')?.value) || SEED.railSize[0];
      return { qty, size };
    });
  }

  function renderDiagonalBracesControls(card, data){
    const cont = card.querySelector('[data-diagonal-braces]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.diagonalBraces) ? data.diagonalBraces : [];
    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-diagonal-brace-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-diagonal-brace-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Brace Size</label>
          <select class="sp-select" data-diagonal-brace-size>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-diagonal-brace-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-diagonal-brace-size]');
      if(sizeSel) sizeSel.value = item.size || SEED.picketSize[0];
    });

    const addBtn = card.querySelector('[data-diagonal-brace-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.diagonalBraces)) s.diagonalBraces = [];
        const defaultSize = s.picketSize || SEED.picketSize[0];
        s.diagonalBraces.push({ qty:1, size: defaultSize });
        renderDiagonalBracesControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-diagonal-brace-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-diagonal-brace-row]'));
      const row = btn.closest('[data-diagonal-brace-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.diagonalBraces)) return;
      s.diagonalBraces.splice(idx,1);
      renderDiagonalBracesControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-diagonal-brace-size]')){
        persistDiagonalBracesFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-diagonal-brace-qty]')){
        persistDiagonalBracesFromDOM(card);
        persist();
      }
    });
  }

  function persistDiagonalBracesFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-diagonal-braces]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-diagonal-brace-row]')) : [];
    s.diagonalBraces = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-diagonal-brace-qty] input')?.value)||'0',10) || 0;
      const size = (row.querySelector('[data-diagonal-brace-size]')?.value) || SEED.picketSize[0];
      return { qty, size };
    });
  }

  // === NEW: finial row rendering & persistence ===
  // === PANEL REPLACEMENTS: row rendering & persistence ===
  function renderPanelsControls(card, data){
    const cont = card.querySelector('[data-panels]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.panels) ? data.panels : [];

    arr.forEach((p)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-panel-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-panel-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${p.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Height</label>
          <select class="sp-select" data-panel-height>${createSelect(SEED.height)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-panel-style>${createSelect(PANEL_REPLACEMENT_STYLES)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-panel-rail>${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-panel-picket>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Panel Width (in)</label>
          <div class="sp-number" data-panel-width>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="1" value="${p.widthIn||96}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3" data-panel-finial-wrap style="display:none">
          <label class="sp-label">Finial Style (26 / panel)</label>
          <select class="sp-select" data-panel-finial-style>${createSelect(SEED.finialStyles)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-panel-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);

      // set defaults
      row.querySelector('[data-panel-height]').value = p.height || SEED.height[1];
      row.querySelector('[data-panel-style]').value  = p.style  || SEED.style[0];
      row.querySelector('[data-panel-rail]').value   = p.railSize || SEED.railSize[0];
      row.querySelector('[data-panel-picket]').value = p.picketSize || SEED.picketSize[0];
      const finWrap = row.querySelector('[data-panel-finial-wrap]');
      const styleSel = row.querySelector('[data-panel-style]');
      const finSel = row.querySelector('[data-panel-finial-style]');
      if(styleSel){
        const show = /Finials/i.test(styleSel.value);
        finWrap.style.display = show ? 'block' : 'none';
      }
      if(finSel){ finSel.value = p.finialStyle || SEED.finialStyles[0]; }
    });

    const addBtn = card.querySelector('[data-panel-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.panels)) s.panels = [];
        s.panels.push({ qty:1, height: SEED.height[1], style: SEED.style[0], railSize: SEED.railSize[0], picketSize: SEED.picketSize[0], widthIn: 96, finialStyle: ''});
        renderPanelsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-panel-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-panel-row]'));
      const row = btn.closest('[data-panel-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.panels)) return;
      s.panels.splice(idx,1);
      renderPanelsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-panel-style], [data-panel-height], [data-panel-rail], [data-panel-picket], [data-panel-finial-style]')){
        // Toggle finial picker visibility
        if(e.target.matches('[data-panel-style]')){
          const wrap = e.target.closest('[data-panel-row]').querySelector('[data-panel-finial-wrap]');
          const show = /Finials/i.test(e.target.value);
          wrap.style.display = show ? 'block' : 'none';
          if(show){
            const finSel = wrap.querySelector('[data-panel-finial-style]');
            if(finSel && !finSel.value){ finSel.value = SEED.finialStyles[0]; }
          }
        }
        persistPanelsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-panel-qty]') || e.target.closest('[data-panel-width]')){
        persistPanelsFromDOM(card);
        persist();
      }
    });
  }

  function persistPanelsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-panels]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-panel-row]')) : [];
    s.panels = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-panel-qty] input')?.value)||'0',10) || 0;
      const height = (row.querySelector('[data-panel-height]')?.value) || SEED.height[1];
      const style  = (row.querySelector('[data-panel-style]')?.value) || SEED.style[0];
      const railSize = (row.querySelector('[data-panel-rail]')?.value) || SEED.railSize[0];
      const picketSize = (row.querySelector('[data-panel-picket]')?.value) || SEED.picketSize[0];
      const widthIn = parseInt((row.querySelector('[data-panel-width] input')?.value)||'0',10) || 0;
      const hasFinials = /Finials/i.test(style);
      const finialStyle = hasFinials
        ? ((row.querySelector('[data-panel-finial-style]')?.value) || SEED.finialStyles[0])
        : '';
      return { qty, height, style, railSize, picketSize, widthIn, finialStyle };
    });
  }
  function renderFinialsControls(card, data){
    const cont = card.querySelector('[data-finials]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.finials) ? data.finials : [];
    arr.forEach((f)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-finial-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-finial-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${f.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-finial-style>${createSelect(SEED.finialStyles)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Material</label>
          <select class="sp-select" data-finial-material>${createSelect(SEED.finialMaterials)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-finial-picket>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-finial-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const styleSel = row.querySelector('[data-finial-style]'); if(styleSel) styleSel.value = f.style || SEED.finialStyles[0];
      const matSel   = row.querySelector('[data-finial-material]'); if(matSel)  matSel.value  = f.material || SEED.finialMaterials[0];
      const pickSel  = row.querySelector('[data-finial-picket]'); if(pickSel)   pickSel.value = f.picketSize || SEED.picketSize[0];
    });

    const addBtn = card.querySelector('[data-finial-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.finials)) s.finials = [];
        s.finials.push({ qty: 1, style: SEED.finialStyles[0], material: SEED.finialMaterials[0], picketSize: s.picketSize || SEED.picketSize[0] });
        renderFinialsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-finial-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-finial-row]'));
      const row = btn.closest('[data-finial-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.finials)) return;
      s.finials.splice(idx,1);
      renderFinialsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-finial-style], [data-finial-material], [data-finial-picket]')){
        persistFinialsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-finial-qty]')){
        persistFinialsFromDOM(card);
        persist();
      }
    });
  }

  function renderPuppyInsertControls(card, data){
    const cont = card.querySelector('[data-puppy-inserts]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.puppyInserts) ? data.puppyInserts : [];
    arr.forEach(item=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-puppy-insert-row','');
      row.innerHTML = `
        <div class="sp-field col-3">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-puppy-insert-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-puppy-insert-size>${createSelect(PUPPY_INSERT_SIZES)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-puppy-insert-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-puppy-insert-size]');
      const normalized = normalizeSize(item.picketSize);
      const preferred = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
      if(sizeSel){ sizeSel.value = preferred; }
    });

    const addBtn = card.querySelector('[data-puppy-insert-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.puppyInserts)) s.puppyInserts = [];
        const normalized = normalizeSize(s.picketSize);
        const defaultSize = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
        s.puppyInserts.push({ qty: 1, picketSize: defaultSize });
        renderPuppyInsertControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-puppy-insert-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-puppy-insert-row]'));
      const row = btn.closest('[data-puppy-insert-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.puppyInserts)) return;
      if(idx>=0){
        s.puppyInserts.splice(idx,1);
        renderPuppyInsertControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-puppy-insert-size]')){
        persistPuppyInsertsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-puppy-insert-qty]')){
        persistPuppyInsertsFromDOM(card);
        persist();
      }
    });
  }

  function persistPuppyInsertsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-puppy-inserts]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-puppy-insert-row]')) : [];
    s.puppyInserts = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-puppy-insert-qty] input')?.value)||'0',10) || 0;
      let picketSize = (row.querySelector('[data-puppy-insert-size]')?.value) || PUPPY_INSERT_SIZES[0];
      const normalized = normalizeSize(picketSize);
      if(PUPPY_INSERT_SIZES.includes(normalized)){
        picketSize = normalized;
      } else {
        picketSize = PUPPY_INSERT_SIZES[0];
      }
      return { qty, picketSize };
    });
  }

  function persistFinialsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-finials]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-finial-row]')) : [];
    s.finials = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-finial-qty] input')?.value)||'0',10) || 0;
      const style = (row.querySelector('[data-finial-style]')?.value) || SEED.finialStyles[0];
      const material = (row.querySelector('[data-finial-material]')?.value) || SEED.finialMaterials[0];
      const picketSize = (row.querySelector('[data-finial-picket]')?.value) || SEED.picketSize[0];
      return { qty, style, material, picketSize };
    });
  }

  function attachRailsHandlers(card){
    const countSel = card.querySelector('[data-field="railsCount"]');
    if(countSel){
      countSel.addEventListener('change', ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId) || {};
        const newCount = parseInt(countSel.value||'2',10);
        s.railsCount = newCount;
        if(!Array.isArray(s.rails)) s.rails = [];
        const labels = railLabels(newCount);
        s.rails = labels.map((_, i)=> s.rails[i] || { size: SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0 });
        renderRailsControls(card, s);
        renderGapAdditionsControls(card, s);
        renderDiagonalBracesControls(card, s);
        attachNumberHandlers(card);
        persist();
      });
    }

    card.addEventListener('change', (e)=>{
      const t = e.target;
      if(!t) return;
      if(t.matches('input[data-field^="railStacked_"]')){
        const key = t.getAttribute('data-field');
        const cond = card.querySelector(`[data-if="${key}"]`);
        if(cond) cond.style.display = t.checked ? 'block' : 'none';
      }
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateWoodAddonsConditional(card);
      updateWoodRepairControls(card);
      updateInstallConditional(card);
      persist();
    });
  }

  function attachNumberHandlers(card){
    if(card.dataset.numberHandlersAttached === 'true') return;
    card.dataset.numberHandlersAttached = 'true';

    card.addEventListener('click', (e)=>{
      const btn = e.target.closest('.sp-step');
      if(!btn || !card.contains(btn)) return;
      const box = btn.closest('.sp-number');
      if(!box) return;
      const input = $('input', box);
      if(!input) return;
      const dir = parseInt(btn.getAttribute('data-dir')||'0',10) || 0;
      const current = parseInt(input.value||'0',10) || 0;
      const min = parseInt(input.getAttribute('min')||'0',10) || 0;
      const next = Math.max(min, current + dir);
      input.value = next;
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateInstallConditional(card);
      persist();
    });

    card.addEventListener('change', (e)=>{
      const input = e.target.closest('.sp-number input');
      if(!input || !card.contains(input)) return;
      const val = parseInt(input.value||'0',10) || 0;
      const min = parseInt(input.getAttribute('min')||'0',10)||0;
      input.value = Math.max(min, val);
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateInstallConditional(card);
      persist();
    });
  }

  function allowInstallFinials(style, puppy){
    return /finials/i.test(String(style||'')) || /finials/i.test(String(puppy||''));
  }

  function hasPuppyPickets(puppy){
    return /puppy/i.test(String(puppy||'')) && !/none/i.test(String(puppy||''));
  }

  function updatePuppyPicketRepairFields(card){
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isRepair = scope !== 'install' && scope !== 'replace';
    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWrought = fenceType === 'wrought iron';
    const puppyVal = (card.querySelector('[data-field="puppy"]') || {}).value || '';
    const show = isRepair && isWrought && hasPuppyPickets(puppyVal);
    card.querySelectorAll('[data-puppy-repair]').forEach(el=>{
      el.style.display = show ? '' : 'none';
    });
    if(show){
      const sizeSel = card.querySelector('[data-field="puppyPicketSize"]');
      if(sizeSel && !sizeSel.value){
        sizeSel.value = (card.querySelector('[data-field="picketSize"]') || {}).value || SEED.picketSize[0];
      }
    }
  }

  function updatePaintingApplicationUI(card){
    const wrap = card.querySelector('[data-painting-application]');
    const prepWrap = card.querySelector('[data-painting-prep]');
    if(!wrap) return;
    const paintingSel = card.querySelector('[data-field="painting"]');
    const methodSel = card.querySelector('[data-field="paintingApplication"]');
    const prepSel = card.querySelector('[data-field="paintingPrepExtra"]');
    const paintingVal = paintingSel ? paintingSel.value : '';
    const show = paintingVal === 'Paint Section' || paintingVal === 'Prime and Paint';
    wrap.style.display = show ? '' : 'none';
    if(prepWrap){
      const showPrep = paintingVal === 'Paint Section';
      prepWrap.style.display = showPrep ? '' : 'none';
      if(!showPrep && prepSel){
        prepSel.checked = false;
      }
    }
    if(show){
      if(methodSel && !methodSel.value){
        methodSel.value = 'By Hand';
      }
    }else if(methodSel && methodSel.value !== 'By Hand'){
      methodSel.value = 'By Hand';
      methodSel.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  function updateStyleGroupVisibility(card){
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isRepair = scope !== 'install' && scope !== 'replace';
    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWood = fenceType === 'wood';
    const styleGroup = card.querySelector('[data-style-group]');
    if(styleGroup){
      styleGroup.style.display = (isWood && isRepair) ? 'none' : '';
    }
  }

  function updateInstallConditional(card){
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isInstall = scope === 'install' || scope === 'replace';
    card.querySelectorAll('[data-install-only]').forEach(el=>{
      el.style.display = isInstall ? '' : 'none';
    });
    card.querySelectorAll('[data-repair-only]').forEach(el=>{
      el.style.display = isInstall ? 'none' : '';
    });

    const styleVal = (card.querySelector('[data-field="style"]') || {}).value || '';
    const puppyVal = (card.querySelector('[data-field="puppy"]') || {}).value || '';
    const finialsWrap = card.querySelector('[data-install-finials]');
    if(finialsWrap){
      const showFinials = isInstall && allowInstallFinials(styleVal, puppyVal);
      finialsWrap.style.display = showFinials ? '' : 'none';
      const finSel = card.querySelector('[data-field="installFinialStyle"]');
      if(finSel && showFinials && !finSel.value){
        finSel.value = SEED.finialStyles[0];
      }
    }

    card.querySelectorAll('[data-rail-repair]').forEach(el=>{
      el.style.display = isInstall ? 'none' : '';
      if(isInstall){
        const input = el.querySelector('input');
        if(input){ input.value = '0'; }
      }
    });

    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWrought = fenceType === 'wrought iron';
    const isWood = fenceType === 'wood';
    const showRetainingWall = isInstall && (isWrought || isWood);
    const retainingWrap = card.querySelector('[data-retaining-wall]');
    if(retainingWrap){
      retainingWrap.style.display = showRetainingWall ? '' : 'none';
    }

    const paintingSel = card.querySelector('[data-field="painting"]');
    if(paintingSel){
      const currentVal = paintingSel.value;
      if(isWood && currentVal !== 'None'){
        paintingSel.value = 'None';
        paintingSel.dispatchEvent(new Event('change', { bubbles: true }));
      } else if(isInstall && isWrought){
        const attachmentSel = card.querySelector('[data-field="panelAttachment"]');
        const usesBrackets = attachmentSel ? attachmentSel.value === 'Brackets' : false;
        const desired = usesBrackets ? 'None' : 'Spot Paint Welds';
        const autoValues = new Set(['', 'Paint Section', 'Spot Paint Welds', 'None']);
        if(autoValues.has(currentVal) && currentVal !== desired){
          paintingSel.value = desired;
          paintingSel.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }
    updatePaintingApplicationUI(card);
    updatePuppyPicketRepairFields(card);
    updateStyleGroupVisibility(card);
  }

  function updateFenceTypeConditional(card){
    const typeSel = card.querySelector('[data-field="fenceType"]');
    const fenceType = (typeSel?.value || 'Wrought Iron').toLowerCase();
    const isWood = fenceType === 'wood';
    card.classList.toggle('is-wood', isWood);
    card.classList.toggle('is-wrought', !isWood);
    const paintingField = card.querySelector('[data-field="painting"]');
    const paintingWrap = paintingField?.closest('.sp-field');
    const paintingAppWrap = card.querySelector('[data-painting-application]');
    const paintingPrepWrap = card.querySelector('[data-painting-prep]');
    if(isWood){
      if(paintingField && paintingField.value !== 'None'){
        paintingField.value = 'None';
        paintingField.dispatchEvent(new Event('change', { bubbles: true }));
      }
      if(paintingWrap){ paintingWrap.style.display = 'none'; }
      if(paintingAppWrap){ paintingAppWrap.style.display = 'none'; }
      if(paintingPrepWrap){ paintingPrepWrap.style.display = 'none'; }
    }else{
      if(paintingWrap){ paintingWrap.style.display = ''; }
      updatePaintingApplicationUI(card);
    }
    if(isWood){
      const defaultWoodPost = 'Round Steel';
      const defaultTie = defaultTieForWoodPost(defaultWoodPost);
      const defaults = {
        woodHeight: '6ft',
        woodStyle: 'Side by Side',
        woodPicketWidth: '5.5"',
        woodRailSize: '2x4',
        woodPost: defaultWoodPost,
        woodType: 'Cedar',
        woodFinish: 'Oil Based Stain',
        woodKickBoardSize: '2x6',
        woodKickBoardStack: '1',
        woodTopCapSize: '2x6',
        woodTrimType: '1x4',
        woodPostRealignments: [],
        woodRepairPostInstallMethod: WOOD_POST_INSTALL_METHODS[1].value,
        woodRepairPostReplaceTie: defaultTie,
        woodRepairPostInstallTie: defaultTie,
        woodRepairTopCapReplaceSize: '2x6',
        woodRepairTrimReplaceSize: '1x4',
        woodRepairKickReplaceSize: '2x6',
        woodRepairKickReplaceStack: '1',
        woodRepairStain: 'none'
      };
      Object.entries(defaults).forEach(([field, val])=>{
        const el = card.querySelector(`[data-field="${field}"]`);
        if(!el) return;
        if((el.tagName === 'SELECT' || el.tagName === 'INPUT') && !el.value){
          el.value = val;
        }
      });
    }
    updateWoodAddonsConditional(card);
    updateWoodRepairControls(card);
    updatePuppyPicketRepairFields(card);
    updateStyleGroupVisibility(card);
  }

  function resetSectionForFenceType(card, nextType){
    if(!card) return;
    const normalizedType = String(nextType || '').toLowerCase();
    const secId = card.getAttribute('data-id');
    const existingIdx = state.sections.findIndex(s=>s.id===secId);
    const existing = existingIdx >= 0 ? state.sections[existingIdx] : null;
    const preserved = existing ? {
      id: existing.id,
      label: existing.label,
      scopeType: existing.scopeType,
      length: existing.length,
      hardscape: existing.hardscape,
      trim: existing.trim,
      digOut: existing.digOut,
      mapGenerated: existing.mapGenerated,
      mapSegmentId: existing.mapSegmentId,
      mapGeneratedLabel: existing.mapGeneratedLabel,
      collapsed: existing.collapsed
    } : { id: secId, scopeType: 'repair' };
    const fenceType = normalizedType === 'wood' ? 'Wood' : 'Wrought Iron';
    const fresh = createSectionBase({ ...preserved, fenceType });
    if(existingIdx >= 0){
      state.sections.splice(existingIdx, 1, fresh);
    } else {
      state.sections.push(fresh);
    }
    writeSectionToDOM(card, fresh);
    card.dataset.lastFenceType = normalizedType;
    card.dataset.lastWoodPost = (fresh.woodPost || '').toLowerCase();
    updateFenceTypeConditional(card);
    updateInstallConditional(card);
    updateWalkGateConditional(card);
    updateDriveGateOperatorConditional(card);
    persist();
  }

  function updateWoodAddonsConditional(card){
    const checkbox = card.querySelector('[data-field="woodAddKickBoard"]');
    const kickboardDetails = card.querySelector('[data-kickboard-settings]');
    const topCapCheckbox = card.querySelector('[data-field="woodAddTopCap"]');
    const topCapDetails = card.querySelector('[data-topcap-settings]');
    const trimCheckbox = card.querySelector('[data-field="woodAddTrim"]');
    const trimDetails = card.querySelector('[data-trim-settings]');
    const showKickboard = checkbox && checkbox.checked;
    const showTopCap = topCapCheckbox && topCapCheckbox.checked;
    const showTrim = trimCheckbox && trimCheckbox.checked;

    if(kickboardDetails){
      kickboardDetails.style.display = showKickboard ? '' : 'none';
    }
    if(topCapDetails){
      topCapDetails.style.display = showTopCap ? '' : 'none';
    }
    if(trimDetails){
      trimDetails.style.display = showTrim ? '' : 'none';
    }
  }

  function updateWoodRepairControls(card){
    const postType = (card.querySelector('[data-field="woodPost"]')?.value || '').toLowerCase();
    const prevPostType = (card.dataset.lastWoodPost || '').toLowerCase();
    if(postType && postType !== prevPostType){
      applyWoodPostDefaults(card, prevPostType);
    }
    if(postType){
      card.dataset.lastWoodPost = postType;
    }
    const allowCutWeld = postType === 'round steel' || postType === 'postmaster';
    const methodSelects = card.querySelectorAll('[data-wood-post-realign-method]');
    methodSelects.forEach(sel => {
      const cutOption = Array.from(sel.options).find(opt=>opt.value==='cut-weld');
      if(cutOption){ cutOption.disabled = !allowCutWeld; }
      if(!allowCutWeld && sel.value === 'cut-weld'){
        sel.value = 'dig-straighten';
        persistWoodPostRealignmentsFromDOM(card);
      }
    });
  }

  function updateWalkGateConditional(card){
    const getN = (f)=>{
      const box = card.querySelector(`.sp-number[data-field="${f}"] input`);
      return parseInt((box && box.value) || '0',10) || 0;
    };
    const wg = getN('walkGates');
    const hw = getN('walkGatesHardware');
    const rb = getN('walkGatesRebuild');
    const add = getN('walkGatesAdd');
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isInstall = scope === 'install' || scope === 'replace';

    const wrap = card.querySelector('[data-wg-wrap]');
    if(wrap){ wrap.style.display = (!isInstall && wg>0) ? 'block' : 'none'; }
    const hwWrap = card.querySelector('[data-wg-hw-wrap]');
    if(hwWrap){ hwWrap.style.display = (!isInstall && wg>0 && hw>0) ? 'block' : 'none'; }
    const rbWrap = card.querySelector('[data-wg-rebuild-wrap]');
    if(rbWrap){ rbWrap.style.display = (!isInstall && wg>0 && rb>0) ? 'block' : 'none'; }

    const addWrap = card.querySelector('[data-wg-add-wrap]');
    if(addWrap){ addWrap.style.display = add>0 ? 'block' : 'none'; }
  }

  function updateDriveGateOperatorConditional(card){
    const replBox = card.querySelector('.sp-number[data-field="driveGateOperatorReplace"] input');
    const replCount = parseInt((replBox && replBox.value) || '0',10) || 0;
    const replWrap = card.querySelector('[data-drive-operator-wrap]');
    if(replWrap){ replWrap.style.display = replCount>0 ? 'block' : 'none'; }

    const installBox = card.querySelector('.sp-number[data-field="driveGateOperatorInstall"] input');
    const installCount = parseInt((installBox && installBox.value) || '0',10) || 0;
    const installWrap = card.querySelector('[data-drive-operator-install-wrap]');
    if(installWrap){ installWrap.style.display = installCount>0 ? 'block' : 'none'; }
  }

  function applyMapLinkedStateToCard(card, sectionData){
    const lengthControl = card.querySelector('[data-field="length"]');
    if(lengthControl && lengthControl.classList.contains('sp-number')){
      const input = lengthControl.querySelector('input');
      const buttons = lengthControl.querySelectorAll('button');
      if(sectionData.mapGenerated){
        lengthControl.classList.add('is-map-linked');
        if(input){
          input.readOnly = true;
          input.setAttribute('aria-readonly','true');
        }
        buttons.forEach(btn=>{
          btn.disabled = true;
          btn.setAttribute('aria-disabled','true');
        });
      }else{
        lengthControl.classList.remove('is-map-linked');
        if(input){
          input.readOnly = false;
          input.removeAttribute('aria-readonly');
        }
        buttons.forEach(btn=>{
          btn.disabled = false;
          btn.removeAttribute('aria-disabled');
        });
      }
    }

    const removeBtn = card.querySelector('.sp-del');
    if(removeBtn){
      if(sectionData.mapGenerated){
        removeBtn.disabled = true;
        removeBtn.title = 'Remove this run on the map to delete the section';
      }else{
        removeBtn.disabled = false;
        removeBtn.title = '';
      }
    }

    const duplicateBtn = card.querySelector('.sp-dup');
    if(duplicateBtn){
      if(sectionData.mapGenerated){
        duplicateBtn.disabled = true;
        duplicateBtn.title = 'Duplicate not available for map-linked sections';
      }else{
        duplicateBtn.disabled = false;
        duplicateBtn.title = '';
      }
    }

    const actionRow = card.querySelector('.sp-card-header .sp-row');
    if(actionRow){
      let chip = actionRow.querySelector('[data-map-chip]');
      if(sectionData.mapGenerated){
        if(!chip){
          chip = document.createElement('span');
          chip.className = 'sp-chip is-info';
          chip.dataset.mapChip = 'true';
          chip.textContent = 'Map linked';
          actionRow.insertBefore(chip, actionRow.firstChild);
        }
      }else if(chip){
        chip.remove();
      }
    }
  }

  function updateQuickActions(){
    const hasSections = state.sections.length > 0;
    const firstBtn = document.getElementById('sp-quick-dup-first');
    const lastBtn = document.getElementById('sp-quick-dup-last');
    const addBtn = document.getElementById('sp-quick-add');

    if(addBtn){ addBtn.disabled = false; }

    if(firstBtn){
      firstBtn.disabled = !hasSections;
      const firstLabel = state.sections[0]?.label?.trim();
      firstBtn.title = hasSections
        ? `Copy style from Section 1${firstLabel ? ` – ${firstLabel}` : ''}`
        : 'Add a section to copy its style';
    }

    if(lastBtn){
      lastBtn.disabled = !hasSections;
      const latest = state.sections[state.sections.length-1];
      const lastLabel = latest?.label?.trim();
      lastBtn.title = hasSections
        ? `Copy style from Section ${state.sections.length}${lastLabel ? ` – ${lastLabel}` : ''}`
        : 'Add a section to copy its style';
    }
  }

  function render(){
    const sectionsEl = document.getElementById('sp-sections');
    sectionsEl.innerHTML = '';
    state.sections.forEach((s, idx)=>{
      const wrapper = document.createElement('div');
      wrapper.innerHTML = sectionTemplate(s.id, idx);
      const card = wrapper.firstElementChild;
      sectionsEl.appendChild(card);
      writeSectionToDOM(card, s);
      card.dataset.lastFenceType = (s.fenceType || 'Wrought Iron').toLowerCase();
      card.dataset.lastWoodPost = (s.woodPost || '').toLowerCase();
      updateSectionBasicsGate(card);
      updateFenceTypeConditional(card);
      attachNumberHandlers(card);
      attachRailsHandlers(card);
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateInstallConditional(card);
      applyMapLinkedStateToCard(card, s);

      const titleEl = $('.sp-card-title', card);
      const labelInput = card.querySelector('[data-field="label"]');
      function refreshTitle(){
        const v = (labelInput.value||'').trim();
        titleEl.textContent = `Section ${idx+1}${v ? ' - ' + v : ''}`;
      }
      refreshTitle();
      labelInput.addEventListener('input', ()=>{
        refreshTitle();
        updateSectionBasicsGate(card);
      });

      const deleteBtn = $('.sp-del', card);
      if(deleteBtn){
        let confirmTimer = null;
        const resetConfirm = ()=>{
          deleteBtn.dataset.confirm = '';
          deleteBtn.textContent = 'Remove';
          deleteBtn.classList.remove('is-confirm');
          if(confirmTimer){
            clearTimeout(confirmTimer);
            confirmTimer = null;
          }
        };
        deleteBtn.addEventListener('click', ()=>{
          if(deleteBtn.dataset.confirm === 'true'){
            resetConfirm();
            removeSection(s.id);
            persist();
            return;
          }
          deleteBtn.dataset.confirm = 'true';
          deleteBtn.textContent = 'Confirm Remove';
          deleteBtn.classList.add('is-confirm');
          if(confirmTimer){
            clearTimeout(confirmTimer);
          }
          confirmTimer = setTimeout(()=>{ resetConfirm(); }, 4000);
        });
      }
      $('.sp-dup', card).addEventListener('click', ()=>{ duplicateSection(s.id); persist(); });

      const toggleBtn = $('.sp-toggle', card);
      if(toggleBtn){
        toggleBtn.addEventListener('click', ()=>{
          const next = !card.classList.contains('is-collapsed');
          card.classList.toggle('is-collapsed', next);
          toggleBtn.textContent = next ? 'Expand' : 'Collapse';
          toggleBtn.setAttribute('aria-expanded', (!next).toString());
          const sec = state.sections.find(x=>x.id===s.id);
          if(sec){ sec.collapsed = next; }
          persist();
        });
      }

      $$('input, select, textarea', card).forEach(el=>{
        el.addEventListener('input', ()=>{
          updateSectionBasicsGate(card);
          persist();
        });
        el.addEventListener('change', ()=>{
          if(el.matches('[data-field="fenceType"]')){
            const nextType = (el.value || '').toLowerCase();
            const prevType = card.dataset.lastFenceType || '';
            if(nextType !== prevType){
              resetSectionForFenceType(card, nextType);
              return;
            }
          }
          updateFenceTypeConditional(card);
          updateWalkGateConditional(card);
          updateDriveGateOperatorConditional(card);
          updateInstallConditional(card);
          updateSectionBasicsGate(card);
          persist();
        });
      });
    });
    updateQuickActions();
  }

  function feetFromStr(h){
    const m = String(h||'').match(/(\d+)/);
    return m ? parseInt(m[1],10) : 0;
  }
  function styleFactor(v){
    if(v === 'Flat Top') return 2;
    if(v === 'Extended Picket') return 1.75;
    return 1.5;
  }
  function railPacePenalty(count){
    const rails = parseInt(count, 10);
    if(!rails || rails <= 2) return 0;
    return (rails - 2) * 0.25;
  }
  function puppyAdj(v){
    if(v === 'Puppy Pickets') return 0.25;
    if(v === 'Puppy Pickets w/ Finials') return 0.5;
    return 0;
  }
  function normalizeLabelText(text){
    return String(text||'')
      .replace(/\u201D|”/g,'"')
      .replace(/\u201C|“/g,'"')
      .replace(/\u2019|’/g,"'")
      .replace(/\u2018|‘/g,"'")
      .replace(/×/g,'x')
      .trim();
  }
  function isPostmasterPost(post){
    return /postmaster/i.test(String(post||''));
  }
  function isRoundSteelPost(post){
    return /round steel/i.test(String(post||''));
  }
  function defaultTieForWoodPost(post){
    return isPostmasterPost(post) ? NO_TIES_OPTION : SIMPSON_TIE_OPTIONS[0];
  }
  function defaultCapForWoodPost(post){
    if(isPostmasterPost(post)) return '';
    if(isRoundSteelPost(post)) return 'Dome cap';
    return '';
  }
  function isNoTiesSelection(tie){
    return /no\s*ties/i.test(String(tie||''));
  }
  function applyWoodPostDefaults(card, prevPost){
    if(!card) return;
    const postSel = card.querySelector('[data-field="woodPost"]');
    if(!postSel) return;
    const nextPost = postSel.value || '';
    const prevTieDefault = defaultTieForWoodPost(prevPost);
    const nextTieDefault = defaultTieForWoodPost(nextPost);
    const prevCapDefault = defaultCapForWoodPost(prevPost);
    const nextCapDefault = defaultCapForWoodPost(nextPost);
    const replaceTieSel = card.querySelector('[data-field="woodRepairPostReplaceTie"]');
    const installTieSel = card.querySelector('[data-field="woodRepairPostInstallTie"]');
    const capSel = card.querySelector('[data-field="woodRepairPostReplaceCap"]');
    [replaceTieSel, installTieSel].forEach(sel=>{
      if(!sel) return;
      const current = sel.value || '';
      if(!current || current === prevTieDefault){
        sel.value = nextTieDefault;
      }
    });
    if(capSel){
      const current = capSel.value || '';
      if(current === prevCapDefault){
        capSel.value = nextCapDefault;
      }
    }
  }
  function woodPicketStyleForSection(section){
    return section && section.woodAddTrim ? 'Flat Top' : 'Dog Ear';
  }
  function woodPicketMaterialLabel(section){
    if(!section) return 'wood picket';
    const widthLabel = normalizeLabelText(section.woodPicketWidth || '');
    const heightLabel = normalizeLabelText(section.woodHeight || section.height || '');
    const typeLabel = normalizeLabelText(section.woodType || '') || 'Cedar';
    const styleLabel = woodPicketStyleForSection(section);
    const parts = [widthLabel, heightLabel, typeLabel, styleLabel].filter(Boolean);
    if(!parts.length) return 'wood picket';
    return `wood picket (${parts.join(', ')})`;
  }
  function woodRailMaterialLabel(section){
    if(!section) return 'wood rail';
    const sizeLabel = normalizeLabelText(section.woodRailSize || '');
    const typeLabel = woodRailTypeLabel(section);
    const parts = [sizeLabel, typeLabel].filter(Boolean);
    return `wood rail${parts.length ? ` (${parts.join(', ')})` : ''}`;
  }
  function woodRailDescriptor(section){
    if(!section) return 'rail';
    const sizeLabel = normalizeLabelText(section.woodRailSize || '');
    const typeLabel = woodRailTypeLabel(section);
    const parts = [sizeLabel, typeLabel].filter(Boolean);
    return parts.length ? `${parts.join(' ')} rail` : 'rail';
  }
  function woodRailTypeLabel(section){
    if(!section) return '';
    const typeLabel = normalizeLabelText(section.woodType || '');
    if(!typeLabel) return '';
    const finishLabel = String(section.woodFinish || '');
    if(/stain/i.test(finishLabel) && /cedar/i.test(typeLabel)){
      return 'Stained Cedar';
    }
    return typeLabel;
  }
  function woodPicketUnitPriceFromLabel(label){
    const raw = String(label||'');
    if(!/^wood picket/i.test(raw)) return null;
    const match = raw.match(/wood picket \(([^,)]+)/i);
    const widthLabel = match ? normalizeLabelText(match[1]) : '';
    if(widthLabel){
      const key = `wood picket (${widthLabel})`;
      if(Object.prototype.hasOwnProperty.call(PRICE_MISC, key)){
        return PRICE_MISC[key] || 0;
      }
    }
    if(Object.prototype.hasOwnProperty.call(PRICE_MISC, 'wood picket')){
      return PRICE_MISC['wood picket'] || 0;
    }
    return null;
  }
  function woodRailUnitPriceFromLabel(label){
    const raw = String(label||'');
    if(!/^wood rail/i.test(raw)) return null;
    const match = raw.match(/wood rail \(([^,)]+)/i);
    const sizeLabel = match ? normalizeLabelText(match[1]) : '';
    if(sizeLabel){
      const key = `wood rail (${sizeLabel})`;
      if(Object.prototype.hasOwnProperty.call(PRICE_MISC, key)){
        return PRICE_MISC[key] || 0;
      }
    }
    if(Object.prototype.hasOwnProperty.call(PRICE_MISC, 'wood rail')){
      return PRICE_MISC['wood rail'] || 0;
    }
    return null;
  }
  function woodBoardUnitPriceFromLabel(label){
    const raw = String(label||'');
    const match = raw.match(/^wood\s+(top cap|trim|kick board)\s*\(([^)]+)\)/i);
    if(!match) return null;
    const sizeRaw = match[2] ? String(match[2]) : '';
    const sizeLabel = normalizeLabelText(sizeRaw.split(',')[0] || '');
    let unit = 0;
    if(Object.prototype.hasOwnProperty.call(WOOD_LINEAR_PRICES, sizeLabel)){
      unit = WOOD_LINEAR_PRICES[sizeLabel] || 0;
    } else {
      return 0;
    }
    const lengthMatch = raw.match(/(\d+(?:\.\d+)?)\s*(?:ft|feet|lf)\b/i);
    if(lengthMatch){
      const lengthFt = parseFloat(lengthMatch[1]) || 0;
      if(lengthFt > 0) unit *= lengthFt;
    }
    return unit;
  }
  function addMat(map, label, qty){
    if(!qty || qty <= 0) return;
    const cleanLabel = normalizeLabelText(label);
    map[cleanLabel] = (map[cleanLabel]||0) + qty;
  }

  function normalizeSize(txt){
    return String(txt||'')
      .replace(/\\u201D|”/g,'"')
      .replace(/\\u201C|“/g,'"')
      .replace(/\\u00BC|¼/g,'1/4')
      .replace(/\\u00BD|½/g,'1/2')
      .replace(/\\u00BE|¾/g,'3/4')
      .replace(/×/g,'x')
      .trim();
  }
  function isPanelPuppyInsertStyle(style){
    return /Puppy Picket Insert/i.test(style || '');
  }
  function normalizePuppyInsertSize(size){
    const normalized = normalizeSize(size);
    return PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
  }

  function puppyPicketDetailLabel(size, height){
    const normalizedSize = normalizeSize(size);
    const sizeLabel = normalizedSize || normalizeLabelText(size);
    const heightNum = parseInt(height||0,10) || 0;
    const heightLabel = heightNum > 0 ? `${heightNum} in` : '';
    if(sizeLabel && heightLabel) return `${sizeLabel} × ${heightLabel}`;
    return sizeLabel || (heightLabel ? `${heightLabel} tall` : '');
  }

  function snapshotForNotes(){
    const sections = JSON.parse(JSON.stringify(state.sections || []));
    return {
      version: NOTES_DATA_VERSION,
      generatedAt: new Date().toISOString(),
      state: { sections },
      map: serializeMapDrawing(),
      estimate: {
        number: lastEstimateLookupNumber || '',
        address: mapAddressInput ? (mapAddressInput.value || '').trim() : '',
      }
    };
  }

  function applySnapshotToState(payload){
    if(!payload || !payload.state || !Array.isArray(payload.state.sections)){
      throw new Error('No sections found in the embedded data');
    }
    clearMapDrawing({ skipSections: true });
    const nextSections = payload.state.sections.map(sec => createSectionBase(sec));
    if(!nextSections.length){
      throw new Error('No sections found in the embedded data');
    }

    state.sections = nextSections;

    const snapshotCustomerType = payload.state && payload.state.customerType ? normalizeCustomerType(payload.state.customerType) : '';
    if(snapshotCustomerType){
      if(customerTypeSelect){
        customerTypeSelect.value = snapshotCustomerType;
      }
      state.customerType = snapshotCustomerType;
    }else if(customerTypeSelect){
      state.customerType = normalizeCustomerType(customerTypeSelect.value);
    }
    updatePricingMinimumUI();
    setCustomerTypeConfirmed(false);

    const importAddress = (payload.map && payload.map.address) || (payload.estimate && payload.estimate.address) || '';
    if(mapAddressInput){
      mapAddressInput.value = importAddress || '';
      if(importAddress){
        focusMapOnAddress(importAddress);
      }
    }

    if(payload.map){
      restoreMapFromSnapshot(payload.map);
    }

    render();
    renderServiceLineNotes([]);
    generateNotes({ skipScroll: true });
  }

  const PRICE_FT = {
    '1/2\"': 0.57,
    '5/8\"': 0.68,
    '3/4\"': 0.74,
    '1\"':   1.07,
    '1x2\"': 1.65,
    '1 1/2\"': 1.46,
    '1 1/4\"': 1.46,
    '1 3/4\"': 2.57,
    '2x2\"': 2.57,
    '3x3\"': 6.00,
    '4x4': 11.6441666667,
    '2\"': 2.57,
    '3\"': 6.00,
    'Flat Bar 1/4\" x 1\"': 0.58
  };

  const PRICE_MISC = {
    'Gravity Latch': 5,
    'Short Pool Latch': 80,
    'Tall Pool Latch': 90,
    'Single Lock Box': 5,
    'Double Lock Box': 10,
    'Pair of Door Hinges': 5,
    'Pair of Bat Wing Hinges': 5,
    'Pair of Auto Close Hinges': 50,
    'Wood 4x4 posts': 20,
    'Round Steel posts': 23.61,
    '12ft round steel posts': 31.82,
    'Postmaster posts': 50,
    'Dome cap post cap': 1.13,
    'Flat cap post cap': 1.13,
    'Simpson 1 piece ties': 1.81,
    'Simpson 2 piece ties': 1.81,
    'lag screws': 0.075,
    // NEW
    'replacement finial': 1.25,
    'puppy picket insert (1/2")': 62.59,
    'puppy picket insert (5/8")': 62.59,
    'picket plugs (1/2")': 0.10,
    'picket plugs (5/8")': 0.11,
    'prefab gate panel': 0,
    'LiftMaster drive gate operator': 2000,
    [DRIVE_GATE_OPERATOR_DETAILS['Single Swing'].label]: DRIVE_GATE_OPERATOR_DETAILS['Single Swing'].unitCost,
    [DRIVE_GATE_OPERATOR_DETAILS['Double Swing'].label]: DRIVE_GATE_OPERATOR_DETAILS['Double Swing'].unitCost,
    [DRIVE_GATE_OPERATOR_DETAILS['Sliding'].label]: DRIVE_GATE_OPERATOR_DETAILS['Sliding'].unitCost,
    'Drive gate power run (new wiring)': 2000,
    'Solar gate power kit': 500,
    'Sliding drive gate chain': 150,
    'panel mount bracket': 1.27,
    '5 gal wood stain bucket': 124.49,
    'wood picket': 3.0,
    'wood picket (3.5")': 2.5,
    'wood picket (4")': 2.75,
    'wood picket (5.5")': 3.25,
    'wood picket (6")': 3.5,
    'wood rail (2x3, Pressure Treated)': 3.23,
    'wood rail (2x4, Cedar)': 9.33,
    'wood rail (2x4, Stained Cedar)': 10.81,
    'wood rail (2x3)': 0,
    'wood rail (2x4)': 0,
    'wood rail': 0
  };

  const WOOD_LINEAR_PRICES = {
    // Per-linear-foot pricing for wood detail boards (override as needed).
    '2x6': 0,
    '2x8': 0,
    '2x10': 0,
    '2x12': 0,
    '1x4': 0,
    '1x2': 0
  };

  const PRICE = {
    paintGallon: 50,
    paintCan: 8,
    primerGallon: 50,
    primerCan: 8,
    concrete: 12,
    post2x2: { 8:18, 9:24 }
  };
  function money(n){ return Number(n||0).toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }
  function parseCurrencyInput(value){
    const cleaned = String(value || '').replace(/,/g, '');
    const num = parseFloat(cleaned);
    return isFinite(num) ? num : NaN;
  }

  const PRICING = {
    grossProfitTargetPerHour: 100,
    grossProfitMinimumResidential: 350,
    grossProfitMinimumCommercial: 350,
    revenueMinimumCommercial: 2500
  };
  const MANUAL_TRAVEL_FLAT = 50;

  function normalizeCustomerType(value){
    const raw = String(value || '').trim();
    if(!raw) return CUSTOMER_TYPES[0];
    const match = CUSTOMER_TYPES.find(option => option.toLowerCase() === raw.toLowerCase());
    return match || CUSTOMER_TYPES[0];
  }

  function getCustomerType(){
    if(customerTypeSelect){
      return normalizeCustomerType(customerTypeSelect.value);
    }
    return normalizeCustomerType(state.customerType);
  }

  function getGrossProfitMinimum(){
    const type = getCustomerType();
    if(type === 'Commercial' || type === 'City'){
      return PRICING.grossProfitMinimumCommercial;
    }
    return PRICING.grossProfitMinimumResidential;
  }

  function getRevenueMinimum(){
    const type = getCustomerType();
    if(type === 'Commercial' || type === 'City'){
      return PRICING.revenueMinimumCommercial;
    }
    return null;
  }

  function getMinimumLabelAndValue(){
    const revenueMin = getRevenueMinimum();
    if(isFinite(revenueMin) && revenueMin > 0){
      return { label: 'Minimum charge', value: revenueMin };
    }
    return { label: 'Minimum gross', value: getGrossProfitMinimum() };
  }

  function getMinimumSummaryText(){
    const minGross = getGrossProfitMinimum();
    const revenueMin = getRevenueMinimum();
    if(isFinite(revenueMin) && revenueMin > 0){
      return `$${money(minGross)} minimum gross, $${money(revenueMin)} minimum charge`;
    }
    return `$${money(minGross)} minimum gross`;
  }

  function updatePricingMinimumUI(){
    const minValue = getMinimumLabelAndValue();
    if(customerMinHint){
      customerMinHint.textContent = `${minValue.label}: $${money(minValue.value)}`;
    }
    updateManualQuote();
  }

  const RATES = {
    overhead:   0.30,
    commission: 0.25,
    // Combined overhead + MCOR flat rate
    mcor:       0.00
  };

  function computeTargetGross(hours, targetPerHour = PRICING.grossProfitTargetPerHour, minimum = getGrossProfitMinimum()){
    const h = Number(hours);
    const rate = Number(targetPerHour);
    if(!isFinite(h) || h <= 0) return NaN;
    if(!isFinite(rate) || rate < 0) return NaN;
    const minValue = (isFinite(minimum) && minimum >= 0)
      ? Number(minimum)
      : PRICING.grossProfitMinimumResidential;
    return Math.max(h * rate, minValue);
  }

  function computeChargeRevenue(directCosts, totalHours){
    const cost = Number(directCosts);
    const hours = Number(totalHours);
    if(!isFinite(cost) || cost < 0) return { revenue: NaN, mode: 'invalid' };
    if(!isFinite(hours) || hours <= 0) return { revenue: NaN, mode: 'invalid-hours' };
    const denom = 1 - RATES.overhead;
    if(denom <= 0) return { revenue: NaN, mode: 'invalid' };

    let targetGross = computeTargetGross(hours);
    let revenue = (cost + targetGross) / denom;
    const revenueMinimum = getRevenueMinimum();
    if(isFinite(revenueMinimum) && revenueMinimum > 0 && revenue < revenueMinimum){
      revenue = revenueMinimum;
      const minTargetGross = (revenue * denom) - cost;
      if(isFinite(minTargetGross)){
        targetGross = Math.max(targetGross, minTargetGross);
      }
    }
    return { revenue, mode: 'gross-per-hour', targetGross, hours, revenueMinimum };
  }

  function setManualModal(open){
    if(!manualModal) return;
    manualModal.setAttribute('aria-hidden', open ? 'false' : 'true');
    manualModal.classList.toggle('is-open', !!open);

    if(open && manualCostInput){
      manualCostInput.focus();
      if(typeof manualCostInput.select === 'function'){
        manualCostInput.select();
      }
    }
  }

  function setImportModal(open){
    if(!importModal) return;
    importModal.setAttribute('aria-hidden', open ? 'false' : 'true');
    importModal.classList.toggle('is-open', !!open);

    if(open && importTextEl){
      importTextEl.focus();
      if(typeof importTextEl.select === 'function'){
        importTextEl.select();
      }
    }
  }

  function clearManualMetrics(){
    if(manualGrossOutput) manualGrossOutput.textContent = '';
    if(manualGrossHourOutput) manualGrossHourOutput.textContent = '';
    if(manualCommissionOutput) manualCommissionOutput.textContent = '';
    if(manualNetOutput) manualNetOutput.textContent = '';
  }

  function updateManualQuote(){
    if(!manualCostInput || !manualChargeOutput || !manualStatusEl || !manualModeChip) return;

    const minimumSummary = getMinimumSummaryText();
    const raw = (manualCostInput.value || '').trim();
    if(!raw){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = '';
      delete manualStatusEl.dataset.state;
      clearManualMetrics();
      return;
    }

    const materialEquipmentCost = parseCurrencyInput(raw);
    if(!isFinite(materialEquipmentCost) || materialEquipmentCost < 0){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = 'Enter a valid non-negative cost amount.';
      manualStatusEl.dataset.state = 'error';
      clearManualMetrics();
      return;
    }

    const rawHours = manualHoursInput ? (manualHoursInput.value || '').trim() : '';
    const totalHours = parseFloat(rawHours);
    if(!isFinite(totalHours) || totalHours <= 0){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = '';
      manualStatusEl.dataset.state = 'error';
      clearManualMetrics();
      return;
    }

    const laborCost = totalHours * LABOR_RATE;
    const travelCost = MANUAL_TRAVEL_FLAT;
    const totalCost = materialEquipmentCost + laborCost + travelCost;
    const pricing = computeChargeRevenue(totalCost, totalHours);
    if(!pricing || !isFinite(pricing.revenue)){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = 'Pricing inputs produced an invalid result. Check overhead and hours.';
      manualStatusEl.dataset.state = 'error';
      clearManualMetrics();
      return;
    }

    const revenue = pricing.revenue;
    manualChargeOutput.textContent = '$' + money(revenue);
    manualModeChip.textContent = 'Gross/hr target';
    manualModeChip.classList.remove('is-warn');
    manualModeChip.classList.add('is-info');
    manualModeChip.style.display = 'inline-block';
    manualStatusEl.textContent = '';
    manualStatusEl.dataset.state = 'success';

    const revenueExcludingMcor = revenue * (1 - RATES.mcor);
    const commissionValue = RATES.commission * (((1 - RATES.overhead) * revenueExcludingMcor) - totalCost);
    const grossProfit = revenue - totalCost - (revenue * RATES.overhead);
    const netProfit = grossProfit - commissionValue;

    if(manualGrossOutput) manualGrossOutput.textContent = '$' + money(grossProfit);
    if(manualCommissionOutput) manualCommissionOutput.textContent = '$' + money(commissionValue);
    if(manualNetOutput) manualNetOutput.textContent = '$' + money(netProfit);

    if(manualGrossHourOutput){
      if(isFinite(totalHours) && totalHours > 0){
        manualGrossHourOutput.textContent = '$' + money(grossProfit / totalHours);
      } else {
        manualGrossHourOutput.textContent = '';
      }
    }

  }

  async function generateNotes(eventOrOptions){
    let options = {};
    if(eventOrOptions && typeof eventOrOptions === 'object'){
      if('target' in eventOrOptions || 'currentTarget' in eventOrOptions){
        if(typeof eventOrOptions.preventDefault === 'function'){
          eventOrOptions.preventDefault();
        }
      }else{
        options = eventOrOptions;
      }
    }

    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
      autoGenerateTimer = null;
    }
    if(isGeneratingNotes){
      return;
    }
    isGeneratingNotes = true;

    const shouldScroll = !options.skipScroll;

    try{
      syncStateFromDOM();
      state.sections.forEach(s=>{ delete s._panelCalc; delete s._installCalc; delete s._woodPanelCalc; });

    // --- PANEL REPLACEMENT helpers ---
    const PANEL_PRICE = {
      // keyed as: `${feet}ft|p${psize}|style`
      // style key: 'base' for standard/extended (no finials); 'finials' when Extended Picket w/ Finials
      // puppy key: 'puppy' for Flat Top w/ Puppy Pickets
      'puppy': 111.37,
      '3|p1/2"|base': 59.91,
      '3|p5/8"|base': 59.91,
      '4|p1/2"|base': 64.48,
      '4|p5/8"|base': 72.11,
      '5|p1/2"|base': 66.39,
      '5|p5/8"|base': 66.39,
      '5|p1/2"|finials': 72.63,
      '5|p5/8"|finials': 91.75,
      '6|p1/2"|base': 76.35,
      '6|p5/8"|base': 91.13,
    };
    function feetFromHeightStr(h){ const m = String(h||'').match(/(\d+)/); return m? parseInt(m[1],10):0; }
    function pkey(feet, picketSize, style){
      if(/Puppy Pickets/i.test(style)){
        return 'puppy';
      }
      const ps = normalizeSize(picketSize);
      const p = (ps==='1/2"')? 'p1/2"' : (ps==='5/8"'? 'p5/8"' : `p${ps}`);
      const sKey = /Finials/i.test(style) ? 'finials' : 'base';
      return `${feet}|${p}|${sKey}`;
    }
    function collectPanelPuppyInsertInfo(list, fallbackSize){
      const sizes = new Map();
      let total = 0;
      if(!Array.isArray(list)) return { total, sizes };
      list.forEach(panel=>{
        if(!panel) return;
        const qty = parseInt(panel.qty,10) || 0;
        if(qty <= 0) return;
        if(!isPanelPuppyInsertStyle(panel.style)) return;
        const sizeLabel = normalizePuppyInsertSize(panel.picketSize || fallbackSize);
        total += qty;
        sizes.set(sizeLabel, (sizes.get(sizeLabel)||0) + qty);
      });
      return { total, sizes };
    }
    function isPrefabEligible(widthIn, railSize, picketSize){
      const rs = normalizeSize(railSize);
      const ps = normalizeSize(picketSize);
      return (parseInt(widthIn,10)||0) <= 96 && rs === '1"' && (ps==='1/2"' || ps==='5/8"');
    }
    function picketCountForWidth(widthIn, picketSize){
      const gap = 3 + 15/16; // 3.9375
      const ps = normalizeSize(picketSize);
      const widths = { '1/2"': 0.5, '5/8"': 0.625, '3/4"': 0.75, '1"': 1 };
      const pw = widths[ps] || 0.5;
      const stride = pw + gap/12; // inches to feet then combine? keep inches to avoid rounding
      // Work fully in inches
      const strideIn = (pw*1) * 1.0 + 3.9375; // picket width inches + gap inches
      return Math.max(1, Math.floor( (parseFloat(widthIn)||0 + 3.9375) / strideIn ));
    }
    const roundTo = (value, decimals = 1)=>{
      const factor = Math.pow(10, decimals);
      return Math.round((Number(value) || 0) * factor) / factor;
    };
    function parseWoodInches(value, fallback){
      const match = String(value||'').match(/(\d+(\.\d+)?)/);
      const num = match ? parseFloat(match[1]) : NaN;
      if(isFinite(num) && num > 0) return num;
      const fb = parseFloat(fallback);
      return isFinite(fb) && fb > 0 ? fb : 0;
    }
    function woodRailsForHeight(heightFt){
      if(!isFinite(heightFt) || heightFt <= 0) return 3;
      return heightFt >= 8 ? 4 : 3;
    }
    function woodPicketCountForWidth(widthIn, picketWidthIn, isBoardOnBoard){
      const gapIn = 0.5; // estimated gap for side-by-side layout
      const width = parseFloat(widthIn) || 0;
      const picket = parseFloat(picketWidthIn) || 0;
      if(width <= 0 || picket <= 0) return 0;
      const base = Math.max(1, Math.ceil((width + gapIn) / (picket + gapIn)));
      return isBoardOnBoard ? base * 2 : base;
    }
    function splitWoodTrimSizes(trimType){
      const raw = normalizeLabelText(trimType || '');
      if(!raw) return [];
      if(raw.includes('&')){
        return raw.split('&').map(part=> normalizeLabelText(part)).filter(Boolean);
      }
      return [raw];
    }
    function calcWoodPanelReplacement(section, panelCount){
      const panels = parseInt(panelCount||0,10) || 0;
      if(!section || panels <= 0) return null;
      const widthFtRaw = parseFloat(section.woodRepairPanelWidth||0) || 0;
      const widthFt = roundTo(widthFtRaw > 0 ? widthFtRaw : 8, 2);
      const widthIn = widthFt * 12;
      const picketWidthIn = parseWoodInches(section.woodPicketWidth, 5.5);
      const isBoardOnBoard = /board on board/i.test(section.woodStyle || '');
      const picketsPerPanel = woodPicketCountForWidth(widthIn, picketWidthIn, isBoardOnBoard);
      const totalPickets = picketsPerPanel * panels;
      const heightFt = Math.max(0, feetFromStr(section.woodHeight || section.height));
      const railsPerPanel = woodRailsForHeight(heightFt);
      const totalRails = railsPerPanel * panels;
      const panelLf = roundTo(widthFt * panels, 2);
      const topCap = section.woodAddTopCap
        ? { size: section.woodTopCapSize || '2x6', lf: panelLf }
        : null;
      const trimSizes = section.woodAddTrim ? splitWoodTrimSizes(section.woodTrimType || 'Trim') : [];
      const trim = trimSizes.length ? { sizes: trimSizes, lf: panelLf } : null;
      const kickStack = parseInt(section.woodKickBoardStack||0,10) || 1;
      const kick = section.woodAddKickBoard
        ? { size: section.woodKickBoardSize || '2x6', stack: kickStack, lf: panelLf }
        : null;
      return {
        panels,
        widthFt,
        widthIn,
        panelLf,
        picketsPerPanel,
        totalPickets,
        railsPerPanel,
        totalRails,
        topCap,
        trim,
        kick
      };
    }

    const lines = [];
    const SERVICE_BUCKET_LABELS = {
      installation: 'Wrought Iron Installation',
      replacement: 'Wrought Iron Replacement',
      repairs: 'Wrought Iron Repairs',
      driveGateOperator: 'Drive Gate Operator Replacement',
      driveGateOperatorInstall: 'Drive Gate Operator Installation',
      slidingDriveGateRepairs: 'Sliding Drive Gate Repairs',
      painting: 'Wrought Iron Painting',
      railReplacement: 'Rail Replacement',
      woodRepairs: 'Wood Fence Repairs',
      woodStain: 'Wood Fence Staining'
    };
    const serviceBuckets = Object.keys(SERVICE_BUCKET_LABELS).reduce((acc, key)=>{
      acc[key] = [];
      return acc;
    }, {});
    const SERVICE_NAME_TO_BUCKET = {
      'Wrought Iron Fence Installation': 'installation',
      'Install New Fence Sections': 'installation',
      'Add Single Walk Gate': 'installation',
      'Add Double Walk Gate': 'installation',
      'Wrought Iron Fence Replacement': 'replacement',
      'Remove Fence Sections': 'replacement',
      'Surface Preparation & Painting': 'painting',
      'Dig Out Encroaching Soil': 'repairs',
      'Replace Damaged Pickets': 'repairs',
      'Rail Patch Repairs': 'repairs',
      'Full Rail Replacement': 'repairs',
      'Full Rail Gap Filler': 'repairs',
      'Replace Fence Posts': 'repairs',
      'Realign Leaning Posts': 'repairs',
      'Finial Replacement': 'repairs',
      'Post Cap Replacement': 'repairs',
      'Install Prefab Panels': 'repairs',
      'Build Custom Panels': 'repairs',
      'Realign Walk Gates': 'repairs',
      'Replace Walk Gate Hardware': 'repairs',
      'Rebuild Walk Gates': 'repairs',
      'Drive Gate Operator Replacement': 'driveGateOperator',
      'Drive Gate Operator Installation': 'driveGateOperatorInstall',
      'Sliding Drive Gate Repairs': 'slidingDriveGateRepairs',
      'Add Diagonal Braces': 'repairs',
      'Install Puppy Picket Inserts': 'repairs',
      'Rail Replacement': 'railReplacement',
      'Wood Fence Repairs': 'woodRepairs',
      'Wood Fence Staining': 'woodStain',
      'Wood Fence Wash & Stain': 'woodStain',
      'Wood Fence Wash Hail & Stain': 'woodStain'
    };
    function ensureSentence(text){
      const trimmed = (text || '').trim();
      if(!trimmed) return '';
      return /[.!?]$/.test(trimmed) ? trimmed : `${trimmed}.`;
    }
    function addServiceLine(name, desc){
      if(!name || !desc) return;
      const normalizedName = name.trim();
      const bucket = SERVICE_NAME_TO_BUCKET[normalizedName]
        || (normalizedName.includes('Paint') ? 'painting' : 'repairs');
      const sentence = ensureSentence(desc);
      if(!sentence) return;
      if(!serviceBuckets[bucket]){
        serviceBuckets[bucket] = [];
      }
      serviceBuckets[bucket].push(sentence);
    }
    function buildServiceLineOutput(){
      return Object.entries(SERVICE_BUCKET_LABELS)
        .map(([key, label])=>{
          const parts = serviceBuckets[key] || [];
          if(!parts.length) return null;
          let desc = parts.join(' ');
          if(key === 'repairs'){
            const disclaimer = 'The repairs listed are based on what was identified at the time of this estimate. Additional repairs may be required that were not visible or discoverable during inspection. If our crew identifies any additional issues on site, we will notify you for approval prior to proceeding, and any extra work will be billed at an additional cost.';
            desc = desc ? `${desc}\n\n${disclaimer}` : disclaimer;
          }
          return { name: label, desc };
        })
        .filter(Boolean);
    }
    function describeCount(count, singular, plural){
      const n = parseInt(count,10) || 0;
      if(n <= 0) return '';
      const label = n === 1 ? singular : (plural || singular + 's');
      return `${n} ${label}`;
    }
    function summarizeWalkHardware(sections){
      const comboCounts = new Map();
      let total = 0;
      sections.forEach(sec=>{
        const count = parseInt(sec?.walkGatesHardware||0,10) || 0;
        if(count <= 0) return;
        total += count;
        const latch = (sec?.walkLatch || '').trim();
        const hinges = (sec?.walkHinges || '').trim();
        const key = `${latch}|||${hinges}`;
        comboCounts.set(key, (comboCounts.get(key)||0) + count);
      });
      const details = [];
      comboCounts.forEach((count, key)=>{
        const [latch, hinges] = key.split('|||');
        const labels = [latch, hinges].filter(Boolean).join(' + ') || 'hardware';
        const gateLabel = describeCount(count, 'gate', 'gates');
        details.push(`${labels}: ${gateLabel}`);
      });
      return { total, details };
    }
    function fenceTypeLabel(type){
      const normalized = String(type||'').toLowerCase();
      if(normalized === 'wood') return 'Wood';
      if(normalized === 'chain link') return 'Chain Link';
      if(normalized === 'vinyl') return 'Vinyl';
      return 'Wrought Iron';
    }
    function fenceTypeDefaultDetail(type, includeRemoval){
      const actionPrefix = includeRemoval ? 'Remove existing fence and install new' : 'Install';
      const label = fenceTypeLabel(type);
      return `${actionPrefix} ${label.toLowerCase()} fence. Posts will be set in concrete 36\" deep.`;
    }
    function groupSectionsByFenceType(sections){
      const map = new Map();
      sections.forEach(sec=>{
        const type = (sec?.fenceType || 'Wrought Iron').toLowerCase();
        if(!map.has(type)) map.set(type, []);
        map.get(type).push(sec);
      });
      return map;
    }
    function joinParts(parts){
      const clean = parts.filter(Boolean);
      if(clean.length === 0) return '';
      if(clean.length === 1) return clean[0];
      if(clean.length === 2) return `${clean[0]} and ${clean[1]}`;
      return `${clean.slice(0,-1).join(', ')}, and ${clean[clean.length-1]}`;
    }
    function formatPrefabPanelType(info){
      const styleLabel = normalizeLabelText(info?.style || '') || 'Prefab';
      const railLabel = normalizeSize(info?.rail || '');
      const picketLabel = normalizeSize(info?.picket || '');
      const sizeParts = [];
      if(railLabel) sizeParts.push(`${railLabel} rails`);
      if(picketLabel) sizeParts.push(`${picketLabel} pickets`);
      const sizeText = sizeParts.length ? joinParts(sizeParts) : '';
      return [styleLabel, sizeText].filter(Boolean).join(' ').trim() || 'prefab panel';
    }
    function summarizePrefabPanelTypes(map){
      if(!map || typeof map.forEach !== 'function' || map.size === 0) return '';
      const parts = [];
      map.forEach(info=>{
        const count = parseInt(info?.count,10) || 0;
        if(count <= 0) return;
        const typeLabel = formatPrefabPanelType(info);
        parts.push(`${count} × ${typeLabel}`);
      });
      return parts.join('; ');
    }
    function formatFtValue(value){
      const n = parseFloat(value);
      if(!isFinite(n) || n <= 0) return '';
      return n
        .toFixed(2)
        .replace(/(\.\d*?)0+$/,'$1')
        .replace(/\.$/,'');
    }
    function buildInstallServiceDescription(sections, includeRemoval){
      if(!Array.isArray(sections) || !sections.length) return '';
      const fenceType = (sections[0]?.fenceType || 'Wrought Iron').toLowerCase();
      const isWood = fenceType === 'wood';
      let totalLength = 0;
      const heights = new Set();
      const styles = new Set();
      const rails = new Set();
      const railSizes = new Set();
      const spacing = new Set();
      const postSizes = new Set();
      const styleGroups = new Map();

      sections.forEach(section=>{
        const len = parseInt(section.length,10) || 0;
        totalLength += len;
        const sectionHeight = isWood ? section.woodHeight : section.height;
        const sectionStyle = isWood ? section.woodStyle : section.style;
        if(sectionHeight){ heights.add(String(sectionHeight).trim()); }
        if(sectionStyle){ styles.add(String(sectionStyle).trim()); }
        const groupKey = (()=>{
          const height = sectionHeight ? String(sectionHeight).trim() : '';
          const style = sectionStyle ? String(sectionStyle).trim() : '';
          return JSON.stringify({ height, style });
        })();
        if(!styleGroups.has(groupKey)){
          styleGroups.set(groupKey, {
            length: 0,
            height: sectionHeight ? String(sectionHeight).trim() : '',
            style: sectionStyle ? String(sectionStyle).trim() : '',
            postSizes: new Set(),
            picketSizes: new Set(),
            railSizes: new Set()
          });
        }
        const group = styleGroups.get(groupKey);
        if(len > 0){
          group.length += len;
        }
        const rCount = parseInt(section.railsCount,10) || (Array.isArray(section.rails) ? section.rails.length : 0);
        if(rCount > 0){ rails.add(`${rCount} rail${rCount === 1 ? '' : 's'}`); }
        if(Array.isArray(section.rails) && section.rails.length){
          section.rails.forEach(r=>{
            if(r && r.size){
              const normalized = normalizeSize(r.size);
              railSizes.add(normalized);
              group.railSizes.add(normalized);
            }
            if(r && r.stacked && r.size2){
              const normalized = normalizeSize(r.size2);
              railSizes.add(normalized);
              group.railSizes.add(normalized);
            }
          });
        } else if(section.railSize){
          const normalized = normalizeSize(section.railSize);
          railSizes.add(normalized);
          group.railSizes.add(normalized);
          if(section.railStacked && section.railSize2){
            const normalizedStack = normalizeSize(section.railSize2);
            railSizes.add(normalizedStack);
            group.railSizes.add(normalizedStack);
          }
        } else if(isWood && section.woodRailSize){
          const normalized = normalizeSize(section.woodRailSize);
          railSizes.add(normalized);
          group.railSizes.add(normalized);
        }
        const postSizeVal = isWood ? section.woodPost : section.postSize;
        if(postSizeVal){
          const normalized = normalizeSize(postSizeVal);
          postSizes.add(normalized);
          group.postSizes.add(normalized);
        }
        if(isWood){
          if(section.woodPicketWidth){
            group.picketSizes.add(normalizeSize(section.woodPicketWidth));
          }
        } else if(section.picketSize){
          group.picketSizes.add(normalizeSize(section.picketSize));
        }
        const spacingCandidate = (section._installCalc && section._installCalc.spacingFt) || parseFloat(section.postSpacing||'');
        const spacingStr = formatFtValue(spacingCandidate);
        if(spacingStr){ spacing.add(spacingStr); }
      });

      const descriptorParts = [];
      if(heights.size){
        const heightLabel = joinParts(Array.from(heights).map(h=> `${h} tall`));
        descriptorParts.push(heightLabel);
      }
      const fenceLabel = isWood ? 'wood fence' : 'wrought iron fence';
      const styleLabel = styles.size ? `${joinParts(Array.from(styles))} fence` : fenceLabel;
      descriptorParts.push(styleLabel);
      const descriptor = descriptorParts.filter(Boolean).join(' ').trim();

      const withParts = [];
      if(rails.size){ withParts.push(joinParts(Array.from(rails))); }
      const withText = withParts.length ? ` with ${joinParts(withParts)}` : '';
      const actionPrefix = includeRemoval ? 'Remove existing fence and install' : 'Install';
      const breakdownParts = Array.from(styleGroups.values())
        .filter(item=>item.length > 0)
        .map(item=>{
          const heightLabel = item.height ? `${item.height} tall` : '';
          const styleLabel = item.style || (isWood ? 'wood' : 'wrought iron');
          const phraseParts = [heightLabel, `${styleLabel}${/fence/i.test(styleLabel)?'':' fence'}`].filter(Boolean);
          const postDetail = item.postSizes.size ? `posts: ${joinParts(Array.from(item.postSizes))}` : '';
          const picketDetail = item.picketSizes.size ? `pickets: ${joinParts(Array.from(item.picketSizes))}` : '';
          const railDetail = item.railSizes.size ? `rails: ${joinParts(Array.from(item.railSizes).map(v=> `${v}`))}` : '';
          const detailParts = [postDetail, picketDetail, railDetail].filter(Boolean);
          const detailText = detailParts.length ? ` (${detailParts.join('; ')})` : '';
          return `${item.length}ft of ${phraseParts.join(' ')}${detailText}`;
        });
      let firstSentence = '';
      if(breakdownParts.length){
        firstSentence = `${actionPrefix} ${joinParts(breakdownParts)}${withText}.`;
      } else {
        const lengthText = totalLength > 0 ? `${totalLength}ft` : '';
        firstSentence = lengthText
          ? `${actionPrefix} ${lengthText} of ${descriptor}${withText}.`
          : `${actionPrefix} ${descriptor}${withText}.`;
      }

      const spacingValues = Array.from(spacing).sort((a,b)=> parseFloat(a) - parseFloat(b));
      const railSizeValues = Array.from(railSizes).filter(Boolean);
      const postSizeValues = Array.from(postSizes).filter(Boolean);
      let postsSentence = '';
      const postSizeLabel = postSizeValues.length ? ` (${joinParts(postSizeValues)})` : '';
      if(spacingValues.length){
        if(spacingValues.length === 1){
          postsSentence = `Posts${postSizeLabel} will be spaced ${spacingValues[0]}ft apart and set in concrete 36\" deep.`;
        } else {
          const spacingLabels = spacingValues.map(v=> `${v}ft`);
          postsSentence = `Posts${postSizeLabel} will be spaced between ${joinParts(spacingLabels)} apart and set in concrete 36\" deep.`;
        }
      } else {
        postsSentence = `Posts${postSizeLabel} will be set in concrete 36\" deep.`;
      }

      let railSentence = '';
      if(railSizeValues.length){
        railSentence = `Rails will use ${joinParts(railSizeValues)}.`;
      }

      return [firstSentence, postsSentence, railSentence].filter(Boolean).join(' ');
    }
    const zeroPostCounts = ()=>({ posts1p5:0, posts2x2:0, posts3x3:0, posts4x4:0 });
    const countWoodRealignMethods = (entries=[])=>{
      return entries.reduce((acc, item)=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        const method = String(item?.method||'').toLowerCase();
        if(method === 'cut-weld'){
          acc.cutWeld += qty;
        } else {
          acc.dig += qty;
        }
        return acc;
      }, { dig: 0, cutWeld: 0 });
    };
    const zeroWoodMethodCounts = ()=>({ 'drive-posts': 0, 'dig-set-concrete': 0 });
    const addWoodMethodCount = (bucket, method, count)=>{
      if(!bucket) return;
      const qty = parseInt(count, 10) || 0;
      if(qty <= 0) return;
      const normalized = String(method || '').toLowerCase();
      const key = normalized === 'drive-posts' ? 'drive-posts' : 'dig-set-concrete';
      bucket[key] = (bucket[key] || 0) + qty;
    };
    const totals = {
      length:0, hardscape:0, trim:0, digOut:0, finials:0, caps:0,
      puppyInserts:0,
      diagonalBraces:0,
      wiPickets:0, wiPatches:0, wiRails:0, wiRailGaps:0, weldRedos:0,
      puppyPickets:0,
      wiPicketSizes: new Set(),
      wiPatchSizes: new Set(),
      wiRailReplaceSizes: new Set(),
      wiRailGapSizes: new Set(),
      diagonalBraceSizes: new Map(),
      puppyInsertSizes: new Map(),
      puppyPicketDetails: new Map(),
      woodPicketReplace:0, woodPicketInstall:0, woodRailReplace:0, woodRailInstall:0,
      woodPostReplace6:0, woodPostReplace8:0, woodPostRealignCutWeld:0, woodPostRealignDig:0,
      woodPostInstall:0, woodPanels:0, woodGateRepair:0, woodGateStrengthen:0, woodGateReplace:0,
      woodTopCapLf:0, woodTrimLf:0, woodKickLf:0, woodStainSqft:0,
      posts2x2:0, posts3x3:0, posts1p5:0, posts4x4:0, postsRealign2x2:0, postsRealign3x3:0, postsRealignCutWeld:0,
      retainingWallPosts: zeroPostCounts(),
      walkGates:0, walkRealign:0, walkHardware:0, walkRebuild:0,
      walkGateAdds:0,
      walkGateAddsSingle:0,
      walkGateAddsDouble:0,
      walkGateAddsRepair:0,
      walkGateAddsInstall:0,
      driveGateChainReplacements:0,
      driveGateOperators:0,
      driveGateOperatorTypes: new Map(),
      driveGateOperatorPowers: new Map(),
      driveGateOperatorCombos: new Map(),
      driveGateOperatorInstalls:0,
      driveGateOperatorInstallTypes: new Map(),
      driveGateOperatorInstallPowers: new Map(),
      driveGateOperatorInstallCombos: new Map(),
      driveGateOperatorInstallPlatforms:0,
      retainingWallSqft:0,
      retainingWallCost:0,
      panelsPrefab:0, panelsCustom:0,
      panelsInstallPrefab:0, panelsInstallCustom:0,
      prefabPanelTypesRepair: new Map(),
      installSections:0, replaceSections:0,
      removalLf:0, removalCost:0,
      postsInstall: zeroPostCounts(),
      postsReplace: zeroPostCounts(),
      woodPostInstallMethods: zeroWoodMethodCounts()
    };
    let hasWoodStaining = false;
    let hasWoodWashSelection = false;
    let hasWroughtRepair = false;
    const woodStainDetails = [];
    const woodWashDetails = [];
    const materials = {};
    const installCapsByLabel = new Map();
    const picketStickTotals = {};
    const railStickTotals = {};
    const steelStickTotals = { raw1p5:0, raw3x3:0, raw4x4:0 };
    const diagonalBraceFeetBySize = {};

    const addPicketSticks = (size, qty) => {
      if(!qty || qty <= 0) return;
      const normalized = normalizeSize(size);
      const labelSize = normalized || normalizeLabelText(size);
      addMat(materials, `12ft picket sticks (${labelSize})`, qty);
      if(normalized){
        picketStickTotals[normalized] = (picketStickTotals[normalized]||0) + qty;
      }
    };

    const addRailSticks = (size, qty) => {
      if(!qty || qty <= 0) return;
      const normalized = normalizeSize(size);
      const labelSize = normalized || normalizeLabelText(size);
      addMat(materials, `12ft rail sticks (${labelSize})`, qty);
      if(normalized){
        railStickTotals[normalized] = (railStickTotals[normalized]||0) + qty;
      }
    };
    let manHours = 0;
    let welderHours = 0;
    let helperHours = 0;
    let woodHelperHours = 0;
    let woodWelderHours = 0;
    let woodManHours = 0;
    let woodStainHours = 0;
    let woodWashHours = 0;
    let woodRequiresTwoPerson = false;
    const woodSectionSummaries = [];
    const parseWoodStainSelection = (value)=>{
      const raw = String(value || 'none').trim();
      if(!raw || raw === 'none'){
        return { side: 'none', wash: 'none' };
      }
      if(raw.startsWith('wash-hail-')){
        return { side: raw.replace('wash-hail-','') || 'both', wash: 'hail' };
      }
      if(raw.startsWith('wash-')){
        return { side: raw.replace('wash-','') || 'both', wash: 'standard' };
      }
      return { side: raw, wash: 'none' };
    };

    state.sections.forEach((s, idx)=>{
      const title  = s.label ? `Section ${idx+1} - ${s.label}` : `Section ${idx+1}`;
      const picket = s.picketHeight ? `${s.picketSize} (height ${s.picketHeight} in)` : `${s.picketSize}`;
      const puppyPicketDetail = puppyPicketDetailLabel(s.puppyPicketSize, s.puppyPicketHeight);
      const gapAdditionsArr = Array.isArray(s.gapAdditions) ? s.gapAdditions : [];
      const diagonalBracesArr = Array.isArray(s.diagonalBraces) ? s.diagonalBraces : [];
      const braceCountByLabel = new Map();
      let braceTotalQty = 0;
      diagonalBracesArr.forEach(item=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        if(!qty) return;
        braceTotalQty += qty;
        const rawSize = item?.size || '';
        const normalized = normalizeSize(rawSize);
        const label = normalized ? normalizeLabelText(normalized) : normalizeLabelText(rawSize) || rawSize || 'picket steel';
        const displayLabel = label || 'picket steel';
        braceCountByLabel.set(displayLabel, (braceCountByLabel.get(displayLabel)||0) + qty);
        if(normalized){
          const prevCount = totals.diagonalBraceSizes.get(normalized) || 0;
          totals.diagonalBraceSizes.set(normalized, prevCount + qty);
          diagonalBraceFeetBySize[normalized] = (diagonalBraceFeetBySize[normalized]||0) + qty * 4;
        }
      });
      if(braceTotalQty > 0){
        totals.diagonalBraces += braceTotalQty;
      }
      const braceLineParts = [];
      braceCountByLabel.forEach((qty,label)=>{ braceLineParts.push(`${qty} × ${label}`); });

      const scopeType = (s.scopeType || 'repair');
      const fenceType = (s.fenceType || '').toLowerCase();
      const isWood = fenceType === 'wood';
      const isWrought = fenceType === 'wrought iron';
      const railsDesc = isWood
        ? (s.woodRailSize || '-')
        : (Array.isArray(s.rails) && s.rails.length)
          ? (()=>{
              const labels = railLabels(s.railsCount || s.rails.length);
              return s.rails.slice(0, s.railsCount || s.rails.length).map((r,i)=>
                r && r.stacked
                  ? `${labels[i]}: ${r.size} + ${r.size2} (stacked)`
                  : `${labels[i]}: ${r.size}`
              ).join('; ');
            })()
          : (s.railStacked ? `${s.railSize} + ${s.railSize2} (stacked)` : `${s.railSize}`);
      const isInstall = scopeType === 'install' || scopeType === 'replace';
      const isRepair = !isInstall;
      if(isRepair && isWrought){
        hasWroughtRepair = true;
      }
      if(scopeType === 'install'){ totals.installSections += 1; }
      if(scopeType === 'replace'){ totals.replaceSections += 1; }

      let installInfo = null;
      if(isInstall){
        const lengthFt = parseInt(s.length||0,10) || 0;
        const spacingRaw = parseFloat(s.postSpacing||'8');
        const spacingFt = (isFinite(spacingRaw) && spacingRaw > 0) ? spacingRaw : 8;
        let spanCount = 0;
        if(lengthFt > 0){ spanCount = Math.max(1, Math.ceil(lengthFt / spacingFt)); }
        const postsTotal = spanCount > 0 ? spanCount + 1 : (lengthFt > 0 ? 2 : 0);
        const installCounts = zeroPostCounts();
        const pKey = postSizeKey(s.postSize);
        if(pKey){ installCounts[pKey] = postsTotal; }
        addPostCounts(totals.postsInstall, installCounts);
        addPostCounts(totals, installCounts);

        const panelWidths = [];
        if(spanCount > 0){
          const standardWidthIn = Math.max(12, Math.round(spacingFt * 12));
          for(let iPanel=0; iPanel<spanCount; iPanel++){
            if(iPanel === spanCount - 1){
              const consumed = spacingFt * (spanCount - 1);
              const remainingFt = lengthFt - consumed;
              const widthIn = Math.max(12, Math.round((remainingFt>0 ? remainingFt : spacingFt) * 12));
              panelWidths.push(widthIn);
            } else {
              panelWidths.push(standardWidthIn);
            }
          }
        }

        const finialStyle = allowInstallFinials(s.style, s.puppy)
          ? (s.installFinialStyle || SEED.finialStyles[0])
          : '';

        const gateAddsForInstall = parseInt(s.walkGatesAdd||0,10) || 0;
        const gatePostKey = postSizeKey(s.walkAddPostSize || s.postSize);
        if(gateAddsForInstall>0 && gatePostKey){
          installCounts[gatePostKey] = (installCounts[gatePostKey]||0) + gateAddsForInstall;
        }

        installInfo = {
          lengthFt,
          spacingFt,
          spanCount,
          postsTotal,
          postCounts: installCounts,
          panelWidths,
          attachment: s.panelAttachment || 'Welding',
          finialStyle,
          removalCost: 0
        };

        if(gateAddsForInstall>0){
          installInfo.postsTotal += gateAddsForInstall;
        }

        if(scopeType === 'replace' && lengthFt > 0){
          const removalCost = lengthFt * 3.9;
          installInfo.removalCost = removalCost;
          totals.removalLf += lengthFt;
          totals.removalCost += removalCost;
        }

        const autoCaps = [];
        const defaultCapStyle = (SEED.capStyles && SEED.capStyles[0]) || 'Pyramid';
        const defaultCapMaterial = (SEED.capMaterials && SEED.capMaterials[0]) || 'Cast Iron';
        Object.entries(installInfo.postCounts || {}).forEach(([postKey, count])=>{
          const qty = parseInt(count,10) || 0;
          if(qty <= 0) return;
          const postSizeLabel = postKeyToLabel(postKey) || (s.postSize || '2x2');
          const capLabel = `caps - ${defaultCapMaterial} - ${defaultCapStyle} (${postSizeLabel})`;
          addMat(materials, capLabel, qty);
          installCapsByLabel.set(capLabel, (installCapsByLabel.get(capLabel)||0) + qty);
          autoCaps.push({ count: qty, postSize: postSizeLabel, style: defaultCapStyle, material: defaultCapMaterial });
        });
        if(autoCaps.length){
          installInfo.autoCaps = autoCaps;
        }
      }

      if(isInstall && (fenceType === 'wrought iron' || fenceType === 'wood')){
        const wallLength = parseFloat(s.retainingWallLength || 0) || 0;
        const wallHeight = parseFloat(s.retainingWallHeight || 0) || 0;
        if(wallLength > 0 && wallHeight > 0){
          const wallPostCounts = zeroPostCounts();
          const wallPostKey = postSizeKey(s.postSize);
          if(wallPostKey){
            const wallSpanCount = Math.max(1, Math.ceil(wallLength / spacingFt));
            const wallPostsTotal = wallSpanCount > 0 ? wallSpanCount + 1 : 0;
            const maxPostsAvailable = postsTotal + gateAddsForInstall;
            const postsForWall = Math.min(maxPostsAvailable, wallPostsTotal);
            if(postsForWall > 0){
              wallPostCounts[wallPostKey] = postsForWall;
              addPostCounts(totals.retainingWallPosts, wallPostCounts);
            }
          }
          const wallSqft = wallLength * wallHeight;
          const wallCost = Math.max(wallSqft * 35, 1500);
          totals.retainingWallSqft += wallSqft;
          totals.retainingWallCost += wallCost;
        }
      }

      let sectionPatchTotal = 0;
      let sectionReplTotal = 0;
      let sectionGapTotal = 0;
      const sectionPatchSizes = new Set();
      const sectionReplSizes = new Set();
      const sectionGapSizes = new Set();
      const gapCountByLabel = new Map();
      if(isRepair){
        const railsArr = (s.rails||[]).slice(0, s.railsCount||0);
        railsArr.forEach(r=>{
          const patchCount = parseInt(r?.patches||0,10) || 0;
          const replCount = parseInt(r?.replacements||0,10) || 0;
          const primarySize = normalizeSize(r?.size);
          const secondarySize = r?.stacked ? normalizeSize(r?.size2) : '';
          if(patchCount){
            sectionPatchTotal += patchCount;
            if(primarySize) sectionPatchSizes.add(primarySize);
            if(secondarySize) sectionPatchSizes.add(secondarySize);
          }
          if(replCount){
            sectionReplTotal += replCount;
            if(primarySize) sectionReplSizes.add(primarySize);
            if(secondarySize) sectionReplSizes.add(secondarySize);
          }
        });
        gapAdditionsArr.forEach(item=>{
          const qty = parseInt(item?.qty||0,10) || 0;
          if(!qty) return;
          sectionGapTotal += qty;
          const rawSize = item?.size || '';
          const normalized = normalizeSize(rawSize);
          if(normalized) sectionGapSizes.add(normalized);
          const label = normalized ? normalizeLabelText(normalized) : normalizeLabelText(rawSize) || rawSize || 'matching rail material';
          const displayLabel = label || 'matching rail material';
          gapCountByLabel.set(displayLabel, (gapCountByLabel.get(displayLabel)||0) + qty);
        });
      }

      lines.push(`${title}`);
      const scopeLabel = scopeType === 'install'
        ? 'Install new section'
        : scopeType === 'replace'
          ? 'Remove & replace section'
          : 'Repair existing section';
      lines.push(`- Scope: ${scopeLabel}`);
      const woodFinish = s.woodFinish || 'None';
      const woodStyle = s.woodStyle || '';
      const woodHeight = s.woodHeight || s.height;
      const woodPostLabel = (post)=>{
        if(!post) return '-';
        if(/round steel/i.test(post)) return 'Round Steel (2 3/8\")';
        return post;
      };

      const skipStyleDetails = isWood && isRepair;
      if(!skipStyleDetails){
        lines.push(`- Style: ${isWood ? woodStyle : s.style}`);
        lines.push(`- Height: ${isWood ? woodHeight : s.height}`);
        lines.push(`- Rails: ${railsDesc}`);
        lines.push(`- Picket: ${isWood ? (s.woodPicketWidth || '-') : picket}`);
        lines.push(`- Puppy Pickets: ${isWood ? 'N/A' : s.puppy}`);
        if(isWood){
          const woodPosts = woodPostLabel(s.woodPost);
          lines.push(`- Wood type: ${s.woodType || 'Cedar'}`);
          lines.push(`- Finish: ${woodFinish}`);
          lines.push(`- Posts: ${woodPosts}`);
          const woodAddOns = [];
          if(s.woodAddKickBoard){
            const stackLabel = s.woodKickBoardStack ? `${s.woodKickBoardStack}×` : '';
            const sizeLabel = s.woodKickBoardSize || '2x6';
            woodAddOns.push(`Kick board (${stackLabel}${sizeLabel})`);
          }
          if(s.woodAddTopCap){
            const sizeLabel = s.woodTopCapSize || '2x6';
            woodAddOns.push(`Top cap (${sizeLabel})`);
          }
          if(s.woodAddTrim){
            const trimLabel = s.woodTrimType || 'Trim';
            woodAddOns.push(`Trim (${trimLabel})`);
          }
          if(woodAddOns.length){
            lines.push(`- Wood add-ons: ${woodAddOns.join('; ')}`);
          }
          const woodSummaryParts = [
            `Style: ${woodStyle || '-'}`,
            `Height: ${woodHeight || '-'}`,
            `Picket: ${s.woodPicketWidth || '-'}`,
            `Rails: ${railsDesc}`,
            `Wood type: ${s.woodType || 'Cedar'}`,
            `Finish: ${woodFinish}`,
            `Posts: ${woodPosts}`,
            woodAddOns.length ? `Add-ons: ${woodAddOns.join('; ')}` : ''
          ].filter(Boolean);
          woodSectionSummaries.push(`- ${title}: ${woodSummaryParts.join('; ')}`);
        } else {
          const attachmentMethod = s.panelAttachment || (installInfo && installInfo.attachment) || 'Welding';
          const paintingDefault = s.painting || 'Paint Section';
          const paintingLabel = (scopeType === 'install' && attachmentMethod === 'Brackets')
            ? 'None'
            : paintingDefault;
          lines.push(`- Painting: ${paintingLabel}`);
          if(paintingLabel === 'Paint Section' || paintingLabel === 'Prime and Paint'){
            const application = s.paintingApplication || 'By Hand';
            lines.push(`- Paint application: ${application}`);
            if(paintingLabel === 'Paint Section' && s.paintingPrepExtra){
              lines.push('- Prep needs: More than usual prep');
            }
          }
        }
      }
      const braceLine = braceLineParts.length ? `- Diagonal brace additions: ${braceLineParts.join('; ')} (4 ft each)` : '';
      if(braceLine && !isRepair){
        lines.push(braceLine);
      }

      if(isInstall && installInfo){
        lines.push(`- Post spacing: ${installInfo.spacingFt} ft`);
        lines.push(`- Panel attachment: ${installInfo.attachment}`);
        lines.push(`- Posts to set: ${installInfo.postsTotal} (${s.postSize})`);
        if(installInfo.finialStyle){
          lines.push(`- Finials: ${installInfo.finialStyle}`);
        }
        if(Array.isArray(installInfo.autoCaps) && installInfo.autoCaps.length){
          const capParts = installInfo.autoCaps.map(cap=>`${cap.count} × ${cap.material} ${cap.style} (${cap.postSize})`);
          lines.push(`- Post caps: ${capParts.join('; ')}`);
        }
        if(scopeType === 'replace' && installInfo.lengthFt > 0){
          lines.push(`- Remove existing section (${installInfo.lengthFt} lf) and haul away (sub paid $${money(installInfo.removalCost)})`);
        }
      }

      lines.push(`- Length: ${numOrDash(s.length)} ft`);
      if (s.hardscape > 0) lines.push(`- Over hardscape: ${s.hardscape} lf`);
      if (s.trim > 0)      lines.push(`- Trim: ${s.trim} lf`);
      if (!isInstall && s.digOut > 0)    lines.push(`- Dig out: ${s.digOut} lf`);

      const i = (v)=> (parseInt(v||0,10) || 0);
      let picketReplaceCount = 0;
      let weldRedoCount = 0;
      let puppyPicketReplaceCount = 0;
      let replaceCounts = zeroPostCounts();
      let realignCounts = zeroPostCounts();
      let realignCutWeld = 0;
      if(isRepair){
        const repairLines = [];
        if(isWood){
          picketReplaceCount = i(s.woodRepairPicketReplace);
          const picketInstallCount = i(s.woodRepairPicketInstall);
          const railReplaceCount = i(s.woodRepairRailReplace);
          const railInstallCount = i(s.woodRepairRailInstall);
          const postReplaceCount = i(s.woodRepairPostReplace);
          const woodRealignCounts = countWoodRealignMethods(s.woodPostRealignments);
          const postInstallCount = i(s.woodRepairPostInstall);
          const panelReplaceCount = i(s.woodRepairPanelReplace);
          const gateCount = i(s.woodRepairWalkGateCount);
          const topCapLf = i(s.woodRepairTopCapReplaceLf);
          const trimLf = i(s.woodRepairTrimReplaceLf);
          const kickLf = i(s.woodRepairKickReplaceLf);
          if(picketReplaceCount > 0) repairLines.push(`  - Pickets to replace: ${picketReplaceCount}`);
          if(picketInstallCount > 0) repairLines.push(`  - Pickets to install: ${picketInstallCount}`);
          if(railReplaceCount > 0) repairLines.push(`  - Rails to replace: ${railReplaceCount}`);
          if(railInstallCount > 0) repairLines.push(`  - Rails to install: ${railInstallCount}`);
          if(postReplaceCount > 0) repairLines.push(`  - Posts to replace: ${postReplaceCount}`);
          if(woodRealignCounts.dig > 0) repairLines.push(`  - Posts to realign (dig/straighten): ${woodRealignCounts.dig}`);
          if(woodRealignCounts.cutWeld > 0) repairLines.push(`  - Posts to realign (cut & weld): ${woodRealignCounts.cutWeld}`);
          if(postInstallCount > 0) repairLines.push(`  - Posts to install: ${postInstallCount}`);
          if(panelReplaceCount > 0){
            const panelCalc = s._woodPanelCalc || calcWoodPanelReplacement(s, panelReplaceCount);
            if(panelCalc) s._woodPanelCalc = panelCalc;
            repairLines.push(`  - Panels to replace: ${panelReplaceCount}`);
          }
          if(gateCount > 0) repairLines.push(`  - Walk gates to repair: ${gateCount}`);
          if(topCapLf > 0) repairLines.push(`  - Top cap to replace: ${topCapLf} lf`);
          if(trimLf > 0) repairLines.push(`  - Trim to replace: ${trimLf} lf`);
          if(kickLf > 0) repairLines.push(`  - Kick board to replace: ${kickLf} lf`);
        } else {
          picketReplaceCount = i(s.wiPickets);
          weldRedoCount = i(s.weldRedos);
          puppyPicketReplaceCount = hasPuppyPickets(s.puppy) ? i(s.puppyPicketReplace) : 0;
          replaceCounts = countPostGroups(s.postReplacements);
          realignCounts = countPostGroups(s.postRealignments);
          realignCutWeld = countRealignCutWeld(s.postRealignments);
          if(picketReplaceCount > 0) repairLines.push(`  - Pickets to replace: ${picketReplaceCount}`);
          if(puppyPicketReplaceCount > 0){
            const detailSuffix = puppyPicketDetail ? ` (${puppyPicketDetail})` : '';
            repairLines.push(`  - Puppy pickets to replace: ${puppyPicketReplaceCount}${detailSuffix}`);
          }
          if(weldRedoCount > 0) repairLines.push(`  - Weld redos: ${weldRedoCount}`);
          if(sectionPatchTotal > 0) repairLines.push(`  - Rail patches: ${sectionPatchTotal}`);
          if(sectionReplTotal > 0) repairLines.push(`  - Full rail replacements: ${sectionReplTotal}`);
          const gapLineParts = [];
          gapCountByLabel.forEach((qty,label)=>{ gapLineParts.push(`${qty} × ${label}`); });
          const gapSummary = (sectionGapTotal > 0 && gapLineParts.length)
            ? ` (${gapLineParts.join('; ')})`
            : '';
          if(sectionGapTotal > 0) repairLines.push(`  - Full rail gap fillers: ${sectionGapTotal}${gapSummary}`);
          if(replaceCounts.posts2x2 > 0) repairLines.push(`  - 2x2 posts to replace: ${replaceCounts.posts2x2}`);
          if(replaceCounts.posts3x3 > 0) repairLines.push(`  - 3x3 posts to replace: ${replaceCounts.posts3x3}`);
          if(replaceCounts.posts1p5 > 0) repairLines.push(`  - 1 1/2" x 1 1/2" posts to replace: ${replaceCounts.posts1p5}`);
          if(replaceCounts.posts4x4 > 0) repairLines.push(`  - 4x4 posts to replace: ${replaceCounts.posts4x4}`);
          if(realignCounts.posts2x2 > 0) repairLines.push(`  - 2x2 posts to realign: ${realignCounts.posts2x2}`);
          if(realignCounts.posts3x3 > 0) repairLines.push(`  - 3x3 posts to realign: ${realignCounts.posts3x3}`);
          if(realignCutWeld > 0){
            repairLines.push(`  - Posts to realign (cut & weld): ${realignCutWeld}`);
          }
          if(braceTotalQty > 0){
            const braceSummary = braceLineParts.length ? ` (${braceLineParts.join('; ')})` : '';
            repairLines.push(`  - Diagonal brace additions: ${braceTotalQty}${braceSummary}`);
          }
        }
        if(repairLines.length){
          lines.push(`- Repairs:`);
          repairLines.forEach(line=>lines.push(line));
        }
      }

      // NEW: Finials
      const finArr = isRepair && Array.isArray(s.finials) ? s.finials : [];
      const finCount = finArr.reduce((acc,f)=> acc + (parseInt(f?.qty||0,10) || 0), 0);
      if(finCount){
        lines.push(`- Finial replacements: ${finCount}`);
        finArr.forEach(f=>{
          const q = parseInt(f?.qty||0,10) || 0; if(!q) return;
          lines.push(`  - ${q} × ${f.material} ${f.style} on ${f.picketSize} pickets`);
        });
      }

      const panelPuppyInsertInfo = (!isWood && isRepair)
        ? collectPanelPuppyInsertInfo(s.panels, s.picketSize)
        : { total: 0, sizes: new Map() };
      const puppyInsertArr = isRepair && Array.isArray(s.puppyInserts) ? s.puppyInserts : [];
      const puppyInsertCount = puppyInsertArr.reduce((acc,item)=> acc + (parseInt(item?.qty||0,10) || 0), 0)
        + (panelPuppyInsertInfo.total || 0);
      if(puppyInsertCount){
        const insertSizeMap = new Map();
        puppyInsertArr.forEach(item=>{
          const qty = parseInt(item?.qty||0,10) || 0;
          if(!qty) return;
          const sizeLabel = normalizePuppyInsertSize(item?.picketSize);
          insertSizeMap.set(sizeLabel, (insertSizeMap.get(sizeLabel)||0) + qty);
        });
        panelPuppyInsertInfo.sizes.forEach((qty, sizeLabel)=>{
          if(!qty) return;
          insertSizeMap.set(sizeLabel, (insertSizeMap.get(sizeLabel)||0) + qty);
        });
        lines.push(`- Puppy picket inserts: ${puppyInsertCount}`);
        insertSizeMap.forEach((qty, sizeLabel)=>{
          lines.push(`  - ${qty} × ${sizeLabel} pickets (includes 25 plugs per insert)`);
        });
      }

      function processPanels(list, heading, source, extra={}){
        if(!Array.isArray(list) || list.length === 0) return;
        const prepared = [];
        const defaultRail = (Array.isArray(s.rails) && s.rails[0] && s.rails[0].size) || s.railSize || SEED.railSize[0];
        list.forEach(p=>{
          if(!p) return;
          const qty = parseInt(p.qty,10) || 0;
          if(qty <= 0) return;
          const widthRaw = parseInt(p.widthIn,10) || 0;
          const widthIn = Math.max(12, widthRaw);
          const railSize = p.railSize || defaultRail;
          const picketSize = p.picketSize || s.picketSize || SEED.picketSize[0];
          const height = p.height || s.height;
          let style = p.style || s.style || '';
          if(source === 'install' && extra.style){ style = extra.style; }
          const hasFinials = /Finials/i.test(style);
          const finialStyle = hasFinials
            ? (p.finialStyle || extra.finialStyle || SEED.finialStyles[0])
            : '';
          prepared.push({ qty, widthIn, railSize, picketSize, height, style, finialStyle });
        });
        if(!prepared.length) return;
        lines.push(heading);
        prepared.forEach(entry=>{
          const { qty, widthIn, railSize, picketSize, height, style, finialStyle } = entry;
          const feet = feetFromHeightStr(height);
          const eligible = isPrefabEligible(widthIn, railSize, picketSize);
          const hasFinials = /Finials/i.test(style);
          const finStyleLabel = hasFinials ? (finialStyle || SEED.finialStyles[0]) : '';
          const finialNote = hasFinials && finStyleLabel ? ` (finials: ${finStyleLabel})` : '';
          const desc = `${height}, ${style}${finialNote}, rails ${railSize}, pickets ${picketSize} ${eligible?'(prefab eligible)':'(build on site)'}`;
          lines.push(`  - ${qty} × ${widthIn}" wide panel — ${desc}`);
          const panelHours = eligible ? qty * 0.5 : qty * 1.5;
          manHours += panelHours;
          const attachment = (source === 'install') ? (extra.attachment || 'Welding') : 'Welding';
          const usesBrackets = attachment === 'Brackets';
          if(!usesBrackets){ welderHours += panelHours; }
          if(eligible){
            totals.panelsPrefab += qty;
            if(source === 'install') totals.panelsInstallPrefab += qty;
            if(source === 'repair' && !isWood){
              const styleLabel = normalizeLabelText(style);
              const railLabel = normalizeSize(railSize);
              const picketLabel = normalizeSize(picketSize);
              const key = JSON.stringify({
                style: styleLabel.toLowerCase(),
                rail: railLabel.toLowerCase(),
                picket: picketLabel.toLowerCase()
              });
              const prev = totals.prefabPanelTypesRepair.get(key) || { count: 0, style: styleLabel, rail: railLabel, picket: picketLabel };
              prev.count += qty;
              totals.prefabPanelTypesRepair.set(key, prev);
            }
          } else {
            totals.panelsCustom += qty;
            if(source === 'install') totals.panelsInstallCustom += qty;
          }
          if(!s._panelCalc) s._panelCalc = [];
          s._panelCalc.push({
            qty,
            feet,
            eligible,
            style,
            picketSize,
            railSize,
            height,
            widthIn,
            finialStyle,
            source,
            attachment
          });
          if(hasFinials){
            addMat(materials, `finials - Cast Iron - ${finStyleLabel} (${picketSize})`, qty*25);
          }
          if(source === 'install' && attachment === 'Brackets'){
            addMat(materials, 'panel mount bracket', qty * 4);
          }
        });
        if(source === 'install' && extra.installInfo){
          if(!extra.installInfo.panels) extra.installInfo.panels = [];
          prepared.forEach(entry=>{
            extra.installInfo.panels.push({ ...entry, attachment: extra.attachment || 'Welding' });
          });
        }
      }

      // PANEL REPLACEMENTS (per-row)
      const panelArr = isRepair && Array.isArray(s.panels) ? s.panels : [];
      processPanels(panelArr, '- Panel replacements:', 'repair');

      if(installInfo && installInfo.spanCount > 0){
        const widthCounts = {};
        installInfo.panelWidths.forEach(w=>{
          widthCounts[w] = (widthCounts[w]||0) + 1;
        });
        const installStyle = (()=>{
          let base = s.style || '';
          const puppyVal = s.puppy || '';
          if(/Finials/i.test(puppyVal) && !/Finials/i.test(base)){
            base = base ? `${base} (${puppyVal})` : puppyVal;
          }
          return base || s.style || '';
        })();
        const installPanels = Object.entries(widthCounts).map(([width, qty])=>({
          qty,
          widthIn: parseInt(width,10) || 0,
          height: s.height,
          style: installStyle,
          railSize: (Array.isArray(s.rails) && s.rails[0] && s.rails[0].size) || s.railSize || SEED.railSize[0],
          picketSize: s.picketSize,
          finialStyle: installInfo.finialStyle
        }));
        processPanels(installPanels, '- Panel installation:', 'install', {
          attachment: installInfo.attachment,
          finialStyle: installInfo.finialStyle,
          style: installStyle,
          installInfo
        });
      }

      // NEW: Caps
      const capArr = isRepair && Array.isArray(s.caps) ? s.caps : [];
      const capCount = capArr.reduce((acc,c)=> acc + (parseInt(c?.qty||0,10) || 0), 0);
      if(capCount){
        lines.push(`- Post cap replacements: ${capCount}`);
        capArr.forEach(c=>{
          const q = parseInt(c?.qty||0,10) || 0; if(!q) return;
          lines.push(`  - ${q} × ${c.material} ${c.style} caps for ${c.postSize} posts`);
        });
      }

      if(installInfo){
        s._installCalc = installInfo;
      }

      // Walk gate details
      const wg  = isRepair ? i(s.walkGates) : 0;
      const wgr = isRepair ? i(s.walkGatesRealign) : 0;
      const wgh = isRepair ? i(s.walkGatesHardware) : 0;
      const wgb = isRepair ? i(s.walkGatesRebuild) : 0;
      if (isRepair && (wg || wgr || wgh || wgb)){
        lines.push(`- Walk gates: ${wg}`);
        if (wgr) lines.push(`  - Realign: ${wgr}`);
        if (wgh) lines.push(`  - Hardware replacements: ${wgh} (Latch: ${s.walkLatch||'-'}, Hinges: ${s.walkHinges||'-'})`);
        if (wgb) lines.push(`  - Rebuild: ${wgb} (Frame: ${s.walkRebuildFrame}, Pickets: ${s.walkRebuildPicket}, Latch: ${s.walkRebuildLatch}, Hinges: ${s.walkRebuildHinges})`);
      }

      // Add walk gate into existing fence
      const wga = i(s.walkGatesAdd);
      if (wga){
        const gateTypeLabel = s.walkAddType || 'Single Swing Walk Gate';
        lines.push(`- Add walk gate(s): ${wga} — ${gateTypeLabel}`);
        lines.push(`  - Post: ${s.walkAddPostSize}; Frame: ${s.walkAddFrameSize}; Pickets: ${s.walkAddPicketSize}; Latch: ${s.walkAddLatch}; Hinges: ${s.walkAddHinges}`);
      }

      const driveGateChainReplace = isRepair ? i(s.driveGateChainReplace) : 0;
      if(driveGateChainReplace){
        lines.push(`- Sliding drive gate chains to replace: ${driveGateChainReplace}`);
        totals.driveGateChainReplacements += driveGateChainReplace;
        addMat(materials, 'Sliding drive gate chain', driveGateChainReplace);
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const qtySentence = driveGateChainReplace > 1 ? ` Quantity: ${driveGateChainReplace}.` : '';
        const desc = `${labelPrefix}Replace sliding drive gate chain.${qtySentence}`;
        addServiceLine('Sliding Drive Gate Repairs', desc);
      }

      // Drive gate operator replacement
      const dgo = i(s.driveGateOperatorReplace);
      if(dgo){
        const rawType = (s.driveGateOperatorType || DRIVE_GATE_OPERATOR_TYPES[0] || '').trim();
        const rawPower = (s.driveGateOperatorPower || DRIVE_GATE_POWER_TYPES[0] || '').trim();
        const typeLabel = rawType || DRIVE_GATE_OPERATOR_TYPES[0] || 'Drive';
        const powerLabel = rawPower || DRIVE_GATE_POWER_TYPES[0] || '';
        const operatorModel = getDriveGateOperatorLabel(typeLabel);
        const gateLabel = typeLabel === 'Drive'
          ? `drive gate${dgo===1?'':'s'}`
          : `${typeLabel} gate${dgo===1?'':'s'}`;
        lines.push(`- Drive gate operator replacement: ${dgo} — ${gateLabel}`);
        lines.push(`  - Operator: ${operatorModel}`);
        if(powerLabel){ lines.push(`  - Power: ${powerLabel}`); }
        totals.driveGateOperators += dgo;
        const prevTypeCount = totals.driveGateOperatorTypes.get(typeLabel) || 0;
        totals.driveGateOperatorTypes.set(typeLabel, prevTypeCount + dgo);
        if(powerLabel){
          const prevPowerCount = totals.driveGateOperatorPowers.get(powerLabel) || 0;
          totals.driveGateOperatorPowers.set(powerLabel, prevPowerCount + dgo);
        }
        const comboKey = `${typeLabel}|||${powerLabel}`;
        const prevCombo = totals.driveGateOperatorCombos.get(comboKey) || 0;
        totals.driveGateOperatorCombos.set(comboKey, prevCombo + dgo);
        addMat(materials, operatorModel, dgo);
        if(powerLabel === 'New Wiring'){
          addMat(materials, 'Drive gate power run (new wiring)', dgo);
        } else if(powerLabel === 'Solar'){
          addMat(materials, 'Solar gate power kit', dgo);
        }
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const operatorLabel = describeCount(dgo, operatorModel, `${operatorModel}s`);
        const powerSentence = powerLabel ? `Power: ${powerLabel}.` : '';
        let desc = `${labelPrefix}Replace ${operatorLabel} for ${gateLabel}. Include removal, haul away, and disposal of the old operator. ${powerSentence}`.trim();
        if(powerLabel === 'Existing Wiring'){
          desc += ' Price includes reuse of existing wiring currently connected to the gate operator. Existing wiring is assumed to be in good working condition. Any troubleshooting, repair, or replacement/rerouting of wiring (including new wire pulls/trenching/conduit) is not included and will be quoted as an additional service if required.';
        }
        addServiceLine('Drive Gate Operator Replacement', desc);
      }

      // Drive gate operator installation
      const dgi = i(s.driveGateOperatorInstall);
      if(dgi){
        const rawType = (s.driveGateOperatorInstallType || DRIVE_GATE_OPERATOR_TYPES[0] || '').trim();
        const rawPower = (s.driveGateOperatorInstallPower || DRIVE_GATE_POWER_TYPES_INSTALL[0] || '').trim();
        const typeLabel = rawType || DRIVE_GATE_OPERATOR_TYPES[0] || 'Drive';
        const powerLabel = rawPower || DRIVE_GATE_POWER_TYPES_INSTALL[0] || '';
        const platformNeeded = !!s.driveGateOperatorInstallPlatform;
        const operatorModel = getDriveGateOperatorLabel(typeLabel);
        const gateLabel = typeLabel === 'Drive'
          ? `drive gate${dgi===1?'':'s'}`
          : `${typeLabel} gate${dgi===1?'':'s'}`;
        lines.push(`- Drive gate operator installation: ${dgi} — ${gateLabel}`);
        lines.push(`  - Operator: ${operatorModel}`);
        if(powerLabel){ lines.push(`  - Power: ${powerLabel}`); }
        if(platformNeeded){ lines.push(`  - Platform: build operator platform`); }
        totals.driveGateOperatorInstalls += dgi;
        const prevTypeCount = totals.driveGateOperatorInstallTypes.get(typeLabel) || 0;
        totals.driveGateOperatorInstallTypes.set(typeLabel, prevTypeCount + dgi);
        if(powerLabel){
          const prevPowerCount = totals.driveGateOperatorInstallPowers.get(powerLabel) || 0;
          totals.driveGateOperatorInstallPowers.set(powerLabel, prevPowerCount + dgi);
        }
        const comboKey = `${typeLabel}|||${powerLabel}|||${platformNeeded ? 'platform' : 'no-platform'}`;
        const prevCombo = totals.driveGateOperatorInstallCombos.get(comboKey) || 0;
        totals.driveGateOperatorInstallCombos.set(comboKey, prevCombo + dgi);
        if(platformNeeded){
          totals.driveGateOperatorInstallPlatforms += dgi;
        }
        addMat(materials, operatorModel, dgi);
        if(powerLabel === 'New Wiring'){
          addMat(materials, 'Drive gate power run (new wiring)', dgi);
        } else if(powerLabel === 'Solar'){
          addMat(materials, 'Solar gate power kit', dgi);
        }
        if(platformNeeded){
          addRailSticks('2x2"', dgi);
          addMat(materials, 'Maximizer bags of concrete', dgi);
        }
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const operatorLabel = describeCount(dgi, operatorModel, `${operatorModel}s`);
        const powerSentence = powerLabel ? `Power: ${powerLabel}.` : '';
        const platformSentence = platformNeeded ? 'Include fabrication of a 2x2 steel operator platform set in concrete.' : '';
        const desc = `${labelPrefix}Install ${operatorLabel} for ${gateLabel}. ${powerSentence} ${platformSentence}`.trim();
        addServiceLine('Drive Gate Operator Installation', desc);
      }

      if(isInstall && (fenceType === 'wrought iron' || fenceType === 'wood')){
        const wallLength = parseFloat(s.retainingWallLength || 0) || 0;
        const wallHeight = parseFloat(s.retainingWallHeight || 0) || 0;
        if(wallLength > 0 && wallHeight > 0){
          lines.push(`- Retaining wall: ${wallLength}ft long × ${wallHeight}ft tall ($35/sq ft, $1,500 minimum). In-House 4 pours the wall only (includes wall materials & labor; post materials separate) and Jesus' crew installs the fence. Posts on the wall are set during the pour—no extra concrete bags needed.`);
        }
      }

      if (s.notes) lines.push(`- Notes: ${s.notes}`);
      lines.push('');

      totals.length       += i(s.length);
      totals.hardscape    += i(s.hardscape);
      totals.trim         += i(s.trim);
      if(isRepair){
        totals.digOut       += i(s.digOut);
        totals.finials      += finCount;
        totals.puppyInserts += puppyInsertCount;
        if(puppyInsertCount > 0){
          puppyInsertArr.forEach(item=>{
            const qty = parseInt(item?.qty||0,10) || 0;
            if(!qty) return;
            const sizeLabel = normalizePuppyInsertSize(item?.picketSize);
            totals.puppyInsertSizes.set(sizeLabel, (totals.puppyInsertSizes.get(sizeLabel)||0) + qty);
            addMat(materials, `puppy picket insert (${sizeLabel})`, qty);
            addMat(materials, `picket plugs (${sizeLabel})`, qty * 25);
          });
          panelPuppyInsertInfo.sizes.forEach((qty, sizeLabel)=>{
            if(!qty) return;
            totals.puppyInsertSizes.set(sizeLabel, (totals.puppyInsertSizes.get(sizeLabel)||0) + qty);
            addMat(materials, `puppy picket insert (${sizeLabel})`, qty);
            addMat(materials, `picket plugs (${sizeLabel})`, qty * 25);
          });
        }
        if(!isWood){
          totals.wiPickets    += picketReplaceCount;
          if(picketReplaceCount > 0){
            const picketSizeNormalized = normalizeSize(s.picketSize);
            if(picketSizeNormalized) totals.wiPicketSizes.add(picketSizeNormalized);
          }
          if(puppyPicketReplaceCount > 0){
            totals.puppyPickets += puppyPicketReplaceCount;
            const detailLabel = puppyPicketDetail || normalizeLabelText(s.puppyPicketSize || 'puppy picket');
            const labelKey = detailLabel || 'puppy picket';
            totals.puppyPicketDetails.set(labelKey, (totals.puppyPicketDetails.get(labelKey)||0) + puppyPicketReplaceCount);
          }
          totals.weldRedos    += weldRedoCount;
          totals.wiPatches    += sectionPatchTotal;
          if(sectionPatchTotal > 0){
            sectionPatchSizes.forEach(size=> totals.wiPatchSizes.add(size));
          }
          totals.wiRails      += sectionReplTotal;
          if(sectionReplTotal > 0){
            sectionReplSizes.forEach(size=> totals.wiRailReplaceSizes.add(size));
          }
          totals.wiRailGaps   += sectionGapTotal;
          if(sectionGapTotal > 0){
            sectionGapSizes.forEach(size=> totals.wiRailGapSizes.add(size));
          }
          addPostCounts(totals.postsReplace, replaceCounts);
          addPostCounts(totals, replaceCounts);
          totals.postsRealign2x2 += realignCounts.posts2x2;
          totals.postsRealign3x3 += realignCounts.posts3x3;
          totals.postsRealignCutWeld += realignCutWeld;
        }
        totals.walkGates   += wg;
        totals.walkRealign += wgr;
        totals.walkHardware+= wgh;
        totals.walkRebuild += wgb;
        totals.caps        += capCount;
      }
      totals.walkGateAdds += wga;
      if(isInstall){
        totals.walkGateAddsInstall += wga;
      } else {
        totals.walkGateAddsRepair += wga;
      }
      const gateTypeLabel = s.walkAddType || 'Single Swing Walk Gate';
      if(gateTypeLabel === 'Double Swing Gate'){
        totals.walkGateAddsDouble += wga;
      } else {
        totals.walkGateAddsSingle += wga;
      }
    });

    const walkHardwareSummary = summarizeWalkHardware(state.sections);
    const prefabReplacementCount = Math.max(0, totals.panelsPrefab - (totals.panelsInstallPrefab || 0));
    const prefabReplacementDetail = summarizePrefabPanelTypes(totals.prefabPanelTypesRepair);

    if (woodSectionSummaries.length){
      lines.push('WOOD SECTION DETAILS');
      woodSectionSummaries.forEach(line=> lines.push(line));
    }

    if (state.sections.length){
      const t = totals;
      lines.push(`TOTALS`);
      lines.push(`- Sections: ${state.sections.length}`);
      lines.push(`- Length: ${t.length} ft`);
      if (t.hardscape)     lines.push(`- Over hardscape: ${t.hardscape} lf`);
      if (t.trim)          lines.push(`- Trim: ${t.trim} lf`);
      if (t.digOut)        lines.push(`- Dig out: ${t.digOut} lf`);
      if (t.replaceSections) lines.push(`- Sections to replace: ${t.replaceSections}`);
      if (t.installSections) lines.push(`- New sections to install: ${t.installSections}`);
      if (t.removalLf)      lines.push(`- Removal & haul away: ${t.removalLf} lf (sub paid $${money(t.removalCost)})`);
      if (t.finials)        lines.push(`- Finials to replace: ${t.finials}`);
      if (t.puppyInserts)   lines.push(`- Puppy picket inserts: ${t.puppyInserts}`);
      if (t.caps)           lines.push(`- Post caps to replace: ${t.caps}`);
      if (t.wiPickets)      lines.push(`- Pickets to replace: ${t.wiPickets}`);
      if (t.puppyPickets){
        const detailParts = [];
        if(t.puppyPicketDetails && typeof t.puppyPicketDetails.forEach === 'function'){
          t.puppyPicketDetails.forEach((count, label)=>{
            if(count>0){ detailParts.push(`${count} × ${label}`); }
          });
        }
        const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
        lines.push(`- Puppy pickets to replace: ${t.puppyPickets}${detail}`);
      }
      if (t.weldRedos)      lines.push(`- Weld redos: ${t.weldRedos}`);
      if (t.wiPatches)      lines.push(`- Rail patches: ${t.wiPatches}`);
      if (t.wiRails)        lines.push(`- Full rail replacements: ${t.wiRails}`);
      if (t.wiRailGaps)     lines.push(`- Full rail gap fillers: ${t.wiRailGaps}`);
      const postSummary = (label, counts)=>{
        const parts = [];
        if(counts.posts1p5) parts.push(`${counts.posts1p5} × 1 1/2" x 1 1/2"`);
        if(counts.posts2x2) parts.push(`${counts.posts2x2} × 2x2`);
        if(counts.posts3x3) parts.push(`${counts.posts3x3} × 3x3`);
        if(counts.posts4x4) parts.push(`${counts.posts4x4} × 4x4`);
        if(parts.length) lines.push(`- ${label}: ${parts.join(', ')}`);
      };
      postSummary('Posts to replace', t.postsReplace || zeroPostCounts());
      postSummary('Posts to set (new sections)', t.postsInstall || zeroPostCounts());
      if (t.postsRealign2x2) lines.push(`- 2x2 posts to realign: ${t.postsRealign2x2}`);
      if (t.postsRealign3x3) lines.push(`- 3x3 posts to realign: ${t.postsRealign3x3}`);
      if (t.postsRealignCutWeld) lines.push(`- Posts to realign (cut & weld): ${t.postsRealignCutWeld}`);
      if (t.walkGates)     lines.push(`- Walk gates: ${t.walkGates}`);
      if (t.walkRealign)   lines.push(`- Walk gates to realign: ${t.walkRealign}`);
      if (walkHardwareSummary.total) {
        const detail = walkHardwareSummary.details.length ? ` (${walkHardwareSummary.details.join('; ')})` : '';
        lines.push(`- Walk gate hardware replacements: ${walkHardwareSummary.total}${detail}`);
      }
      if (t.walkRebuild)   lines.push(`- Walk gates to rebuild: ${t.walkRebuild}`);
      if (t.walkGateAdds)  lines.push(`- Walk gates to add: ${t.walkGateAdds}`);
      if (t.walkGateAddsSingle) lines.push(`- Single swing walk gates to add: ${t.walkGateAddsSingle}`);
      if (t.walkGateAddsDouble) lines.push(`- Double swing gates to add: ${t.walkGateAddsDouble}`);
      if (t.driveGateOperators){
        const comboParts = [];
        if(t.driveGateOperatorCombos && typeof t.driveGateOperatorCombos.forEach === 'function'){
          t.driveGateOperatorCombos.forEach((count, key)=>{
            if(count<=0) return;
            const [type, power] = String(key||'').split('|||');
            const typeLabel = (type || 'Drive').trim() || 'Drive';
            const powerLabel = (power || 'Power TBD').trim() || 'Power TBD';
            comboParts.push(`${typeLabel} / ${powerLabel}: ${count}`);
          });
        }
        const comboDetail = comboParts.length ? ` (${comboParts.join('; ')})` : '';
        lines.push(`- Drive gate operators to replace: ${t.driveGateOperators}${comboDetail}`);
      }
      if (t.driveGateOperatorInstalls){
        const comboParts = [];
        if(t.driveGateOperatorInstallCombos && typeof t.driveGateOperatorInstallCombos.forEach === 'function'){
          t.driveGateOperatorInstallCombos.forEach((count, key)=>{
            if(count<=0) return;
            const [type, power, platform] = String(key||'').split('|||');
            const typeLabel = (type || 'Drive').trim() || 'Drive';
            const powerLabel = (power || 'Power TBD').trim() || 'Power TBD';
            const platformLabel = platform === 'platform' ? 'platform' : '';
            comboParts.push(`${typeLabel} / ${powerLabel}${platformLabel ? ` / ${platformLabel}` : ''}: ${count}`);
          });
        }
        const comboDetail = comboParts.length ? ` (${comboParts.join('; ')})` : '';
        lines.push(`- Drive gate operators to install: ${t.driveGateOperatorInstalls}${comboDetail}`);
      }
      if (t.driveGateChainReplacements){
        lines.push(`- Sliding drive gate chains to replace: ${t.driveGateChainReplacements}`);
      }
      if (prefabReplacementCount) {
        const detailSuffix = prefabReplacementDetail ? ` (${prefabReplacementDetail})` : '';
        lines.push(`- Prefab panel replacements: ${prefabReplacementCount}${detailSuffix}`);
      }
      if (t.panelsCustom) lines.push(`- Panels to custom-build: ${t.panelsCustom}`);
      if (t.panelsInstallPrefab) lines.push(`- New prefab panels: ${t.panelsInstallPrefab}`);
      if (t.panelsInstallCustom) lines.push(`- New custom panels: ${t.panelsInstallCustom}`);
    }


    const installSectionsOnly = state.sections.filter(s=> (s?.scopeType || 'repair') === 'install');
    const replacementSectionsOnly = state.sections.filter(s=> (s?.scopeType || 'repair') === 'replace');

    const replacementGroups = groupSectionsByFenceType(replacementSectionsOnly);
    replacementGroups.forEach((sections, type)=>{
      const detail = buildInstallServiceDescription(sections, true);
      addServiceLine(`${fenceTypeLabel(type)} Fence Replacement`, detail || fenceTypeDefaultDetail(type, true));
    });

    const installGroups = groupSectionsByFenceType(installSectionsOnly);
    installGroups.forEach((sections, type)=>{
      const detail = buildInstallServiceDescription(sections, false);
      addServiceLine(`${fenceTypeLabel(type)} Fence Installation`, detail || fenceTypeDefaultDetail(type, false));
    });

    const paintingSummary = state.sections.reduce((acc, s)=>{
      const fenceType = (s.fenceType || '').toLowerCase();
      if(fenceType && fenceType !== 'wrought iron') return acc;
      const len = parseInt(s.length||0,10) || 0;
      if(len > 0){
        const hardscape = parseInt(s.hardscape||0,10) || 0;
        const trim = parseInt(s.trim||0,10) || 0;
        if(s.painting === 'Paint Section'){
          acc.full.len += len;
          acc.full.hardscape += hardscape;
          acc.full.trim += trim;
        } else if (s.painting === 'Prime and Paint'){
          acc.primePaint.len += len;
          acc.primePaint.hardscape += hardscape;
          acc.primePaint.trim += trim;
        } else if (s.painting === 'Spot Paint Welds'){
          acc.spot += len;
        }
      }
      return acc;
    }, { full: { len: 0, hardscape: 0, trim: 0 }, primePaint: { len: 0, hardscape: 0, trim: 0 }, spot: 0 });

    if (paintingSummary.full.len || paintingSummary.primePaint.len || paintingSummary.spot){
      const paintingMethodSet = new Set();
      state.sections.forEach(s=>{
        const fenceType = (s.fenceType || '').toLowerCase();
        if(fenceType && fenceType !== 'wrought iron') return;
        if(s.painting === 'Paint Section' || s.painting === 'Prime and Paint' || s.painting === 'Spot Paint Welds'){
          const method = String(s.paintingApplication || 'By Hand').trim();
          if(method) paintingMethodSet.add(method);
        }
      });
      const methodOrder = ['By Hand', 'Spray'];
      const methodLabels = methodOrder.filter(m => paintingMethodSet.has(m));
      paintingMethodSet.forEach(m=>{
        if(!methodLabels.includes(m)) methodLabels.push(m);
      });
      let methodNote = '';
      if(methodLabels.length){
        const methodText = methodLabels.length === 1 ? methodLabels[0] : methodLabels.join(' and ');
        methodNote = `Paint application method${methodLabels.length > 1 ? 's' : ''}: ${methodText}.`;
        if(methodLabels.includes('By Hand')){
          methodNote += ' By hand allows a thicker coat of paint to be applied, which is great for protection, and leaves a more textured finish from the gloves.';
        }
      }

      const segments = [];
      if(paintingSummary.full.len){
        let detail = `Scrape and brush off loose rust and debris, then apply gloss black oil-based paint to approximately ${paintingSummary.full.len} linear feet of fence`;
        const extras = [];
        if(paintingSummary.full.hardscape) extras.push(`${paintingSummary.full.hardscape} lf over hardscape`);
        if(paintingSummary.full.trim) extras.push(`${paintingSummary.full.trim} lf of trim detail`);
        if(extras.length) detail += ` (${extras.join(', ')})`;
        segments.push(detail);
      }
      if(paintingSummary.primePaint.len){
        let detail = `Prime with red oxide primer, then apply gloss black oil-based paint to approximately ${paintingSummary.primePaint.len} linear feet of fence`;
        const extras = [];
        if(paintingSummary.primePaint.hardscape) extras.push(`${paintingSummary.primePaint.hardscape} lf over hardscape`);
        if(paintingSummary.primePaint.trim) extras.push(`${paintingSummary.primePaint.trim} lf of trim detail`);
        if(extras.length) detail += ` (${extras.join(', ')})`;
        detail += ` with two mobilizations: prime on day one and return after cure for the finish coat`;
        segments.push(detail);
      }
      if(paintingSummary.spot){
        segments.push(`Spot prep and apply gloss black oil-based paint to weld areas along ${paintingSummary.spot} linear feet`);
      }
      let desc = segments.join('; ') + '.';
      if(methodNote){
        desc += ` ${methodNote}`;
      }
      addServiceLine('Surface Preparation & Painting', desc);
    }

    const woodRepairSections = state.sections.filter(s=> ((s.fenceType||'').toLowerCase() === 'wood') && ((s.scopeType||'repair') === 'repair'));
    if(woodRepairSections.length){
      const methodLabel = (list, val)=>{
        const match = list.find(item=>item.value === val);
        return match ? match.label : (val || '');
      };
      woodRepairSections.forEach((s, idx)=>{
        const parts = [];
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const railSize = s.woodRailSize || '';
        const picketWidth = s.woodPicketWidth || '';
        const woodHeightFt = feetFromStr(s.woodHeight || '');
        const sectionLengthFt = parseFloat(s.length||0) || 0;
        const isBoardOnBoard = /board on board/i.test(s.woodStyle || '');
        const addCount = (count, singular, plural)=>{
          const n = parseInt(count||0,10) || 0;
          if(!n) return '';
          const label = n === 1 ? singular : (plural || `${singular}s`);
          return `${n} ${label}`;
        };
        const picketReplaceCount = parseInt(s.woodRepairPicketReplace||0,10) || 0;
        const picketInstallCount = parseInt(s.woodRepairPicketInstall||0,10) || 0;
        const railReplaceCount = parseInt(s.woodRepairRailReplace||0,10) || 0;
        const railInstallCount = parseInt(s.woodRepairRailInstall||0,10) || 0;
        const postReplaceCount = parseInt(s.woodRepairPostReplace||0,10) || 0;
        const postRealignCounts = countWoodRealignMethods(s.woodPostRealignments);
        const postInstallCount = parseInt(s.woodRepairPostInstall||0,10) || 0;
        const panels = parseInt(s.woodRepairPanelReplace||0,10) || 0;
        const walkGates = parseInt(s.woodRepairWalkGateCount||0,10) || 0;
        const strengthen = parseInt(s.woodRepairGateStrengthen||0,10) || 0;
        const replaceGate = parseInt(s.woodRepairGateReplace||0,10) || 0;
        const topCapLf = parseInt(s.woodRepairTopCapReplaceLf||0,10) || 0;
        const trimLf = parseInt(s.woodRepairTrimReplaceLf||0,10) || 0;
        const kickLf = parseInt(s.woodRepairKickReplaceLf||0,10) || 0;
        const kickStack = parseInt(s.woodRepairKickReplaceStack||0,10) || 1;

        const picketReplace = picketWidth
          ? addCount(picketReplaceCount, `${picketWidth} picket`, `${picketWidth} pickets`)
          : addCount(picketReplaceCount, 'picket', 'pickets');
        if(picketReplace){
          parts.push(`Replace ${picketReplace}`);
          const perPicketMinutes = isBoardOnBoard ? 10 : 5;
          const hours = (picketReplaceCount * perPicketMinutes) / 60;
          totals.woodPicketReplace += picketReplaceCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const picketInstall = picketWidth
          ? addCount(picketInstallCount, `${picketWidth} picket`, `${picketWidth} pickets`)
          : addCount(picketInstallCount, 'picket', 'pickets');
        if(picketInstall){
          parts.push(`Install ${picketInstall}`);
          const perPicketMinutes = isBoardOnBoard ? 10 : 5;
          const hours = (picketInstallCount * perPicketMinutes) / 60;
          totals.woodPicketInstall += picketInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const railDescriptor = woodRailDescriptor(s);
        const railReplace = addCount(railReplaceCount, railDescriptor, `${railDescriptor}s`);
        if(railReplace){
          addServiceLine('Rail Replacement', `${labelPrefix}Replace ${railReplace}`);
          addMat(materials, woodRailMaterialLabel(s), railReplaceCount);
          const hours = (railReplaceCount * 20) / 60;
          totals.woodRailReplace += railReplaceCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const railInstall = addCount(railInstallCount, railSize ? `${railSize} rail` : 'rail', railSize ? `${railSize} rails` : 'rails');
        if(railInstall){
          parts.push(`Install ${railInstall}`);
          const hours = (railInstallCount * 10) / 60;
          totals.woodRailInstall += railInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const postReplace = addCount(postReplaceCount, 'post', 'posts');
        if(postReplace){
          const tie = (s.woodRepairPostReplaceTie || defaultTieForWoodPost(s.woodPost) || '').trim();
          const cap = (s.woodRepairPostReplaceCap || '').trim();
          const tieLabel = tie && !isNoTiesSelection(tie) ? tie : '';
          const extras = [tieLabel ? `Simpson ${tieLabel}` : '', cap ? `cap: ${cap}` : ''].filter(Boolean).join(', ');
          parts.push(`Replace ${postReplace}${extras ? ` (${extras})` : ''}`);
          const perPostHours = (woodHeightFt >= 8) ? 1.5 : 1;
          const hours = postReplaceCount * perPostHours * 2; // two-person task
          if(woodHeightFt >= 8){ totals.woodPostReplace8 += postReplaceCount; }
          else { totals.woodPostReplace6 += postReplaceCount; }
          woodHelperHours += hours;
          woodManHours += hours;
          woodRequiresTwoPerson = woodRequiresTwoPerson || postReplaceCount > 0;
        }
        if(postRealignCounts.dig){
          const realign = addCount(postRealignCounts.dig, 'post realignment', 'post realignments');
          parts.push(`${realign} via dig, straighten, and add concrete`);
          const perPostHours = (45/60);
          totals.woodPostRealignDig += postRealignCounts.dig;
          const hours = postRealignCounts.dig * perPostHours;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(postRealignCounts.cutWeld){
          const realign = addCount(postRealignCounts.cutWeld, 'post realignment', 'post realignments');
          parts.push(`${realign} via cut & weld`);
          const perPostHours = (20/60);
          totals.woodPostRealignCutWeld += postRealignCounts.cutWeld;
          const hours = postRealignCounts.cutWeld * perPostHours;
          woodWelderHours += hours;
          woodHelperHours += hours;
          woodManHours += hours * 2;
          woodRequiresTwoPerson = true;
        }
        const postInstall = addCount(postInstallCount, 'post installation', 'post installations');
        if(postInstall){
          const method = methodLabel(WOOD_POST_INSTALL_METHODS, s.woodRepairPostInstallMethod);
          const tie = (s.woodRepairPostInstallTie || defaultTieForWoodPost(s.woodPost) || '').trim();
          const tieLabel = tie && !isNoTiesSelection(tie) ? tie : '';
          const extras = [method, tieLabel ? `Simpson ${tieLabel}` : ''].filter(Boolean).join('; ');
          parts.push(`${postInstall}${extras ? ` (${extras})` : ''}`);
          const hours = postInstallCount * (45/60);
          totals.woodPostInstall += postInstallCount;
          addWoodMethodCount(totals.woodPostInstallMethods, s.woodRepairPostInstallMethod, postInstallCount);
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(panels>0){
          const panelCalc = s._woodPanelCalc || calcWoodPanelReplacement(s, panels);
          if(panelCalc) s._woodPanelCalc = panelCalc;
          const panelStyleRaw = String(s.woodStyle || '').trim();
          const panelStyle = panelStyleRaw ? `wood ${panelStyleRaw.toLowerCase()} panel` : 'wood panel';
          const panelAddOns = [];
          if(panelCalc && panelCalc.kick) panelAddOns.push('kick board');
          if(panelCalc && panelCalc.topCap) panelAddOns.push('top cap');
          if(panelCalc && panelCalc.trim) panelAddOns.push('trim');
          const addOnText = panelAddOns.length ? ` with ${joinParts(panelAddOns)}` : '';
          parts.push(`Replace ${panels}x ${panelStyle}${addOnText}`);
          parts.push('Remove and haul away the existing panel(s)');
          const hours = panels * 1.5;
          totals.woodPanels += panels;
          if(panelCalc){
            if(panelCalc.panelLf > 0){
              const disposalLf = panelCalc.panelLf;
              totals.removalLf += disposalLf;
              totals.removalCost += disposalLf * 3.9;
            }
            if(panelCalc.totalRails > 0){
              addMat(materials, woodRailMaterialLabel(s), panelCalc.totalRails);
            }
            if(panelCalc.totalPickets > 0){
              addMat(materials, woodPicketMaterialLabel(s), panelCalc.totalPickets);
            }
            if(panelCalc.topCap){
              const lengthLabel = formatFtValue(panelCalc.widthFt || 8) || '8';
              addMat(materials, `wood top cap (${panelCalc.topCap.size}, ${lengthLabel} ft)`, panels);
            }
            if(panelCalc.trim){
              panelCalc.trim.sizes.forEach(size=>{
                const lengthLabel = formatFtValue(panelCalc.widthFt || 8) || '8';
                addMat(materials, `wood trim (${size}, ${lengthLabel} ft)`, panels);
              });
            }
            if(panelCalc.kick){
              const stack = panelCalc.kick.stack || 1;
              const lengthLabel = formatFtValue(panelCalc.widthFt || 8) || '8';
              addMat(materials, `wood kick board (${panelCalc.kick.size}, ${lengthLabel} ft)`, panels * stack);
            }
          }
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(walkGates>0){
          const tasks = [];
          if(s.woodRepairWalkGateHinges) tasks.push('replace hinges');
          if(s.woodRepairWalkGateLatch) tasks.push('replace latch');
          if(s.woodRepairWalkGateWood) tasks.push('repair wood around gate');
          const taskLabel = tasks.length ? ` (${tasks.join(', ')})` : '';
          parts.push(`Repair ${walkGates} walk gate${walkGates===1?'':'s'}${taskLabel}`);
          const hours = walkGates * 2;
          totals.woodGateRepair += walkGates;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(strengthen>0){
          parts.push(`Strengthen ${strengthen} walk gate${strengthen===1?'':'s'} with additional 2x4 framing`);
          const hours = strengthen * 1;
          totals.woodGateStrengthen += strengthen;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(replaceGate>0){
          parts.push(`Replace ${replaceGate} walk gate${replaceGate===1?'':'s'} with new build and hardware`);
          const hours = replaceGate * 2;
          totals.woodGateReplace += replaceGate;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(topCapLf>0){
          const size = s.woodRepairTopCapReplaceSize || s.woodTopCapSize || '2x6';
          parts.push(`Replace ${topCapLf} lf of top cap (${size})`);
          const hours = topCapLf * ((20/60)/16);
          totals.woodTopCapLf += topCapLf;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(trimLf>0){
          const size = s.woodRepairTrimReplaceSize || s.woodTrimType || '';
          parts.push(`Replace ${trimLf} lf of trim${size ? ` (${size})` : ''}`);
          const hours = trimLf * ((10/60)/8);
          totals.woodTrimLf += trimLf;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(kickLf>0){
          const size = s.woodRepairKickReplaceSize || s.woodKickBoardSize || '';
          const stack = kickStack > 0 ? kickStack : 1;
          parts.push(`Replace ${kickLf} lf of kick board (${size}, ${stack} board stack)`);
          const hours = kickLf * stack * ((20/60)/8);
          totals.woodKickLf += kickLf;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(parts.length){
          addServiceLine('Wood Fence Repairs', `${labelPrefix}${parts.join('; ')}.`);
        }
        if(s.woodRepairStain && s.woodRepairStain !== 'none'){
          const stainSelection = parseWoodStainSelection(s.woodRepairStain);
          if(stainSelection.side !== 'none'){
            const sideLabelMap = { outside: 'outside', inside: 'inside', both: 'both sides' };
            const sideLabel = sideLabelMap[stainSelection.side] || stainSelection.side;
            const heightFt = Math.max(0, woodHeightFt || feetFromStr(s.height));
            const sidesMultiplier = stainSelection.side === 'both' ? 2 : 1;
            const normalizedLengthFt = Math.max(0, sectionLengthFt);
            const stainSqft = Math.max(0, Math.round(normalizedLengthFt * heightFt * sidesMultiplier));
            if(stainSelection.wash !== 'none'){
              hasWoodWashSelection = true;
            }
            if(stainSqft > 0){
              totals.woodStainSqft += stainSqft;
              const lfPerHour = sidesMultiplier === 2 ? 25 : 50;
              const baseHours = lfPerHour > 0 ? normalizedLengthFt / lfPerHour : 0;
              const topCapLf = parseFloat(s.woodRepairTopCapReplaceLf||0) || 0;
              const hasTopCap = !!s.woodAddTopCap || topCapLf > 0;
              const topCapHours = hasTopCap ? normalizedLengthFt * (0.5/60) : 0;
              const hours = baseHours + topCapHours;
              woodManHours += hours * 2;
              woodHelperHours += hours;
              woodStainHours += hours;
              woodRequiresTwoPerson = true;
            }
            if(stainSelection.wash !== 'none' && normalizedLengthFt > 0){
              const baseWashRate = sidesMultiplier === 2 ? 50 : 100;
              const baseWashHours = baseWashRate > 0 ? normalizedLengthFt / baseWashRate : 0;
              const washMultiplier = stainSelection.wash === 'hail' ? 2 : 1;
              const washHours = baseWashHours * washMultiplier;
              woodWashHours += washHours;
              woodHelperHours += washHours;
              woodManHours += washHours;
              woodWashDetails.push({
                sectionLabel: s.label || `Section ${idx + 1}`,
                sideLabel,
                lengthFt: normalizedLengthFt,
                washType: stainSelection.wash
              });
            }
            hasWoodStaining = true;
            const sectionLabel = s.label || `Section ${idx + 1}`;
            const lengthLabel = normalizedLengthFt > 0 ? `${Math.round(normalizedLengthFt)} linear ft` : '';
            const heightLabel = heightFt > 0 ? `${formatFtValue(heightFt)} ft tall` : '';
            const sizeLabel = [lengthLabel, heightLabel].filter(Boolean).join(' and ');
            const sizeDetail = sizeLabel ? ` which is about ${sizeLabel}` : '';
            woodStainDetails.push({ sectionLabel, sideLabel, lengthFt: normalizedLengthFt, sqft: stainSqft });
            const serviceName = stainSelection.wash === 'hail'
              ? 'Wood Fence Wash Hail & Stain'
              : (stainSelection.wash === 'standard' ? 'Wood Fence Wash & Stain' : 'Wood Fence Staining');
            const washPrefix = stainSelection.wash === 'hail'
              ? 'Pressure wash hail-damaged fence and stain'
              : (stainSelection.wash === 'standard' ? 'Pressure wash and stain' : 'Stain');
            addServiceLine(serviceName, `${labelPrefix}${washPrefix} ${sideLabel} of ${sectionLabel}${sizeDetail}.`);
          }
        }
      });
    }

    if(hasWoodStaining){
      const setupHours = 1;
      woodStainHours += setupHours;
      woodHelperHours += setupHours;
      woodManHours += setupHours * 2;
      const minCrewHours = 2;
      if(woodStainHours < minCrewHours){
        const addedHours = minCrewHours - woodStainHours;
        woodStainHours += addedHours;
        woodHelperHours += addedHours;
        woodManHours += addedHours * 2;
      }
    }

    manHours += woodManHours;
    helperHours += woodHelperHours;
    welderHours += woodWelderHours;
    const stainHours = woodStainHours;
    const washHours = woodWashHours;
    const hasWoodWash = washHours > 0;

    if (totals.digOut > 0){
      addServiceLine('Dig Out Encroaching Soil', `Remove built-up soil along ${totals.digOut} linear feet to expose fence bottom rails. If any additional repairs are exposed, we can let you know and get you a quote for the additional repairs.`);
    }
    const picketCount = parseInt(totals.wiPickets, 10) || 0;
    const puppyPicketCount = parseInt(totals.puppyPickets, 10) || 0;
    if (picketCount > 0 || puppyPicketCount > 0){
      const picketSegments = [];
      if(picketCount > 0){
        const picketPlural = picketCount === 1 ? '' : 's';
        const picketSizes = Array.from(totals.wiPicketSizes || []).filter(Boolean);
        let picketDesc = '';
        if(picketSizes.length === 1){
          const size = picketSizes[0];
          picketDesc = `Cut out ${picketCount}x rusted ${size} picket${picketPlural} and weld in ${picketCount}x new ${size} steel picket${picketPlural}.`;
        } else {
          const sizeSuffix = picketSizes.length > 1 ? ` (${joinParts(picketSizes)})` : '';
          picketDesc = `Cut out ${picketCount}x rusted picket${picketPlural}${sizeSuffix} and weld in ${picketCount}x new steel picket${picketPlural}${sizeSuffix}.`;
        }
        picketSegments.push(picketDesc);
      }
      if(puppyPicketCount > 0){
        const detailParts = [];
        if(totals.puppyPicketDetails && typeof totals.puppyPicketDetails.forEach === 'function'){
          totals.puppyPicketDetails.forEach((count, label)=>{
            if(count>0){ detailParts.push(`${count} × ${label}`); }
          });
        }
        const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
        const puppyLabel = describeCount(puppyPicketCount, 'puppy picket', 'puppy pickets');
        picketSegments.push(`Replace ${puppyLabel}${detail}.`);
      }
      addServiceLine('Replace Damaged Pickets', picketSegments.join(' '));
    }
    if (totals.weldRedos > 0){
      const weldLabel = describeCount(totals.weldRedos, 'weld', 'welds');
      addServiceLine('Redo Broken Welds', `Clean and re-weld ${weldLabel} where the steel is intact (no new material needed).`);
    }
    if (totals.wiPatches > 0){
      const rustedPortionText = totals.wiPatches === 1
        ? '1x rusted portion'
        : `${totals.wiPatches}x rusted portions`;
      const patchSizes = Array.from(totals.wiPatchSizes || []).filter(Boolean);
      let patchDesc = '';
      if(patchSizes.length === 1){
        patchDesc = `Cut out ${rustedPortionText} of ${patchSizes[0]} rail steel and weld in new steel.`;
      } else {
        const sizeSuffix = patchSizes.length > 1 ? ` (${joinParts(patchSizes)})` : '';
        patchDesc = `Cut out ${rustedPortionText} of rail steel${sizeSuffix} and weld in new steel.`;
      }
      addServiceLine('Rail Patch Repairs', patchDesc);
    }
    if (totals.wiRails > 0){
      const railCount = parseInt(totals.wiRails, 10) || 0;
      const railLabel = railCount === 1 ? 'old rail' : 'old rails';
      const railVerb = railCount === 1 ? 'is' : 'are';
      const railNeedVerb = railCount === 1 ? 'needs' : 'need';
      const replaceSizes = Array.from(totals.wiRailReplaceSizes || []).filter(Boolean);
      const sizeSuffix = replaceSizes.length ? ` (${joinParts(replaceSizes)})` : '';
      addServiceLine(
        'Full Rail Replacement',
        `Cut out ${railCount}x ${railLabel}${sizeSuffix} that ${railVerb} rusted through and ${railNeedVerb} to be replaced. Weld in new rail steel.`
      );
    }
    if (totals.wiRailGaps > 0){
      const gapCount = parseInt(totals.wiRailGaps, 10) || 0;
      const gapLabel = describeCount(gapCount, 'full rail gap filler', 'full rail gap fillers');
      const gapSizes = Array.from(totals.wiRailGapSizes || []).filter(Boolean);
      const sizeText = gapSizes.length ? ` using ${joinParts(gapSizes)} rail material` : ' using matching rail material';
      addServiceLine('Full Rail Gap Filler', `Add ${gapLabel}${sizeText} to close open spans and match the existing fence.`);
    }
    const replaceServiceCounts = totals.postsReplace || zeroPostCounts();
    if (replaceServiceCounts.posts2x2 > 0 || replaceServiceCounts.posts3x3 > 0 || replaceServiceCounts.posts1p5 > 0 || replaceServiceCounts.posts4x4 > 0){
      const parts = [];
      if(replaceServiceCounts.posts2x2 > 0) parts.push(describeCount(replaceServiceCounts.posts2x2, '2x2 post', '2x2 posts'));
      if(replaceServiceCounts.posts3x3 > 0) parts.push(describeCount(replaceServiceCounts.posts3x3, '3x3 post', '3x3 posts'));
      if(replaceServiceCounts.posts1p5 > 0) parts.push(describeCount(replaceServiceCounts.posts1p5, '1 1/2" x 1 1/2" post', '1 1/2" x 1 1/2" posts'));
      if(replaceServiceCounts.posts4x4 > 0) parts.push(describeCount(replaceServiceCounts.posts4x4, '4x4 post', '4x4 posts'));
      const partText = joinParts(parts);
      if(partText) addServiceLine('Replace Fence Posts', `Set new ${partText} in concrete and tie into existing panels.`);
    }
    if (totals.postsRealign2x2 > 0 || totals.postsRealign3x3 > 0){
      const parts = [];
      if(totals.postsRealign2x2 > 0) parts.push(describeCount(totals.postsRealign2x2, '2x2 post', '2x2 posts'));
      if(totals.postsRealign3x3 > 0) parts.push(describeCount(totals.postsRealign3x3, '3x3 post', '3x3 posts'));
      const partText = joinParts(parts);
      if(partText) addServiceLine('Realign Leaning Posts', `Plumb and secure ${partText} without replacement.`);
    }
    if (totals.postsRealignCutWeld > 0){
      addServiceLine(
        'Realign Leaning Posts (Cut & Weld)',
        `Cut, brace, and weld ${describeCount(totals.postsRealignCutWeld, 'leaning post', 'leaning posts')} back plumb without resetting in concrete.`
      );
    }
    if (totals.finials > 0){
      addServiceLine('Finial Replacement', `Install ${describeCount(totals.finials, 'new finial', 'new finials')} to restore decorative picket tops.`);
    }
    if (totals.puppyInserts > 0){
      const sizeParts = [];
      if(totals.puppyInsertSizes && typeof totals.puppyInsertSizes.forEach === 'function'){
        totals.puppyInsertSizes.forEach((count, size)=>{
          if(count>0){ sizeParts.push(`${count} × ${size}`); }
        });
      }
      const sizeNote = sizeParts.length ? ` (${sizeParts.join(', ')})` : '';
      addServiceLine('Install Puppy Picket Inserts', `Install ${describeCount(totals.puppyInserts, 'puppy picket insert', 'puppy picket inserts')}${sizeNote} to close spacing near the bottom of the fence for small pets.`);
    }
    if (totals.caps > 0){
      addServiceLine('Post Cap Replacement', `Install ${describeCount(totals.caps, 'new post cap', 'new post caps')} to protect posts and match the existing style.`);
    }
    if (totals.diagonalBraces > 0){
      const braceDesc = describeCount(totals.diagonalBraces, 'diagonal brace', 'diagonal braces');
      const braceSizeLabels = [];
      if(totals.diagonalBraceSizes && typeof totals.diagonalBraceSizes.forEach === 'function'){
        totals.diagonalBraceSizes.forEach((count, size)=>{
          const qty = parseInt(count,10) || 0;
          if(qty <= 0) return;
          const cleanSize = normalizeLabelText(size || '');
          braceSizeLabels.push(cleanSize ? `${cleanSize} picket steel` : 'picket steel');
        });
      }
      const uniqueBraceLabels = Array.from(new Set(braceSizeLabels)).filter(Boolean);
      const sizeDetail = uniqueBraceLabels.length ? ` using ${joinParts(uniqueBraceLabels)}` : '';
      addServiceLine('Add Diagonal Braces', `Fabricate and install ${braceDesc}${sizeDetail} to close gaps near the bottom of the fence.`);
    }
    if (prefabReplacementCount > 0){
      const typeSuffix = prefabReplacementDetail ? ` (${prefabReplacementDetail})` : '';
      addServiceLine('Install Prefab Panels', `Swap in ${describeCount(prefabReplacementCount, 'prefabricated panel', 'prefabricated panels')}${typeSuffix} and secure them to existing posts.`);
    }
    const customSwapCount = Math.max(0, totals.panelsCustom - (totals.panelsInstallCustom || 0));
    if (customSwapCount > 0){
      addServiceLine('Build Custom Panels', `Fabricate and install ${describeCount(customSwapCount, 'custom panel', 'custom panels')} on site to match the wrought iron design.`);
    }
    if (totals.walkRealign > 0){
      addServiceLine('Realign Walk Gates', `Adjust and plumb ${describeCount(totals.walkRealign, 'walk gate', 'walk gates')} for smooth swing and latch.`);
    }
    if (walkHardwareSummary.total > 0){
      const detail = walkHardwareSummary.details.length ? ` (${walkHardwareSummary.details.join('; ')})` : '';
      addServiceLine('Replace Walk Gate Hardware', `Install new latch and hinge hardware on ${describeCount(walkHardwareSummary.total, 'walk gate', 'walk gates')}${detail}.`);
    }
    if (totals.walkRebuild > 0){
      addServiceLine('Rebuild Walk Gates', `Rebuild ${describeCount(totals.walkRebuild, 'walk gate', 'walk gates')} with new frame and pickets to match the fence.`);
    }
    if (totals.walkGateAddsSingle > 0){
      addServiceLine('Add Single Walk Gate', `Cut in and install ${describeCount(totals.walkGateAddsSingle, 'single swing walk gate', 'single swing walk gates')} complete with posts, frame, and hardware.`);
    }
    if (totals.walkGateAddsDouble > 0){
      addServiceLine('Add Double Walk Gate', `Cut in and install ${describeCount(totals.walkGateAddsDouble, 'double swing gate', 'double swing gates')} complete with posts, frame, and hardware.`);
    }
    if (totals.replaceSections > 0){
      addServiceLine('Remove Fence Sections', `Take down and haul away ${describeCount(totals.replaceSections, 'existing fence section', 'existing fence sections')} prior to installation.`);
    }
    if (totals.installSections > 0){
      addServiceLine('Install New Fence Sections', `Set posts in concrete and install panels for ${describeCount(totals.installSections, 'new wrought iron fence section', 'new wrought iron fence sections')}.`);
    }

    const serviceLines = buildServiceLineOutput();
    renderServiceLineNotes(serviceLines);

    const woodStainBuckets = totals.woodStainSqft > 0
      ? Math.ceil(totals.woodStainSqft / 750)
      : 0;
    if(woodStainBuckets > 0){
      addMat(materials, '5 gal wood stain bucket', woodStainBuckets);
    }

    function addWoodPostReplacementMaterials(){
      state.sections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        const replaceCount = parseInt(s.woodRepairPostReplace || 0, 10) || 0;
        if(replaceCount <= 0) return;
        const heightFt = Math.max(0, feetFromStr(s.woodHeight || s.height));
        const railsPerPost = woodRailsForHeight(heightFt);
        const hasKickBoard = !!s.woodAddKickBoard;
        const tiesPerPost = railsPerPost + (hasKickBoard ? 1 : 0);
        const totalTies = replaceCount * tiesPerPost;
        const rawPostLabel = s.woodPost || 'Wood post';
        const isRoundSteel = /round steel/i.test(rawPostLabel);
        const isEightFoot = heightFt === 8;
        const postLabel = isRoundSteel && isEightFoot
          ? '12ft round steel'
          : normalizeLabelText(rawPostLabel);
        addMat(materials, `${postLabel} posts`, replaceCount);
        const capLabel = normalizeLabelText(s.woodRepairPostReplaceCap || '');
        if(capLabel) addMat(materials, `${capLabel} post cap`, replaceCount);
        const tieSelection = (s.woodRepairPostReplaceTie || defaultTieForWoodPost(s.woodPost) || '');
        const tieLabel = normalizeLabelText(tieSelection);
        if(totalTies > 0 && tieLabel && !isNoTiesSelection(tieLabel)){
          addMat(materials, `Simpson ${tieLabel}`, totalTies);
          addMat(materials, 'lag screws', totalTies * 4);
        }
        const bagsPerPost = heightFt >= 8 ? 1.25 : 1;
        addMat(materials, 'Maximizer bags of concrete', replaceCount * bagsPerPost);
      });
    }

    addWoodPostReplacementMaterials();

    function addWoodPostInstallMaterials(){
      state.sections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        if((s.scopeType || 'repair') !== 'repair') return;
        const installCount = parseInt(s.woodRepairPostInstall || 0, 10) || 0;
        if(installCount <= 0) return;
        const heightFt = Math.max(0, feetFromStr(s.woodHeight || s.height));
        const railsPerPost = woodRailsForHeight(heightFt);
        const hasKickBoard = !!s.woodAddKickBoard;
        const tiesPerPost = railsPerPost + (hasKickBoard ? 1 : 0);
        const totalTies = installCount * tiesPerPost;
        const rawPostLabel = s.woodPost || 'Wood post';
        const isRoundSteel = /round steel/i.test(rawPostLabel);
        const isEightFoot = heightFt === 8;
        const postLabel = isRoundSteel && isEightFoot
          ? '12ft round steel'
          : normalizeLabelText(rawPostLabel);
        addMat(materials, `${postLabel} posts`, installCount);
        const tieSelection = (s.woodRepairPostInstallTie || defaultTieForWoodPost(s.woodPost) || '');
        const tieLabel = normalizeLabelText(tieSelection);
        if(totalTies > 0 && tieLabel && !isNoTiesSelection(tieLabel)){
          addMat(materials, `Simpson ${tieLabel}`, totalTies);
          addMat(materials, 'lag screws', totalTies * 4);
        }
        const method = String(s.woodRepairPostInstallMethod || '').toLowerCase();
        if(method !== 'drive-posts'){
          const bagsPerPost = heightFt >= 8 ? 1.25 : 1;
          addMat(materials, 'Maximizer bags of concrete', installCount * bagsPerPost);
        }
      });
    }

    addWoodPostInstallMaterials();

    function addWoodPicketMaterials(){
      const picketCounts = {};
      state.sections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        if((s.scopeType || 'repair') !== 'repair') return;
        const replaceCount = parseInt(s.woodRepairPicketReplace || 0, 10) || 0;
        const installCount = parseInt(s.woodRepairPicketInstall || 0, 10) || 0;
        const total = replaceCount + installCount;
        if(total <= 0) return;
        const label = woodPicketMaterialLabel(s);
        picketCounts[label] = (picketCounts[label] || 0) + total;
      });
      Object.entries(picketCounts).forEach(([label, qty])=>{
        addMat(materials, label, qty);
      });
    }

    addWoodPicketMaterials();

    // ==== Materials aggregation ====
    let paintLenTotal = 0;
    let paintGallons = 0;
    let paintCans = 0;
    let primerGallons = 0;
    let primerCans = 0;

    const weldRepairHours = (
      totals.wiPickets*12 +
      totals.puppyPickets*12 +
      totals.diagonalBraces*12 +
      totals.wiPatches*20 +
      totals.wiRails*30 +
      totals.wiRailGaps*20 +
      totals.weldRedos*5 +
      totals.posts1p5*60 +
      totals.posts2x2*60 +
      totals.posts3x3*90 +
      totals.posts4x4*120 +
      (totals.postsRealign2x2 + totals.postsRealign3x3)*30
    )/60;
    manHours += weldRepairHours;
    welderHours += weldRepairHours;
    const cutWeldWelderHours = totals.postsRealignCutWeld * 0.5;
    const cutWeldHelperHours = totals.postsRealignCutWeld * 0.5;
    if(totals.postsRealignCutWeld > 0){
      manHours += cutWeldWelderHours + cutWeldHelperHours;
      welderHours += cutWeldWelderHours;
      helperHours += cutWeldHelperHours;
    }
    const gateRepairHours = totals.walkRealign * 1 + totals.walkHardware * 1 + totals.walkRebuild * 3;
    manHours += gateRepairHours;
    welderHours += gateRepairHours;
    // Dig out: 5 minutes per LF
    const digHours = totals.digOut * (5/60);
    manHours += digHours;
    helperHours += digHours;
    // Finials: 0.5 minutes each
    const finialHours = totals.finials * (0.5/60);
    manHours += finialHours;
    welderHours += finialHours;
    // Caps: 20 seconds each
    const capHours = totals.caps * (20/60);
    manHours += capHours;
    helperHours += capHours;
    const puppyInsertWelderHours = totals.puppyInserts * 0.5; // 30 minutes each
    const puppyInsertHelperHours = totals.puppyInserts * (5/60); // 5 minutes each
    const puppyInsertManHours = puppyInsertWelderHours + puppyInsertHelperHours;
    manHours += puppyInsertManHours;
    welderHours += puppyInsertWelderHours;
    helperHours += puppyInsertHelperHours;
    // Added gates: 4 hours each
    const addedGateHours = (totals.walkGateAddsSingle * 2) + (totals.walkGateAddsDouble * 3);
    manHours += addedGateHours;
    welderHours += addedGateHours;
    // Sliding drive gate chain replacement: 1 crew hour each
    const driveGateChainCrewHours = totals.driveGateChainReplacements * 1;
    if(driveGateChainCrewHours > 0){
      const driveGateChainManHours = driveGateChainCrewHours * ONSITE_CREW_SIZE;
      manHours += driveGateChainManHours;
      helperHours += driveGateChainManHours;
    }
    let driveGateOperatorHours = 0;
    if(totals.driveGateOperatorTypes && typeof totals.driveGateOperatorTypes.forEach === 'function'){
      totals.driveGateOperatorTypes.forEach((count, label)=>{
        const qty = parseInt(count,10) || 0;
        if(qty <= 0) return;
        const normalized = String(label||'').toLowerCase();
        const perHours = normalized.includes('double') ? 5 : 3;
        driveGateOperatorHours += qty * perHours;
      });
    } else {
      driveGateOperatorHours = totals.driveGateOperators * 3;
    }
    manHours += driveGateOperatorHours;

    let driveGateOperatorInstallHours = 0;
    if(totals.driveGateOperatorInstallTypes && typeof totals.driveGateOperatorInstallTypes.forEach === 'function'){
      totals.driveGateOperatorInstallTypes.forEach((count, label)=>{
        const qty = parseInt(count,10) || 0;
        if(qty <= 0) return;
        const normalized = String(label||'').toLowerCase();
        const perHours = normalized.includes('double') ? 5 : 3;
        driveGateOperatorInstallHours += qty * perHours;
      });
    } else {
      driveGateOperatorInstallHours = totals.driveGateOperatorInstalls * 3;
    }
    if(totals.driveGateOperatorInstallPlatforms > 0){
      driveGateOperatorInstallHours += totals.driveGateOperatorInstallPlatforms * 2;
    }
    manHours += driveGateOperatorInstallHours;

    // posts (1.5" x 1.5" raw sticks)
    let raw1p5Total = 0;
    state.sections.forEach(s=>{
      const hft = feetFromStr(s.height);
      const postLen = Math.max(8, hft + 3);
      const repCounts = countPostGroups(s.postReplacements);
      const count = repCounts.posts1p5 || 0;
      if(count>0){
        const perStick = Math.max(1, Math.floor(12 / Math.max(1, postLen)));
        raw1p5Total += Math.ceil(count / perStick);
      }
      const installCount1p5 = parseInt(s._installCalc?.postCounts?.posts1p5 || 0,10) || 0;
      if(installCount1p5>0){
        const perStickInstall = Math.max(1, Math.floor(12 / Math.max(1, postLen)));
        raw1p5Total += Math.ceil(installCount1p5 / perStickInstall);
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '1 1/2" x 1 1/2"'){
        const perStickAdd = Math.max(1, Math.floor(12 / Math.max(1, postLen)));
        raw1p5Total += Math.ceil(addG / perStickAdd);
      }
    });
    if(raw1p5Total>0){
      steelStickTotals.raw1p5 += raw1p5Total;
      addMat(materials, '1.5x1.5x12 raw steel', raw1p5Total);
    }

    // posts (2x2 by length)
    const posts2x2ByLenCalc = {};
    state.sections.forEach(s=>{
      const hft = feetFromStr(s.height);
      const postLen = Math.max(8, hft + 3);
      const repCounts = countPostGroups(s.postReplacements);
      const nReplace = repCounts.posts2x2 || 0;
      if(nReplace>0){ posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + nReplace; }
      const nInstall2x2 = parseInt(s._installCalc?.postCounts?.posts2x2 || 0,10) || 0;
      if(nInstall2x2>0){ posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + nInstall2x2; }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '2x2'){
        posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + addG;
      }
    });
    Object.keys(posts2x2ByLenCalc).sort((a,b)=>parseInt(a,10)-parseInt(b,10)).forEach(len=>{
      addMat(materials, `2x2x${len} posts`, posts2x2ByLenCalc[len]);
    });

    // 3x3 raw sticks (12ft) incl. gate adds
    const posts3x3ByLenCalc = {};
    state.sections.forEach(s=>{
      const repCounts = countPostGroups(s.postReplacements);
      const count = repCounts.posts3x3 || 0;
      const L = Math.max(8, feetFromStr(s.height) + 3);
      if(count>0){
        const perStick = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticks = Math.ceil(count / perStick);
        posts3x3ByLenCalc[L] = (posts3x3ByLenCalc[L]||0) + sticks;
      }
      const installCount3x3 = parseInt(s._installCalc?.postCounts?.posts3x3 || 0,10) || 0;
      if(installCount3x3>0){
        const perStickInstall = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksInstall = Math.ceil(installCount3x3 / perStickInstall);
        posts3x3ByLenCalc[L] = (posts3x3ByLenCalc[L]||0) + sticksInstall;
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '3x3'){
        const perStickAdd = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksAdd = Math.ceil(addG / perStickAdd);
        posts3x3ByLenCalc[L] = (posts3x3ByLenCalc[L]||0) + sticksAdd;
      }
    });
    let raw3x3Total = 0;
    Object.values(posts3x3ByLenCalc).forEach(v=>{ raw3x3Total += v; });
    if(raw3x3Total>0){
      steelStickTotals.raw3x3 += raw3x3Total;
      addMat(materials, '3x3x12 raw steel', raw3x3Total);
    }

    // 4x4 raw sticks (12ft) incl. gate adds
    const posts4x4ByLenCalc = {};
    state.sections.forEach(s=>{
      const repCounts = countPostGroups(s.postReplacements);
      const count = repCounts.posts4x4 || 0;
      const L = Math.max(8, feetFromStr(s.height) + 3);
      if(count>0){
        const perStick = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticks = Math.ceil(count / perStick);
        posts4x4ByLenCalc[L] = (posts4x4ByLenCalc[L]||0) + sticks;
      }
      const installCount4x4 = parseInt(s._installCalc?.postCounts?.posts4x4 || 0,10) || 0;
      if(installCount4x4>0){
        const perStickInstall = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksInstall = Math.ceil(installCount4x4 / perStickInstall);
        posts4x4ByLenCalc[L] = (posts4x4ByLenCalc[L]||0) + sticksInstall;
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '4x4'){
        const perStickAdd = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksAdd = Math.ceil(addG / perStickAdd);
        posts4x4ByLenCalc[L] = (posts4x4ByLenCalc[L]||0) + sticksAdd;
      }
    });
    let raw4x4Total = 0;
    Object.values(posts4x4ByLenCalc).forEach(v=>{ raw4x4Total += v; });
    if(raw4x4Total>0){
      steelStickTotals.raw4x4 += raw4x4Total;
      addMat(materials, '4x4x12 raw steel', raw4x4Total);
    }

    // Concrete (exclude posts set within retaining walls)
    const wallPostCounts = totals.retainingWallPosts || zeroPostCounts();
    const posts1p5NeedingConcrete = Math.max(0, totals.posts1p5 - (wallPostCounts.posts1p5 || 0));
    const posts2x2NeedingConcrete = Math.max(0, totals.posts2x2 - (wallPostCounts.posts2x2 || 0));
    const posts3x3NeedingConcrete = Math.max(0, totals.posts3x3 - (wallPostCounts.posts3x3 || 0));
    const posts4x4NeedingConcrete = Math.max(0, totals.posts4x4 - (wallPostCounts.posts4x4 || 0));
    const concreteBagsCalc = posts2x2NeedingConcrete + posts3x3NeedingConcrete + posts1p5NeedingConcrete + posts4x4NeedingConcrete + Math.ceil((totals.postsRealign2x2 + totals.postsRealign3x3) * 0.5) + totals.walkRealign + totals.walkGateAddsRepair;

    // Gate bits + gate materials
    const latchCounts = {};
    const hingeCounts = {};
    state.sections.forEach(s=>{
      const hw = parseInt(s.walkGatesHardware||0,10) || 0;
      const rb = parseInt(s.walkGatesRebuild||0,10) || 0;
      if(hw>0){
        if(s.walkLatch) latchCounts[s.walkLatch] = (latchCounts[s.walkLatch]||0) + hw;
        if(s.walkHinges) hingeCounts[s.walkHinges] = (hingeCounts[s.walkHinges]||0) + hw;
      }
      if(rb>0){
        if(s.walkRebuildLatch) latchCounts[s.walkRebuildLatch] = (latchCounts[s.walkRebuildLatch]||0) + rb;
        if(s.walkRebuildHinges) hingeCounts[s.walkRebuildHinges] = (hingeCounts[s.walkRebuildHinges]||0) + rb;
        const frame = s.walkRebuildFrame || '';
        const pick  = s.walkRebuildPicket || '';
        const fN = normalizeSize(frame);
        const pN = normalizeSize(pick);
        if(fN === '1\"' && (pN === '1/2\"' || pN === '5/8\"')){
          const gateDescParts = [];
          if((s.walkRebuildFrame||'').trim()){ gateDescParts.push(`frame ${s.walkRebuildFrame.trim()}`); }
          if((s.walkRebuildPicket||'').trim()){ gateDescParts.push(`pickets ${s.walkRebuildPicket.trim()}`); }
          const gateDesc = gateDescParts.length ? ` (${gateDescParts.join(', ')})` : '';
          addMat(materials, `prefab gate panel${gateDesc}`, rb);
          addRailSticks(frame, rb * 2);
        } else {
          addRailSticks(frame, rb * 2);
          addPicketSticks(pick, rb * 2);
        }
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0){
        if(s.walkAddLatch) latchCounts[s.walkAddLatch] = (latchCounts[s.walkAddLatch]||0) + addG;
        if(s.walkAddHinges) hingeCounts[s.walkAddHinges] = (hingeCounts[s.walkAddHinges]||0) + addG;
        const gateType = s.walkAddType || 'Single Swing Walk Gate';
        const perGateRail = gateType === 'Double Swing Gate' ? 4 : 2;
        const sectionRails = sectionRailSizes(s);
        const frame = s.walkAddFrameSize || '';
        const railsToCount = sectionRails.length ? sectionRails : (frame ? [frame] : []);
        railsToCount.forEach(size=>{
          addRailSticks(size, addG * perGateRail);
        });
      }
    });

    // Add latches/hinges
    Object.keys(latchCounts).forEach(k=> addMat(materials, k, latchCounts[k]));
    const hingeLabel = (k)=> k==='Door Hinges' ? 'Pair of Door Hinges'
                            : k==='Bat Wing Hinges' ? 'Pair of Bat Wing Hinges'
                            : k==='Auto Close Hinges' ? 'Pair of Auto Close Hinges'
                            : k;
    Object.keys(hingeCounts).forEach(k=> addMat(materials, hingeLabel(k), hingeCounts[k]));

    addMat(materials, 'Maximizer bags of concrete', concreteBagsCalc);

    // WI picket sticks from replacements
    const picketBySizeCalc = {};
    state.sections.forEach(s=>{
      const scopeType = s.scopeType || 'repair';
      const isRepair = scopeType !== 'install' && scopeType !== 'replace';
      const isWrought = (s.fenceType || '').toLowerCase() === 'wrought iron';
      const need = parseInt(s.wiPickets||0,10) || 0;
      if(need){
        let ph = parseInt(s.picketHeight||0,10) || 0; // inches
        if (ph <= 0) {
          const hf = feetFromStr(s.height);
          if (hf > 0) ph = hf * 12;
        }
        if (ph <= 0) ph = 54;
        const perStick = Math.max(1, Math.floor(144 / ph));
        const sticks = Math.ceil(need / perStick);
        const size = normalizeSize(s.picketSize);
        picketBySizeCalc[size] = (picketBySizeCalc[size]||0) + sticks;
      }
      if(isRepair && isWrought && hasPuppyPickets(s.puppy)){
        const puppyNeed = parseInt(s.puppyPicketReplace||0,10) || 0;
        if(puppyNeed){
          let ph = parseInt(s.puppyPicketHeight||0,10) || 0;
          if (ph <= 0) {
            ph = parseInt(s.picketHeight||0,10) || 0;
          }
          if (ph <= 0) {
            const hf = feetFromStr(s.height);
            if (hf > 0) ph = hf * 12;
          }
          if (ph <= 0) ph = 54;
          const perStick = Math.max(1, Math.floor(144 / ph));
          const sticks = Math.ceil(puppyNeed / perStick);
          const size = normalizeSize(s.puppyPicketSize || s.picketSize);
          picketBySizeCalc[size] = (picketBySizeCalc[size]||0) + sticks;
        }
      }
    });
    Object.entries(picketBySizeCalc).forEach(([size, qty])=>{
      addPicketSticks(size, qty);
    });

    Object.entries(diagonalBraceFeetBySize).forEach(([size, feetTotal])=>{
      const totalFeet = parseFloat(feetTotal) || 0;
      if(totalFeet <= 0) return;
      const sticks = Math.ceil(totalFeet / 12);
      if(sticks > 0){
        addPicketSticks(size, sticks);
      }
    });

    // Rails: patches & replacements → sticks
    const railStickBySizeMat = {};
    const patchBySizeMat = {};
    const replBySizeMat = {};
    const gapBySizeMat = {};
    function inc(map, key, delta){ if(!key) return; map[key] = (map[key]||0) + (delta||0); }

    state.sections.forEach(s=>{
      const rCount = s.railsCount || (s.rails||[]).length || 0;
      for(let i=0;i<rCount;i++){
        const r = (s.rails||[])[i] || {};
        const p = parseInt(r.patches||0,10) || 0;
        const rep = parseInt(r.replacements||0,10) || 0;
        if(p>0){
          inc(patchBySizeMat, normalizeSize(r.size), p);
          if(r.stacked) inc(patchBySizeMat, normalizeSize(r.size2), p);
        }
        if(rep>0){
          inc(replBySizeMat, normalizeSize(r.size), rep);
          if(r.stacked) inc(replBySizeMat, normalizeSize(r.size2), rep);
        }
      }
      const gapArr = Array.isArray(s.gapAdditions) ? s.gapAdditions : [];
      gapArr.forEach(item=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        if(qty<=0) return;
        const normalized = normalizeSize(item?.size);
        inc(gapBySizeMat, normalized, qty);
      });
    });

    Object.entries(replBySizeMat).forEach(([size, rep])=>{
      if(rep>0) inc(railStickBySizeMat, size, rep);
    });

    Object.entries(gapBySizeMat).forEach(([size, gapCount])=>{
      if(gapCount>0) inc(railStickBySizeMat, size, gapCount);
    });

    Object.entries(patchBySizeMat).forEach(([size, pcount])=>{
      const credits = replBySizeMat[size] || 0;
      const remaining = Math.max(0, (pcount||0) - credits);
      if(remaining>0){
        inc(railStickBySizeMat, size, Math.ceil(remaining/6));
      }
    });

    Object.keys(railStickBySizeMat).forEach(size=>{
      addRailSticks(size, railStickBySizeMat[size]);
    });

    // Paint estimates
    let totalLenPaint = 0;
    let totalLenPrimePaint = 0;
    let totalLenSpot  = 0;
    state.sections.forEach(s=>{
      const len = (parseInt(s.length||0,10) || 0);
      if(!len) return;
      if (s.painting === 'Paint Section') {
        totalLenPaint += len;
      } else if (s.painting === 'Prime and Paint') {
        totalLenPaint += len;
        totalLenPrimePaint += len;
      } else if (s.painting === 'Spot Paint Welds') {
        totalLenSpot += len;
      }
    });
    paintLenTotal = totalLenPaint;
    paintGallons  = Math.ceil(totalLenPaint / 100);
    if (paintGallons > 0) paintCans += Math.ceil(paintGallons * 0.5);
    primerGallons = Math.ceil(totalLenPrimePaint / 100);
    if (primerGallons > 0) primerCans += Math.ceil(primerGallons * 0.5);
    if (totalLenSpot > 0) {
      const unitsSpot = Math.ceil(totalLenSpot / 100);
      paintCans += Math.max(1, Math.ceil(unitsSpot * 0.5));
    }
    if (paintGallons > 0) addMat(materials, 'gallons of gloss black paint', paintGallons);
    if (paintCans > 0)    addMat(materials, 'spray cans (gloss black)', paintCans);
    if (primerGallons > 0) addMat(materials, 'gallons of red oxide primer', primerGallons);
    if (primerCans > 0)    addMat(materials, 'spray cans (red oxide primer)', primerCans);

    // Finials (descriptive labels) for MATERIALS list
    state.sections.forEach(s=>{
      const arr = Array.isArray(s.finials) ? s.finials : [];
      arr.forEach(f=>{
        const q = parseInt(f?.qty||0,10) || 0; if(!q) return;
        const picketLabel = normalizeSize(f?.picketSize);
        addMat(materials, `finials - ${f.material} - ${f.style} (${picketLabel})`, q);
      });
    });
    // Caps (descriptive labels) for MATERIALS list
    state.sections.forEach(s=>{
      const arr = Array.isArray(s.caps) ? s.caps : [];
      arr.forEach(c=>{
        const q = parseInt(c?.qty||0,10) || 0; if(!q) return;
        addMat(materials, `caps - ${c.material} - ${c.style} (${c.postSize})`, q);
      });
    });

    // ===== Panel purchase vs build materials & direct costs =====
    let costPanels = 0;
    state.sections.forEach(s=>{
      const lst = s._panelCalc || [];
      lst.forEach(p=>{
        if(p.eligible){
          const price = PANEL_PRICE[pkey(p.feet, p.picketSize, p.style)];
          const unit = (typeof price==='number') ? price : 0;
          costPanels += p.qty * unit;
          const panelDescParts = [];
          if(p.height) panelDescParts.push(p.height);
          if(p.style) panelDescParts.push(p.style);
          const styleText = p.style || '';
          const hasFinialsInStyle = /Finials?/i.test(styleText);
          const isFlatTopStyle = /Flat Top/i.test(styleText);
          if(p.finialStyle && !hasFinialsInStyle && !isFlatTopStyle){
            panelDescParts.push(`(${p.finialStyle})`);
          }
          const picketLabel = p.picketSize ? `${p.picketSize} pickets` : '';
          const panelDesc = panelDescParts.length ? panelDescParts.join(' ') : 'wrought iron';
          const labelParts = [`prefab fence panel ${panelDesc}`];
          if(picketLabel) labelParts.push(`(${picketLabel})`);
          addMat(materials, labelParts.join(' '), p.qty);
          // No extra raw steel for prefab
        } else {
          // Build on site: rails (2 per panel) and pickets per width
          const totalRailInches = 2 * p.widthIn * p.qty; // two horizontals
          const railFeet = totalRailInches / 12;
          const railSticks = Math.ceil(railFeet / 12);
          addRailSticks(p.railSize, railSticks);

          const picketsPerPanel = picketCountForWidth(p.widthIn, p.picketSize);
          // assume picket height = selected panel height in inches (fallback 54)
          let ph = p.feet>0 ? p.feet*12 : 54;
          const perStick = Math.max(1, Math.floor(144 / ph));
          const totalPickets = picketsPerPanel * p.qty;
          const picketSticks = Math.ceil(totalPickets / perStick);
          addPicketSticks(p.picketSize, picketSticks);
        }
      });
    });

    // ===== Costing =====
    let unpriced = false;
    const matBreak = [];
    let costMaterials = 0;

    if(totals.retainingWallCost > 0){
      costMaterials += totals.retainingWallCost;
      matBreak.push('  - Retaining wall installation (In-House 4 only): $'+money(totals.retainingWallCost)+' ($35/sq ft, $1,500 minimum, includes wall materials & labor; post materials separate)');
    }

    // PRICE_MISC line-items
    Object.entries(materials).forEach(([label, qty])=>{
      if(Object.prototype.hasOwnProperty.call(PRICE_MISC, label)){
        const unit = PRICE_MISC[label] || 0;
        const c = qty * unit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
        return;
      }
      const woodPicketUnit = woodPicketUnitPriceFromLabel(label);
      if(woodPicketUnit !== null){
        const c = qty * woodPicketUnit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(woodPicketUnit)} = $${money(c)}`);
        return;
      }
      const woodRailUnit = woodRailUnitPriceFromLabel(label);
      if(woodRailUnit !== null){
        const unit = woodRailUnit || 0;
        if(unit <= 0) unpriced = true;
        const c = qty * unit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
        return;
      }
      const woodBoardUnit = woodBoardUnitPriceFromLabel(label);
      if(woodBoardUnit !== null){
        const unit = woodBoardUnit || 0;
        if(unit <= 0) unpriced = true;
        const c = qty * unit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
        return;
      }
      if(/^wood rail/i.test(label)){
        unpriced = true;
        matBreak.push(`  - ${label}: ${qty} x $${money(0)} = $${money(0)}`);
      }
    });

    if(costPanels>0){
      costMaterials += costPanels;
      matBreak.push('  - Prefab fence panels: $'+money(costPanels));
    }

    if(paintGallons>0){
      const c = paintGallons * PRICE.paintGallon;
      costMaterials += c;
      matBreak.push('  - Paint (gallons): '+paintGallons+' x $'+money(PRICE.paintGallon)+' = $'+money(c));
    }
    if(paintCans>0){
      const c = paintCans * PRICE.paintCan;
      costMaterials += c;
      matBreak.push('  - Paint (spray cans): '+paintCans+' x $'+money(PRICE.paintCan)+' = $'+money(c));
    }
    if(primerGallons>0){
      const c = primerGallons * PRICE.primerGallon;
      costMaterials += c;
      matBreak.push('  - Red oxide primer (gallons): '+primerGallons+' x $'+money(PRICE.primerGallon)+' = $'+money(c));
    }
    if(primerCans>0){
      const c = primerCans * PRICE.primerCan;
      costMaterials += c;
      matBreak.push('  - Red oxide primer (spray cans): '+primerCans+' x $'+money(PRICE.primerCan)+' = $'+money(c));
    }

    const concreteBagsMat = (materials['Maximizer bags of concrete']||0);
    if(concreteBagsMat>0){
      const c = concreteBagsMat * PRICE.concrete;
      costMaterials += c;
      matBreak.push('  - Concrete (Maximizer): '+concreteBagsMat+' x $'+money(PRICE.concrete)+' = $'+money(c));
    }

    const posts2x2CountsCost = {};
    Object.keys(materials).forEach(k=>{
      const m = k.match(/^2x2x(\d+)\s+posts$/);
      if(m){ posts2x2CountsCost[m[1]] = (posts2x2CountsCost[m[1]]||0) + materials[k]; }
    });
    Object.entries(posts2x2CountsCost).forEach(([lenStr, qty])=>{
      const len = parseInt(lenStr,10) || 0;
      let unit = PRICE.post2x2[len];
      if(unit==null){
        const perFt = PRICE_FT['2x2\"']||0;
        unit = perFt * len;
      }
      const c = qty * (unit||0);
      if((unit||0)===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 2x2x'+len+' posts: '+qty+' x $'+money(unit)+' = $'+money(c));
    });

    const raw1p5Count = steelStickTotals.raw1p5 || 0;
    if(raw1p5Count>0){
      const perFt1p5 = PRICE_FT['1 1/2\"'] || 0;
      const unit1p5 = 12 * perFt1p5;
      if(perFt1p5 === 0) unpriced = true;
      const c = raw1p5Count * unit1p5;
      costMaterials += c;
      matBreak.push('  - 1.5x1.5 raw steel sticks: '+raw1p5Count+' x 12ft x $'+money(perFt1p5)+'/ft = $'+money(c));
    }

    const raw3x3Count = steelStickTotals.raw3x3 || 0;
    if(raw3x3Count>0){
      const unit3x3 = 12 * (PRICE_FT['3x3\"']||0);
      const c = raw3x3Count * unit3x3;
      costMaterials += c;
      matBreak.push('  - 3x3 raw steel sticks: '+raw3x3Count+' x 12ft x $'+money(PRICE_FT['3x3\"']||0)+'/ft = $'+money(c));
    }

    const raw4x4Count = steelStickTotals.raw4x4 || 0;
    if(raw4x4Count>0){
      const unit4x4 = 139.73;
      const c = raw4x4Count * unit4x4;
      costMaterials += c;
      matBreak.push('  - 4x4 raw steel sticks: '+raw4x4Count+' x $'+money(unit4x4)+' = $'+money(c));
    }

    Object.keys(picketStickTotals).sort().forEach(size=>{
      const qty = picketStickTotals[size];
      const perFt = PRICE_FT[size]||0;
      const c = qty * 12 * perFt;
      if(perFt===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 12ft picket sticks '+size+': '+qty+' x 12ft x $'+money(perFt)+'/ft = $'+money(c));
    });

    Object.keys(railStickTotals).sort().forEach(size=>{
      const qty = railStickTotals[size];
      const perFt = PRICE_FT[size]||0;
      const c = qty * 12 * perFt;
      if(perFt===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 12ft rail sticks '+size+': '+qty+' x 12ft x $'+money(perFt)+'/ft = $'+money(c));
    });

    // NEW: Finials cost (flat $1.25 each via total of descriptive labels)
    const finialsPricedUnit = PRICE_MISC['replacement finial'] || 0;
    const finialsTotalForCost = Object.keys(materials).reduce((acc,k)=>{
      if(k.startsWith('finials - ')) return acc + (materials[k]||0);
      return acc;
    }, 0);
    if(finialsTotalForCost>0){
      const c = finialsTotalForCost * finialsPricedUnit;
      costMaterials += c;
      matBreak.push('  - Replacement finials: '+finialsTotalForCost+' x $'+money(finialsPricedUnit)+' = $'+money(c));
    }

    // NEW: Caps cost by size/style
    Object.entries(materials).forEach(([label, qty])=>{
      const m = label.match(CAP_LABEL_RE);
      if(!m) return;
      const style = m[2];
      const postSize = m[3];
      let unit = 0;
      // Normalize style to handle typos like "bal" -> "ball"
      const styleNorm = String(style||'').toLowerCase();
      const isBall = /ball/.test(styleNorm);
      if(postSize === '1 1/2" x 1 1/2"' || postSize === '2x2'){
        unit = isBall ? 4 : 1;
      } else if(postSize === '3x3'){
        unit = isBall ? 7 : 2;
      } else if(postSize === '4x4'){
        unit = isBall ? 15 : 8;
      } else {
        unit = 0;
        unpriced = true;
      }
      const c = qty * unit;
      costMaterials += c;
      matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
    });

    // Labor + totals
    let primePaintReturnHours = 0;
    let sprayBaseHours = 0;
    let sprayFinishHours = 0;
    const paintingHours = state.sections.reduce((acc, s)=>{
      if (s.painting !== 'Paint Section' && s.painting !== 'Prime and Paint') return acc;
      const len = parseInt(s.length||0,10) || 0;
      const method = s.paintingApplication || 'By Hand';
      let totalSectionHours = 0;
      if(method === 'Spray'){
        let panelCount = 0;
        if(Array.isArray(s.panels)){
          panelCount = s.panels.reduce((sum, panel)=>{
            const qty = parseInt(panel?.qty||0, 10) || 0;
            return sum + qty;
          }, 0);
        }
        if(panelCount <= 0 && len > 0){
          panelCount = Math.max(1, Math.ceil(len / 8));
        }
        if(panelCount > 0){
          totalSectionHours = panelCount / 4;
        }
      }else{
        if(!len) return acc;
        const railsPenalty = railPacePenalty(s.railsCount || (s.rails||[]).length || 0);
        const denom = styleFactor(s.style) - puppyAdj(s.puppy) - railsPenalty;
        const baseHours = (len/8) / Math.max(0.5, denom);
        const hardscapeHours = (parseInt(s.hardscape||0,10)||0) / 20;
        const trimHours = (parseInt(s.trim||0,10)||0) / 50;
        totalSectionHours = baseHours + hardscapeHours + trimHours;
      }
      if(totalSectionHours <= 0) return acc;
      if(s.painting === 'Paint Section' && s.paintingPrepExtra){
        totalSectionHours *= 1.25;
      }
      if(method === 'Spray'){
        sprayBaseHours += totalSectionHours;
      }
      if (s.painting === 'Prime and Paint'){
        primePaintReturnHours += totalSectionHours;
        if(method === 'Spray'){
          sprayFinishHours += totalSectionHours;
        }
      }
      return acc + totalSectionHours;
    }, 0);
    manHours += paintingHours + primePaintReturnHours;
    helperHours += paintingHours + primePaintReturnHours;
    welderHours += sprayBaseHours + sprayFinishHours;

    if(JOB_SETUP_TEARDOWN_HOURS > 0){
      const setupTeardownManHours = JOB_SETUP_TEARDOWN_HOURS * ONSITE_CREW_SIZE;
      manHours += setupTeardownManHours;
      helperHours += setupTeardownManHours;
    }

    const hasPostReplacements = (()=>{
      const replaceCounts = totals.postsReplace || zeroPostCounts();
      const hasMetalPosts = (replaceCounts.posts1p5 || 0) > 0
        || (replaceCounts.posts2x2 || 0) > 0
        || (replaceCounts.posts3x3 || 0) > 0
        || (replaceCounts.posts4x4 || 0) > 0;
      const hasWoodPosts = (totals.woodPostReplace6 || 0) > 0 || (totals.woodPostReplace8 || 0) > 0;
      return hasMetalPosts || hasWoodPosts;
    })();
    if(hasPostReplacements){
      const minCrewHours = 3;
      const minManHours = minCrewHours * ONSITE_CREW_SIZE;
      if(manHours < minManHours){
        const addedHours = minManHours - manHours;
        manHours += addedHours;
        helperHours += addedHours;
      }
    }

    const jobAddress = mapAddressInput ? (mapAddressInput.value || '').trim() : lastEstimateAddress;
    const travelDayInfo = await computeTravelDayInfo(jobAddress);
    const travelHoursPerDay = travelDayInfo.included && isFinite(travelDayInfo.hoursPerDay)
      ? travelDayInfo.hoursPerDay
      : 0;
    const MAX_CREW_DAY_HOURS = CREW_SETTINGS.maxDayHours || 10;
    const onsiteHoursPerPerson = MAX_CREW_DAY_HOURS - travelHoursPerDay;
    // Guard against zero/negative onsite capacity if travel time exceeds the day cap.
    const HOURS_PER_PERSON = Math.max(0.25, onsiteHoursPerPerson);
    const primePaintScheduled = totalLenPrimePaint > 0;
    const hasInstallOrReplace = (totals.installSections > 0) || (totals.replaceSections > 0);
    const requiresTwoPersonCrew = hasInstallOrReplace || (totals.postsRealignCutWeld > 0) || woodRequiresTwoPerson || stainHours > 0;
    const minCrewBase = requiresTwoPersonCrew ? 2 : 1;
    const MIN_CREW_PER_DAY = Math.max(minCrewBase, CREW_SETTINGS.minCrew);
    const MAX_CREW_PER_DAY = CREW_SETTINGS.maxCrew;
    const MAX_WELDERS = Math.max(0, CREW_SETTINGS.maxWelders || MAX_CREW_PER_DAY);
    // Wrought-iron repair work is capped at 2 concurrent welders.
    const MAX_BASE_WELDERS = hasWroughtRepair ? Math.min(MAX_WELDERS, 2) : MAX_WELDERS;
    const stainReturnHours = hasWoodWash ? stainHours : 0;
    const day2Hours = primePaintReturnHours + stainReturnHours;
    const helperHoursDay2 = day2Hours;
    const helperHoursDay1 = Math.max(0, helperHours - helperHoursDay2 - washHours);
    const washHoursDay1 = Math.max(0, washHours);
    const stainHoursDay1 = Math.max(0, hasWoodWash ? 0 : stainHours);
    const finishWelderHours = sprayFinishHours;
    const baseWelderHours = Math.max(0, welderHours - finishWelderHours);
    const baseStainHours = Math.min(stainHoursDay1, helperHoursDay1);
    const baseHelperHours = Math.max(0, helperHoursDay1 - baseStainHours);

    const washDays = [];
    let remainingWashHours = washHoursDay1;
    const MAX_WASHERS = Math.min(2, MAX_CREW_PER_DAY);
    while(remainingWashHours > 0.01){
      let washerCount = Math.ceil(remainingWashHours / HOURS_PER_PERSON);
      washerCount = Math.max(1, Math.min(washerCount, MAX_WASHERS));
      let crewCount = washerCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, washerCount));
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      const usedWashHours = Math.min(remainingWashHours, washerCount * HOURS_PER_PERSON);
      washDays.push({ crew: crewCount, welderCount: 0, stainerCount: 0, helperCount: crewCount, hours: usedWashHours });
      remainingWashHours = Math.max(0, remainingWashHours - usedWashHours);
      if(washerCount === 0 && crewCount === 0){
        break;
      }
    }

    const baseDays = [];
    let remainingWelderHours = baseWelderHours;
    let remainingHelperHours = baseHelperHours;
    let remainingStainHours = baseStainHours;
    while(remainingWelderHours > 0.01 || remainingHelperHours > 0.01 || remainingStainHours > 0.01){
      let welderCount = 0;
      if(remainingWelderHours > 0.01){
        const welderNeeded = Math.ceil(remainingWelderHours / HOURS_PER_PERSON);
        welderCount = Math.max(1, Math.min(welderNeeded, MAX_BASE_WELDERS, MAX_CREW_PER_DAY));
      }
      let stainerCount = 0;
      if(remainingStainHours > 0.01){
        const stainerNeeded = Math.ceil(remainingStainHours / HOURS_PER_PERSON);
        const maxStainers = Math.floor(Math.max(0, MAX_CREW_PER_DAY - welderCount) / 2);
        stainerCount = Math.min(stainerNeeded, maxStainers);
      }
      const welderCapacity = welderCount * HOURS_PER_PERSON;
      const helperHoursWelderCanCover = Math.max(0, welderCapacity - remainingWelderHours);
      let helperCount = 0;
      const helperHoursAfterWelder = Math.max(0, remainingHelperHours - helperHoursWelderCanCover);
      if(helperHoursAfterWelder > 0.01){
        const helperNeeded = Math.ceil(helperHoursAfterWelder / HOURS_PER_PERSON);
        helperCount = Math.min(helperNeeded, Math.max(0, MAX_CREW_PER_DAY - welderCount - stainerCount));
      }
      helperCount = Math.max(helperCount, stainerCount);
      helperCount = Math.min(helperCount, Math.max(0, MAX_CREW_PER_DAY - welderCount - stainerCount));
      let crewCount = welderCount + stainerCount + helperCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, welderCount + stainerCount));
      }
      if(crewCount <= 0){
        crewCount = Math.min(MAX_CREW_PER_DAY, MIN_CREW_PER_DAY);
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      helperCount = Math.min(helperCount, Math.max(0, crewCount - welderCount - stainerCount));
      if(welderCount + stainerCount + helperCount < crewCount){
        helperCount = crewCount - welderCount - stainerCount;
      }
      const usedWelderHours = Math.min(remainingWelderHours, welderCount * HOURS_PER_PERSON);
      const usedStainerHours = Math.min(remainingStainHours, stainerCount * HOURS_PER_PERSON);
      const usedHelperHours = Math.min(
        remainingHelperHours,
        helperHoursWelderCanCover + Math.max(0, helperCount - stainerCount) * HOURS_PER_PERSON
      );
      const usedHours = usedWelderHours + usedStainerHours + usedHelperHours;
      baseDays.push({ crew: crewCount, welderCount, stainerCount, helperCount, hours: usedHours });
      remainingWelderHours = Math.max(0, remainingWelderHours - welderCount * HOURS_PER_PERSON);
      const helperHoursHandledByWeldersFinal = Math.min(remainingHelperHours, helperHoursWelderCanCover);
      remainingStainHours = Math.max(0, remainingStainHours - stainerCount * HOURS_PER_PERSON);
      remainingHelperHours = Math.max(
        0,
        remainingHelperHours - helperHoursHandledByWeldersFinal - Math.max(0, (helperCount - stainerCount)) * HOURS_PER_PERSON
      );
      if(welderCount === 0 && stainerCount === 0 && helperCount === 0){
        break;
      }
    }

    const finishDays = [];
    let remainingFinishWelderHours = finishWelderHours;
    let remainingFinishHelperHours = helperHoursDay2;
    while(remainingFinishWelderHours > 0.01 || remainingFinishHelperHours > 0.01){
      let welderCount = 0;
      if(remainingFinishWelderHours > 0.01){
        const welderNeeded = Math.ceil(remainingFinishWelderHours / HOURS_PER_PERSON);
        welderCount = Math.max(1, Math.min(welderNeeded, MAX_WELDERS, MAX_CREW_PER_DAY));
      }
      const welderCapacity = welderCount * HOURS_PER_PERSON;
      const helperHoursWelderCanCover = Math.max(0, welderCapacity - remainingFinishWelderHours);
      let helperCount = 0;
      const helperHoursAfterWelder = Math.max(0, remainingFinishHelperHours - helperHoursWelderCanCover);
      if(helperHoursAfterWelder > 0.01){
        const helperNeeded = Math.ceil(helperHoursAfterWelder / HOURS_PER_PERSON);
        helperCount = Math.min(helperNeeded, Math.max(0, MAX_CREW_PER_DAY - welderCount));
      }
      let crewCount = welderCount + helperCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, welderCount));
      }
      if(crewCount <= 0){
        crewCount = Math.min(MAX_CREW_PER_DAY, MIN_CREW_PER_DAY);
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      helperCount = Math.min(helperCount, Math.max(0, crewCount - welderCount));
      if(welderCount + helperCount < crewCount){
        helperCount = crewCount - welderCount;
      }
      finishDays.push({ crew: crewCount, welderCount, stainerCount: 0, helperCount });
      remainingFinishWelderHours = Math.max(0, remainingFinishWelderHours - welderCount * HOURS_PER_PERSON);
      const helperHoursHandledByWelders = Math.min(remainingFinishHelperHours, helperHoursWelderCanCover);
      remainingFinishHelperHours = Math.max(0, remainingFinishHelperHours - helperHoursHandledByWelders - helperCount * HOURS_PER_PERSON);
      if(welderCount === 0 && helperCount === 0){
        break;
      }
    }

    if(washDays.length && baseDays.length){
      const firstWash = washDays[0];
      const firstBase = baseDays[0];
      const washHoursToCombine = firstWash.hours || 0;
      const baseHours = firstBase.hours || 0;
      const baseCapacity = (firstBase.crew || 0) * HOURS_PER_PERSON;
      if(washHoursToCombine > 0
        && firstWash.crew <= firstBase.crew
        && (baseHours + washHoursToCombine) <= baseCapacity){
        baseDays[0] = { ...firstBase, hasWash: true, hours: baseHours + washHoursToCombine };
        washDays.shift();
      }
    }

    const crewSchedule = [];
    washDays.forEach(day => crewSchedule.push({ ...day, kind: 'wash' }));
    baseDays.forEach(day => crewSchedule.push({ ...day, kind: primePaintScheduled ? 'prime' : 'base' }));
    finishDays.forEach(day => crewSchedule.push({ ...day, kind: 'finish' }));

    const crewLabelWithMix = (count) => {
      if(count <= 0) return '';
      return `${ONSITE_CREW_SIZE}-man crew`;
    };

    const returnSuffix = primePaintScheduled && hasWoodWash
      ? ' (return for finish coat & staining)'
      : (primePaintScheduled ? ' (return for finish coat)' : (hasWoodWash ? ' (return for staining)' : ''));
    const scheduleEntries = crewSchedule.map((day, idx) => {
      const crewLabel = crewLabelWithMix(day.crew);
      const suffix = day.kind === 'wash'
        ? ' (pressure wash)'
        : (day.kind === 'finish'
          ? returnSuffix
          : (day.hasWash
            ? (primePaintScheduled ? ' (prime/repairs, then pressure wash)' : ' (repairs, then pressure wash)')
            : (primePaintScheduled ? ' (prime/repairs)' : '')));
      return {
        number: idx + 1,
        crewLabel,
        suffix,
      };
    });

    const estimatedOnsiteHours = ONSITE_CREW_SIZE > 0 ? manHours / ONSITE_CREW_SIZE : 0;
    const formatHours = (hours) => {
      if (!isFinite(hours) || hours <= 0) return '';
      const rounded = Math.round(hours * 10) / 10;
      const isWhole = Math.abs(rounded - Math.round(rounded)) < 0.05;
      return isWhole ? `${Math.round(rounded)} hours` : `${rounded.toFixed(1)} hours`;
    };
    const estimatedOnsiteLabel = formatHours(estimatedOnsiteHours);
    const totalLaborHoursLabel = formatHours(manHours);
    const onsiteCrewLabel = `${ONSITE_CREW_SIZE}-man crew`;

    const materialEntries = Object.keys(materials)
      .filter(label => materials[label] > 0)
      .sort((a, b) => a.localeCompare(b))
      .map(label => ({ label, qty: materials[label] }));

    if (materialEntries.length) {
      lines.push('');
      lines.push('MATERIALS');
      materialEntries.forEach(({ label, qty }) => {
        lines.push(`- ${qty}x ${label}`);
      });
    }

    const sub = [];
    sub.push("CREW");
    if (totalLaborHoursLabel) {
      sub.push(`- Total labor time: ${totalLaborHoursLabel}`);
    }
    if (estimatedOnsiteLabel) {
      sub.push(`- Estimated onsite time (${onsiteCrewLabel}): ${estimatedOnsiteLabel}`);
    }
    sub.push('');
    sub.push('SCOPE (Totals)');
    const pushPostLinesSub = (label, counts)=>{
      const parts = [];
      const addIfPresent = (key, label)=>{
        const qty = parseInt(counts?.[key], 10) || 0;
        if(qty > 0) parts.push(`${qty} × ${label}`);
      };
      addIfPresent('posts1p5', '1 1/2" x 1 1/2"');
      addIfPresent('posts2x2', '2x2');
      addIfPresent('posts3x3', '3x3');
      addIfPresent('posts4x4', '4x4');
      if(parts.length) sub.push(`- ${label}: ${parts.join(', ')}`);
    };
    pushPostLinesSub('Posts to replace', totals.postsReplace || zeroPostCounts());
    if (totals.postsRealign2x2 > 0) sub.push('- 2x2 posts to realign: '+totals.postsRealign2x2);
    if (totals.postsRealign3x3 > 0) sub.push('- 3x3 posts to realign: '+totals.postsRealign3x3);
    if (totals.postsRealignCutWeld > 0) sub.push('- Posts to realign (cut & weld): '+totals.postsRealignCutWeld);
    if (totals.woodPostRealignCutWeld > 0) sub.push('- Wood posts to realign (cut & weld): '+totals.woodPostRealignCutWeld);
    if (totals.woodPostRealignDig > 0) sub.push('- Wood posts to realign (dig): '+totals.woodPostRealignDig);
    pushPostLinesSub('Posts to set (new sections)', totals.postsInstall || zeroPostCounts());
    if (totals.replaceSections > 0) sub.push('- Sections to replace: '+totals.replaceSections);
    if (totals.installSections > 0) sub.push('- New sections to install: '+totals.installSections);
    if (totals.removalLf > 0)       sub.push(`- Removal & haul away: ${totals.removalLf} lf (sub paid $${money(totals.removalCost)})`);
    if (totals.wiPickets > 0)       sub.push('- Pickets to replace: '+totals.wiPickets);
    if (totals.puppyPickets > 0){
      const detailParts = [];
      if(totals.puppyPicketDetails && typeof totals.puppyPicketDetails.forEach === 'function'){
        totals.puppyPicketDetails.forEach((count, label)=>{
          if(count>0){ detailParts.push(`${count} × ${label}`); }
        });
      }
      const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
      sub.push(`- Puppy pickets to replace: ${totals.puppyPickets}${detail}`);
    }
    if (totals.weldRedos > 0)       sub.push('- Weld redos: '+totals.weldRedos);
    if (totals.wiPatches > 0)       sub.push('- Rail patches: '+totals.wiPatches);
    if (totals.wiRails > 0)         sub.push('- Full rail replacements: '+totals.wiRails);
    if (totals.wiRailGaps > 0)      sub.push('- Full rail gap fillers: '+totals.wiRailGaps);
    if (totals.walkGates > 0)       sub.push('- Walk gates: '+totals.walkGates);
    if (totals.walkRealign > 0)     sub.push('- Walk gates to realign: '+totals.walkRealign);
    if (walkHardwareSummary.total > 0) {
      const detail = walkHardwareSummary.details.length ? ` (${walkHardwareSummary.details.join('; ')})` : '';
      sub.push(`- Walk gate hardware replacements: ${walkHardwareSummary.total}${detail}`);
    }
    if (totals.walkRebuild > 0)     sub.push('- Walk gates to rebuild: '+totals.walkRebuild);
    if (totals.walkGateAddsSingle > 0) sub.push('- Single swing walk gates to add: '+totals.walkGateAddsSingle);
    if (totals.walkGateAddsDouble > 0) sub.push('- Double swing gates to add: '+totals.walkGateAddsDouble);
    if (totals.driveGateOperators > 0){
      const comboLines = [];
      if(totals.driveGateOperatorCombos && typeof totals.driveGateOperatorCombos.forEach === 'function'){
        totals.driveGateOperatorCombos.forEach((count, key)=>{
          if(count<=0) return;
          const [type, power] = String(key||'').split('|||');
          const typeRaw = (type || 'drive').trim();
          const typeLabel = typeRaw.toLowerCase() || 'drive';
          const powerLabel = (power || '').trim().toLowerCase();
          const operatorLabel = count === 1 ? 'gate operator' : 'gate operators';
          const operatorModel = getDriveGateOperatorLabel(typeRaw);
          const modelSuffix = operatorModel ? ` (${operatorModel})` : '';
          const powerSuffix = powerLabel ? `, using ${powerLabel}` : '';
          comboLines.push(`- Replace ${count} ${typeLabel} ${operatorLabel}${modelSuffix}${powerSuffix}`);
        });
      }
      if(comboLines.length){
        comboLines.forEach(line=> sub.push(line));
      } else {
        sub.push('- Drive gate operators to replace: '+totals.driveGateOperators);
      }
    }
    if (totals.driveGateOperatorInstalls > 0){
      const comboLines = [];
      if(totals.driveGateOperatorInstallCombos && typeof totals.driveGateOperatorInstallCombos.forEach === 'function'){
        totals.driveGateOperatorInstallCombos.forEach((count, key)=>{
          if(count<=0) return;
          const [type, power, platform] = String(key||'').split('|||');
          const typeRaw = (type || 'drive').trim();
          const typeLabel = typeRaw.toLowerCase() || 'drive';
          const powerLabel = (power || '').trim().toLowerCase();
          const operatorLabel = count === 1 ? 'gate operator' : 'gate operators';
          const operatorModel = getDriveGateOperatorLabel(typeRaw);
          const modelSuffix = operatorModel ? ` (${operatorModel})` : '';
          const powerSuffix = powerLabel ? `, using ${powerLabel}` : '';
          const platformSuffix = platform === 'platform' ? ', with platform' : '';
          comboLines.push(`- Install ${count} ${typeLabel} ${operatorLabel}${modelSuffix}${powerSuffix}${platformSuffix}`);
        });
      }
      if(comboLines.length){
        comboLines.forEach(line=> sub.push(line));
      } else {
        sub.push('- Drive gate operators to install: '+totals.driveGateOperatorInstalls);
      }
    }
    if (totals.driveGateChainReplacements > 0){
      sub.push('- Sliding drive gate chains to replace: '+totals.driveGateChainReplacements);
    }
    if (totals.finials > 0)         sub.push('- Finials to replace: '+totals.finials);
    if (totals.puppyInserts > 0)    sub.push('- Puppy picket inserts: '+totals.puppyInserts);
    if (totals.caps > 0)            sub.push('- Post caps to replace: '+totals.caps);
    if (installCapsByLabel.size > 0){
      installCapsByLabel.forEach((qty, label)=>{
        const m = label.match(CAP_LABEL_RE);
        if(m){
          const material = m[1];
          const style = m[2];
          const postSize = m[3];
          sub.push(`- Post caps to install: ${qty} × ${material} ${style} (${postSize})`);
        }else{
          sub.push(`- Post caps to install: ${qty}`);
        }
      });
    }
    if (totals.diagonalBraces > 0)  sub.push('- Diagonal braces to add: '+totals.diagonalBraces);
    if (totals.digOut > 0)          sub.push('- Dig out: '+totals.digOut+' lf');
    if (prefabReplacementCount > 0){
      const detailSuffix = prefabReplacementDetail ? ` (${prefabReplacementDetail})` : '';
      sub.push(`- Prefab panel replacements: ${prefabReplacementCount}${detailSuffix}`);
    }
    if (totals.panelsCustom > 0)    sub.push('- Panels to custom-build: '+totals.panelsCustom);
    if (totals.panelsInstallPrefab > 0) sub.push('- New prefab panels: '+totals.panelsInstallPrefab);
    if (totals.panelsInstallCustom > 0) sub.push('- New custom panels: '+totals.panelsInstallCustom);
    if (totals.retainingWallSqft > 0) sub.push(`- Retaining wall: ${totals.retainingWallSqft.toFixed(2)} sq ft ($${money(totals.retainingWallCost)}). In-House 4 pours the wall (wall materials & labor included; post materials separate) and Jesus' crew installs the fence. Posts on the wall set in the pour—no extra concrete bags.`);
    if (paintLenTotal > 0)          sub.push('- Scrape off loose rust and debris, then hand paint '+paintLenTotal+' ft of fence');
    if (totalLenPrimePaint > 0)     sub.push('- Prime with red oxide primer and schedule a return visit after cure to apply the finish coat');
    if (totals.woodPicketReplace > 0) sub.push('- Wood pickets to replace: '+totals.woodPicketReplace);
    if (totals.woodPicketInstall > 0) sub.push('- Wood pickets to install: '+totals.woodPicketInstall);
    if (totals.woodRailReplace > 0) sub.push('- Wood rails to replace: '+totals.woodRailReplace);
    if (totals.woodRailInstall > 0) sub.push('- Wood rails to install: '+totals.woodRailInstall);
    const woodPostReplaceByType = new Map();
    state.sections.forEach(section=>{
      if((section.fenceType || '').toLowerCase() !== 'wood') return;
      if((section.scopeType || 'repair') !== 'repair') return;
      const count = parseInt(section.woodRepairPostReplace || 0, 10) || 0;
      if(count <= 0) return;
      const rawType = String(section.woodPost || 'wood post').trim();
      const typeLabel = rawType ? rawType.toLowerCase() : 'wood';
      woodPostReplaceByType.set(typeLabel, (woodPostReplaceByType.get(typeLabel) || 0) + count);
    });
    woodPostReplaceByType.forEach((count, typeLabel)=>{
      const postLabel = count === 1 ? 'post' : 'posts';
      sub.push(`- Replace ${count} ${typeLabel} ${postLabel}`);
    });
    const woodMethodLabel = (method)=>{
      const match = WOOD_POST_INSTALL_METHODS.find(item=>item.value === method);
      return match ? match.label : method;
    };
    const pushWoodPostMethodLines = (label, counts)=>{
      if(!counts) return;
      Object.entries(counts).forEach(([method, count])=>{
        const qty = parseInt(count,10) || 0;
        if(qty <= 0) return;
        sub.push(`- ${label} (${woodMethodLabel(method)}): ${qty}`);
      });
    };
    pushWoodPostMethodLines('Wood posts to install', totals.woodPostInstallMethods);
    if (totals.woodPanels > 0) sub.push('- Wood panels to replace: '+totals.woodPanels);
    if (totals.woodGateRepair > 0) sub.push('- Wood walk gates to repair: '+totals.woodGateRepair);
    if (totals.woodGateStrengthen > 0) sub.push('- Wood gates to strengthen: '+totals.woodGateStrengthen);
    if (totals.woodGateReplace > 0) sub.push('- Wood gates to replace: '+totals.woodGateReplace);
    if (totals.woodTopCapLf > 0) sub.push('- Wood top cap to replace: '+totals.woodTopCapLf+' lf');
    if (totals.woodTrimLf > 0) sub.push('- Wood trim to replace: '+totals.woodTrimLf+' lf');
    if (totals.woodKickLf > 0) sub.push('- Wood kick board to replace: '+totals.woodKickLf+' lf');
    const stainScopeLines = [];
    const summarizeStainLengths = (details)=>{
      const totalsBySide = new Map();
      details.forEach(detail=>{
        const sideRaw = String(detail.sideLabel || '').trim().toLowerCase();
        const sideLabel = sideRaw || 'side';
        const length = isFinite(detail.lengthFt) ? detail.lengthFt : 0;
        if(length <= 0) return;
        totalsBySide.set(sideLabel, (totalsBySide.get(sideLabel) || 0) + length);
      });
      if(!totalsBySide.size) return '';
      const parts = [];
      const order = ['both sides', 'outside', 'inside'];
      order.forEach(side=>{
        if(!totalsBySide.has(side)) return;
        const len = totalsBySide.get(side);
        const rounded = Math.round(len * 10) / 10;
        const lenLabel = Math.abs(rounded - Math.round(rounded)) < 0.05 ? `${Math.round(rounded)}` : `${rounded.toFixed(1)}`;
        parts.push(`${side} of ${lenLabel} linear ft`);
      });
      totalsBySide.forEach((len, side)=>{
        if(order.includes(side)) return;
        const rounded = Math.round(len * 10) / 10;
        const lenLabel = Math.abs(rounded - Math.round(rounded)) < 0.05 ? `${Math.round(rounded)}` : `${rounded.toFixed(1)}`;
        parts.push(`${side} of ${lenLabel} linear ft`);
      });
      return parts.join('; ');
    };
    if (woodWashDetails.length){
      const summary = summarizeStainLengths(woodWashDetails);
      if(summary){
        stainScopeLines.push(`- Power wash the fence to clean off dirt and debris (${summary})`);
        stainScopeLines.push(`- Return after a couple of days to stain the fence (${summary})`);
      } else if (hasWoodWashSelection) {
        stainScopeLines.push('- Wood wash & stain selected; add section length and height to estimate wash time.');
      }
    } else if (hasWoodWashSelection) {
      stainScopeLines.push('- Wood wash & stain selected; add section length and height to estimate wash time.');
    } else if (woodStainDetails.length){
      const summary = summarizeStainLengths(woodStainDetails);
      if(summary){
        stainScopeLines.push(`- Stain the fence (${summary})`);
      } else if (hasWoodStaining) {
        stainScopeLines.push('- Wood staining selected; add section length and height to estimate area.');
      }
    } else if (hasWoodStaining) {
      stainScopeLines.push('- Wood staining selected; add section length and height to estimate area.');
    }
    stainScopeLines.forEach(line => sub.push(line));
    sub.push('');
    sub.push('MATERIALS');
    materialEntries.forEach(({ label, qty }) => {
      sub.push(`- ${qty}x ${label}`);
    });
    if (notesSubEl) { notesSubEl.value = sub.join('\n'); }

    const laborHoursOnsite = isFinite(estimatedOnsiteHours) ? estimatedOnsiteHours : 0;
    const laborCost = laborHoursOnsite * LABOR_RATE;
    const consumablesCost = scheduleEntries.length * 50;
    const removalCost = totals.removalCost || 0;
    const travelCostResult = await computeTravelCost({ crewSchedule, jobAddress, travelDayInfo });
    const travelCost = travelCostResult.cost || 0;
    const travelHours = isFinite(travelCostResult.hours) ? travelCostResult.hours : 0;
    const totalHours = laborHoursOnsite + travelHours;
    const directCosts = laborCost + travelCost + costMaterials + removalCost + consumablesCost;
    const revenueRes = computeChargeRevenue(directCosts, totalHours);
    const revenue = revenueRes && isFinite(revenueRes.revenue) ? revenueRes.revenue : NaN;
    const revenueExcludingMcor = revenue * (1 - RATES.mcor);
    const commissionFormula$ = isFinite(revenue)
      ? (RATES.commission * (((1 - RATES.overhead) * revenueExcludingMcor) - directCosts))
      : NaN;

    const cost = [];
    cost.push('ESTIMATED COST');
    const crewScheduleDetail = scheduleEntries.map(entry => {
      const dayTitle = entry.suffix ? `Day ${entry.number}${entry.suffix}` : `Day ${entry.number}`;
      return `${dayTitle}: ${entry.crewLabel}`;
    });
    const laborTimeDetail = estimatedOnsiteLabel || 'time TBD';
    const laborScheduleDetail = crewScheduleDetail.length ? `; ${crewScheduleDetail.join('; ')}` : '';
    cost.push(`- Labor ($${money(LABOR_RATE)}/hr, crew): $${money(laborCost)} (${laborTimeDetail}${laborScheduleDetail})`);
    const travelHoursLabel = formatHours(travelHours);
    const totalHoursLabel = formatHours(totalHours);
    if (estimatedOnsiteLabel) {
      const timeDetail = totalLaborHoursLabel
        ? `${estimatedOnsiteLabel} onsite (~${totalLaborHoursLabel} of labor time)`
        : estimatedOnsiteLabel;
      cost.push(`- Estimated time (onsite): ${timeDetail}`);
    }
    if (travelHoursLabel){
      cost.push(`- Estimated time (travel): ${travelHoursLabel}`);
    } else if (!travelCostResult.included){
      cost.push('- Estimated time (travel): not included (missing address or schedule).');
    }
    if (totalHoursLabel){
      const totalLabel = travelCostResult.included ? 'total' : 'total, travel excluded';
      cost.push(`- Estimated time (${totalLabel}): ${totalHoursLabel}`);
    }
    travelCostResult.breakdown.forEach(line => cost.push(line));
    cost.push('- Consumables: $'+money(consumablesCost));
    cost.push('- Materials: $'+money(costMaterials));
    if(removalCost>0){ cost.push('- Removal & disposal (paid to sub): $'+money(removalCost)); }
    matBreak.forEach(line=> cost.push(line));
    cost.push('- Total: $'+money(laborCost + travelCost + costMaterials + removalCost + consumablesCost));
    if (unpriced) cost.push('  - Note: Some sizes have no price mapping and were counted as $0.');

    cost.push('');
    cost.push('WHAT TO CHARGE');
    if (!isFinite(revenue)){
      cost.push('⚠️ Pricing inputs produce an invalid result. Check overhead rate and ensure total hours > 0.');
    } else {
      const grossProfit = revenue - directCosts - (revenue * RATES.overhead);
      const netProfit = grossProfit - commissionFormula$;
      const netProfitPct = revenue !== 0 ? (netProfit / revenue) * 100 : NaN;
      cost.push('- Price to charge: $'+money(revenue));
      cost.push('- Total direct costs: $'+money(directCosts));
      if(isFinite(revenueRes?.targetGross)){
        const hoursLabel = totalHoursLabel || (isFinite(totalHours) && totalHours > 0 ? `${totalHours.toFixed(1)} hours` : 'time TBD');
        cost.push(`- Target gross profit ($${money(PRICING.grossProfitTargetPerHour)}/hr × ${hoursLabel}, $${money(getGrossProfitMinimum())} min): $${money(revenueRes.targetGross)}`);
      }
      cost.push('- Overhead amount: $'+money(revenue * RATES.overhead));
      cost.push('- Gross profit: $'+money(grossProfit));
      cost.push('- Commission (per formula): $'+money(commissionFormula$));
      cost.push('- Net profit: $'+money(netProfit));
      cost.push('- Net profit %: '+(isFinite(netProfitPct) ? netProfitPct.toFixed(1) : 'Invalid')+'%');
    }

    const idxTotals = lines.indexOf('TOTALS');
    const outLines = (idxTotals >= 0)
      ? [...lines.slice(idxTotals), '', ...lines.slice(0, idxTotals)]
      : lines;
    const fullNotes = [...outLines, '', ...cost];

    const snapshot = snapshotForNotes();
    const encodedSnapshot = encodePayloadForNotes(snapshot);
    if(encodedSnapshot){
      fullNotes.push('');
      fullNotes.push('Reload key (for Scope Generator, do not edit)');
      fullNotes.push(`${NOTES_DATA_START}${encodedSnapshot}${NOTES_DATA_END}`);
    }

    notesEl.value = fullNotes.join('\n');
    outputEl.style.display = 'grid';
    if (window.parentIFrame && typeof window.parentIFrame.size === 'function') {
      try { window.parentIFrame.size(); } catch(e){}
    }
    if(shouldScroll){
      scrollTo(outputEl);
    }
    persist();
    } finally {
      isGeneratingNotes = false;
    }
  }

  function renderServiceLineNotes(items){
    lastServiceLines = Array.isArray(items) ? items.map(item=>({ ...item })) : [];

    if(!serviceListEl || !serviceCardEl){
      return;
    }

    serviceListEl.innerHTML = '';

    if(!lastServiceLines.length){
      serviceCardEl.style.display = 'none';
      if(serviceCopyAllBtn){
        serviceCopyAllBtn.disabled = true;
        serviceCopyAllBtn.textContent = 'Copy All';
      }
      return;
    }

    serviceCardEl.style.display = 'block';
    if(serviceCopyAllBtn){
      serviceCopyAllBtn.disabled = false;
      serviceCopyAllBtn.textContent = 'Copy All';
    }

    lastServiceLines.forEach((item, index)=>{
      const lineEl = document.createElement('div');
      lineEl.className = 'sp-service-line';
      lineEl.dataset.index = String(index);

      const titleField = document.createElement('div');
      titleField.className = 'sp-field';
      const titleLabel = document.createElement('label');
      titleLabel.className = 'sp-label';
      titleLabel.textContent = 'Line Item Title';
      const titleRow = document.createElement('div');
      titleRow.className = 'sp-copy-row';
      const titleInput = document.createElement('input');
      titleInput.className = 'sp-input';
      titleInput.readOnly = true;
      titleInput.value = item.name || '';
      const titleBtn = document.createElement('button');
      titleBtn.className = 'sp-btn ghost sp-copy-service';
      titleBtn.type = 'button';
      titleBtn.textContent = 'Copy';
      titleBtn.dataset.text = item.name || '';
      titleBtn.dataset.kind = 'title';
      titleRow.appendChild(titleInput);
      titleRow.appendChild(titleBtn);
      titleField.appendChild(titleLabel);
      titleField.appendChild(titleRow);

      const descField = document.createElement('div');
      descField.className = 'sp-field';
      const descLabel = document.createElement('label');
      descLabel.className = 'sp-label';
      descLabel.textContent = 'Description';
      const descRow = document.createElement('div');
      descRow.className = 'sp-copy-row';
      const descTextarea = document.createElement('textarea');
      descTextarea.className = 'sp-textarea';
      descTextarea.readOnly = true;
      descTextarea.value = item.desc || '';
      const descBtn = document.createElement('button');
      descBtn.className = 'sp-btn ghost sp-copy-service';
      descBtn.type = 'button';
      descBtn.textContent = 'Copy';
      descBtn.dataset.text = item.desc || '';
      descBtn.dataset.kind = 'description';
      descRow.appendChild(descTextarea);
      descRow.appendChild(descBtn);
      descField.appendChild(descLabel);
      descField.appendChild(descRow);

      lineEl.appendChild(titleField);
      lineEl.appendChild(descField);

      serviceListEl.appendChild(lineEl);
    });
  }

  function copyTextToClipboard(text){
    const value = (typeof text === 'string') ? text : String(text || '');
    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function'){
      return navigator.clipboard.writeText(value);
    }

    return new Promise((resolve, reject)=>{
      const textarea = document.createElement('textarea');
      textarea.value = value;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.top = '-9999px';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        const ok = document.execCommand('copy');
        document.body.removeChild(textarea);
        if(ok) resolve();
        else reject(new Error('Copy command was rejected.'));
      } catch(err){
        document.body.removeChild(textarea);
        reject(err);
      }
    });
  }

  function flashButton(btn, message='Copied!', options){
    if(!btn) return;
    const opts = Object.assign({ revertMs: 1200, disable: true }, options || {});
    const originalText = btn.textContent;
    const originalDisabled = btn.disabled;
    btn.textContent = message;
    if(opts.disable){
      btn.disabled = true;
    }
    window.setTimeout(()=>{
      btn.textContent = originalText;
      if(opts.disable){
        btn.disabled = originalDisabled;
      }
    }, opts.revertMs);
  }

  function copyAllServiceLines(){
    if(!lastServiceLines.length || !serviceCopyAllBtn){
      return;
    }
    const text = lastServiceLines.map(item=>`${item.name}: ${item.desc}`).join('\n');
    copyTextToClipboard(text)
      .then(()=>flashButton(serviceCopyAllBtn))
      .catch(()=>flashButton(serviceCopyAllBtn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function handleServiceListClick(event){
    const btn = event.target.closest('.sp-copy-service');
    if(!btn){
      return;
    }
    const text = btn.dataset && typeof btn.dataset.text !== 'undefined' ? btn.dataset.text : '';
    copyTextToClipboard(text)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function numOrDash(v){ const n = parseInt(v,10); return isNaN(n)?'—':n; }
  function scrollTo(el){ el.scrollIntoView({behavior:'smooth', block:'start'}); }

  function copyNotes(){
    const btn = document.getElementById('sp-copy');
    if(!notesEl || !btn) return;
    notesEl.select();
    copyTextToClipboard(notesEl.value)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copySubNotes(){
    const btn = document.getElementById('sp-copy-sub');
    if(!notesSubEl || !btn) return;
    notesSubEl.select();
    copyTextToClipboard(notesSubEl.value)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  async function pushNotesToHcp(){
    if(!pushHcpBtn || !estimateNumberInput){ return; }

    const rawNumber = (estimateNumberInput.value || '').trim();
    if(!rawNumber){
      alert('Please enter the Housecall Pro estimate number.');
      estimateNumberInput.focus();
      return;
    }

    const estimateNumber = rawNumber.replace(/[^0-9]/g, '');
    if(!estimateNumber){
      alert('The estimate number must contain at least one digit.');
      estimateNumberInput.focus();
      return;
    }

    const notes = (notesEl && notesEl.value || '').trim();
    const notesSub = (notesSubEl && notesSubEl.value || '').trim();
    const serviceLinesPayload = Array.isArray(lastServiceLines)
      ? lastServiceLines
          .map(item=>({
            title: (item && item.name ? String(item.name).trim() : ''),
            description: (item && item.desc ? String(item.desc).trim() : ''),
          }))
          .filter(item=>item.title || item.description)
      : [];
    if(!notes){
      alert('There are no notes to send yet. Generate notes first.');
      return;
    }

    if(typeof fetch !== 'function'){
      alert('This browser does not support automatic note sending. Please copy the notes manually.');
      return;
    }

    const originalText = pushHcpBtn.textContent;
    pushHcpBtn.disabled = true;
    pushHcpBtn.textContent = 'Pushing...';

    try{
      const payload = {
        estimateNumber,
        notes,
        notesSub,
      };

      if(serviceLinesPayload.length){
        payload.serviceLines = serviceLinesPayload;
      }

      const response = await fetch('https://api.strongclicks.io/webhook/add-notes-to-hcp-estimate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if(!response.ok){
        const text = await response.text();
        throw new Error(text || `Request failed with status ${response.status}`);
      }

      alert('Notes sent to Housecall Pro.');
    }catch(err){
      console.error('Failed to push notes to HCP', err);
      alert('Failed to push notes to Housecall Pro. Please try again.');
    }finally{
      pushHcpBtn.disabled = false;
      pushHcpBtn.textContent = originalText;
    }
  }

  const KEY = 'sp_scope_v1';

  function handleNotesImport(){
    if(!importTextEl){
      return;
    }
    const raw = (importTextEl.value || '').trim();
    if(!raw){
      updateImportStatus('Paste notes to reload.', 'warn');
      return;
    }

    const encoded = extractEmbeddedNotesData(raw);
    const payload = encoded ? decodePayloadFromNotes(encoded) : null;

    if(!payload){
      const legacySnapshot = parseLegacyNotesSnapshot(raw);
      if(!legacySnapshot){
        updateImportStatus('No embedded scope data found in the pasted notes.', 'error');
        return;
      }
      try{
        applySnapshotToState(legacySnapshot);
        updateImportStatus('Scope restored from pasted notes (legacy format).', 'success');
        setGateUnlocked(true);
        return;
      }catch(err){
        console.error('Failed to apply legacy snapshot', err);
        updateImportStatus('Embedded data was invalid or incomplete.', 'error');
        return;
      }
    }

    try{
      applySnapshotToState(payload);
      updateImportStatus('Scope restored from pasted notes.', 'success');
      setGateUnlocked(true);
    }catch(err){
      console.error('Failed to apply snapshot', err);
      updateImportStatus('Embedded data was invalid or incomplete.', 'error');
    }
  }

  function clearImportField(){
    if(importTextEl){
      importTextEl.value = '';
    }
    updateImportStatus('', '');
  }

  function scheduleAutoGenerateNotes(){
    if(isGeneratingNotes){
      return;
    }
    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
    }
    autoGenerateTimer = window.setTimeout(()=>{
      autoGenerateTimer = null;
      if(isGeneratingNotes){
        return;
      }
      try{
        generateNotes({ skipScroll: true });
      }catch(err){
        console.error('Auto note generation failed', err);
      }
    }, 250);
  }

  function persist(){
    if(isGeneratingNotes){
      return;
    }
    scheduleAutoGenerateNotes();
  }

  function restore(){
    try { localStorage.removeItem(KEY); } catch(e){}
    return false;
  }
  function resetAll(){
    if(!confirm('Clear all sections?')) return;
    clearMapDrawing({ skipSections: true });
    state.sections = [];
    localStorage.removeItem(KEY);
    render();
    outputEl.style.display='none';
    renderServiceLineNotes([]);
  }
  window._spInitializeMap = initializeMap;
  if(window._spGoogleMapsReady){
    initializeMap();
  }
  updateMapControlsUI();

  const mapClearBtn = document.getElementById('sp-map-clear');
  if(mapClearBtn){
    mapClearBtn.addEventListener('click', ()=>{
      syncStateFromDOM();
      const hasLinkedSections = state.sections.some(sec=>sec.mapGenerated);
      if(!mapState.polylines.length && !hasLinkedSections) return;
      if(!confirm('Remove all map drawings and linked sections?')) return;
      clearMapDrawing();
    });
  }

  if(mapToggleBtn && mapCardEl){
    setMapCollapsed(mapCardEl.classList.contains('is-collapsed'));
    mapToggleBtn.addEventListener('click', ()=>{
      const next = !mapCardEl.classList.contains('is-collapsed');
      setMapCollapsed(next);
    });
  }

  if(manualOpenBtn && manualModal){
    manualOpenBtn.addEventListener('click', ()=> setManualModal(true));
  }
  if(manualCloseBtn){
    manualCloseBtn.addEventListener('click', ()=> setManualModal(false));
  }
  if(importOpenBtn && importModal){
    importOpenBtn.addEventListener('click', ()=> setImportModal(true));
  }
  if(importCloseBtn){
    importCloseBtn.addEventListener('click', ()=> setImportModal(false));
  }

  if(manualCalcBtn){
    manualCalcBtn.addEventListener('click', updateManualQuote);
  }
  if(manualCostInput){
    manualCostInput.addEventListener('input', ()=> updateManualQuote());
    manualCostInput.addEventListener('keydown', evt=>{
      if(evt.key === 'Enter'){
        evt.preventDefault();
        updateManualQuote();
      }
    });
  }
  if(manualHoursInput){
    manualHoursInput.addEventListener('input', ()=> {
      const raw = manualHoursInput.value || '';
      const cleaned = raw.replace(/[^0-9.]/g, '');
      const parts = cleaned.split('.');
      const normalized = parts.length > 1
        ? `${parts[0]}.${parts.slice(1).join('')}`
        : cleaned;
      if(raw !== normalized){
        manualHoursInput.value = normalized;
      }
      updateManualQuote();
    });
  }

  if(customerTypeSelect){
    customerTypeSelect.addEventListener('change', ()=>{
      customerTypeSelect.value = normalizeCustomerType(customerTypeSelect.value);
      state.customerType = customerTypeSelect.value;
      updatePricingMinimumUI();
      setCustomerTypeConfirmed(false);
      persist();
    });
  }
  if(customerTypeSelect){
    customerTypeSelect.value = normalizeCustomerType(customerTypeSelect.value);
    state.customerType = customerTypeSelect.value;
  }
  updatePricingMinimumUI();
  if(customerConfirmBtn){
    customerConfirmBtn.addEventListener('click', ()=> setCustomerTypeConfirmed(true));
  }

  const quickAddBtn = document.getElementById('sp-quick-add');
  if(quickAddBtn){ quickAddBtn.addEventListener('click', ()=>{ addSection(); persist(); }); }
  const quickDupFirstBtn = document.getElementById('sp-quick-dup-first');
  if(quickDupFirstBtn){ quickDupFirstBtn.addEventListener('click', ()=>{ duplicateFirstSectionStyle(); persist(); }); }
  const quickDupLastBtn = document.getElementById('sp-quick-dup-last');
  if(quickDupLastBtn){ quickDupLastBtn.addEventListener('click', ()=>{ duplicateLatestSectionStyle(); persist(); }); }
  document.getElementById('sp-copy').addEventListener('click', copyNotes);
  document.getElementById('sp-copy-sub').addEventListener('click', copySubNotes);
  if(estimateNumberInput){
    estimateNumberInput.addEventListener('input', ()=>{
      const digits = sanitizeEstimateNumber(estimateNumberInput.value || '');
      if(!digits){
        if(estimateLookupController && typeof estimateLookupController.abort === 'function'){
          estimateLookupController.abort();
          estimateLookupController = null;
        }
        lastEstimateLookupNumber = '';
        lastEstimateAddress = '';
        lastEstimateExists = false;
        updateEstimateStatus('', '');
      }
    });
    estimateNumberInput.addEventListener('keydown', evt=>{
      if(evt.key === 'Enter'){
        evt.preventDefault();
        runEstimateLookup();
      }
    });
  }
  if(estimateLookupBtn){
    estimateLookupBtn.addEventListener('click', ()=>runEstimateLookup());
  }
  if(proceedWithoutEstimateBtn){
    proceedWithoutEstimateBtn.addEventListener('click', ()=>{
      updateEstimateStatus('Proceeding without estimate.', 'info');
      setGateUnlocked(true);
    });
  }
  if(pushHcpBtn){
    pushHcpBtn.addEventListener('click', pushNotesToHcp);
  }
  if(serviceCopyAllBtn){ serviceCopyAllBtn.addEventListener('click', copyAllServiceLines); }
  if(serviceListEl){ serviceListEl.addEventListener('click', handleServiceListClick); }
  if(importBtn){
    importBtn.addEventListener('click', handleNotesImport);
  }
  if(importClearBtn){
    importClearBtn.addEventListener('click', clearImportField);
  }
  document.getElementById('sp-reset').addEventListener('click', resetAll);

  const backTopBtn = document.getElementById('sp-top-btn');
  if (backTopBtn){
    backTopBtn.addEventListener('click', ()=> window.scrollTo({ top: 0, behavior: 'smooth' }));
  }

  const backBottomBtn = document.getElementById('sp-bottom-btn');
  if (backBottomBtn){
    backBottomBtn.addEventListener('click', ()=> window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' }));
  }

  updateManualQuote();

  if(estimateNumberInput && estimateNumberInput.value){
    runEstimateLookup();
  }

  if(!restore()){ addSection(); }
})();
});
</script>
<script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDW2GCWGKbnbA9lA2wPJSmciyMcghOZlxc&libraries=geometry,places,drawing&callback=initMap&loading=async"></script>
</body>
</html>
