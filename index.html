<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scope Generator</title>
  <link rel="icon" type="image/jpeg" sizes="32x32" href="https://cdn.prod.website-files.com/6594928d27a68dfdb6474334/66e8a1e05c9e00dea43e9a1b_Strong-Perimeter-Logo-32.jpg" />
  <style>
  :root{
    --sp-green:#004B3D;
    --sp-ink:#1d1d1f;
    --sp-muted:#6b7280;
    --sp-border:#e5e7eb;
    --sp-bg:#f8fafc;
    --sp-card:#ffffff;
    --sp-radius:14px;
    --sp-stage-bg:#EBEBEB;
  }
  #sp-scope{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";color:var(--sp-ink)}
  #sp-scope *{box-sizing:border-box}

  body{margin:0;background:var(--sp-stage-bg);}
  .sp-container{max-width:1100px;margin:0 auto;padding:24px 24px 40px}
  .sp-header{display:flex;flex-wrap:wrap;align-items:center;gap:12px;justify-content:space-between;margin-bottom:18px}
  .sp-title{font-size:22px;font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px;line-height:1.2}
  .sp-badge{background:var(--sp-green);color:#fff;padding:4px 10px;border-radius:999px;font-size:12px;font-weight:700}

  .sp-actions{display:flex;gap:10px;flex-wrap:wrap}
  .sp-btn{appearance:none;border:1px solid var(--sp-border);background:#fff;color:var(--sp-ink);padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:transform .02s ease,border-color .2s ease,background .2s ease;min-height:44px}
  .sp-btn:active{transform:translateY(1px)}
  .sp-btn.primary{background:var(--sp-green);color:#fff;border-color:var(--sp-green)}
  .sp-btn.ghost{background:#fff}
  .sp-btn.danger{background:#fff;color:#b91c1c;border-color:#fecaca}
  .sp-btn.danger.is-confirm{background:#b91c1c;color:#fff;border-color:#b91c1c}

  .sp-sections{display:grid;gap:16px}
  .sp-card{background:var(--sp-card);border:1px solid var(--sp-border);border-radius:var(--sp-radius);padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  #sp-map-card{margin-bottom:16px}
  #sp-crew-card{margin-top:18px}
  .sp-card-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .sp-card-title{font-size:16px;font-weight:800}
  .sp-card.is-collapsed .sp-grid{display:none}

  .sp-grid{display:grid;gap:12px}
  @media(min-width:720px){
    .sp-grid{grid-template-columns:repeat(12,1fr)}
    .col-6{grid-column:span 6}
    .col-4{grid-column:span 4}
    .col-3{grid-column:span 3}
    .col-2{grid-column:span 2}
    .col-8{grid-column:span 8}
    .col-12{grid-column:span 12}
  }
  @media(max-width:719px){
    .sp-container{padding:20px 16px 36px}
    .sp-header{flex-direction:column;align-items:flex-start;gap:16px}
    .sp-title{font-size:20px}
    .sp-actions{width:100%;flex-direction:column;align-items:stretch}
    .sp-btn{width:100%}
    .sp-sections{gap:12px}
    .sp-card{padding:14px}
    #sp-map-card{margin-bottom:12px}
    #sp-crew-card{margin-top:16px}
    .sp-card-header{flex-direction:column;align-items:flex-start;gap:10px}
    .sp-card-header .sp-row{width:100%;justify-content:flex-start}
    .sp-card-title{font-size:18px}
    .sp-grid{gap:10px}
    .col-6,.col-4,.col-3,.col-2,.col-8,.col-12{grid-column:span 12}
    .sp-copy-row{flex-direction:column}
    .sp-copy-row .sp-btn{width:100%}
    .sp-row{width:100%;justify-content:flex-start}
    .sp-number{width:100%}
  }

  .sp-field{display:flex;flex-direction:column;gap:6px}
  .sp-label{font-size:12px;font-weight:800;color:var(--sp-muted);letter-spacing:.4px;text-transform:uppercase}
  .sp-input,.sp-select,.sp-textarea{border:1px solid var(--sp-border);border-radius:12px;padding:10px 12px;background:#fff;font-size:14px;width:100%}
  .sp-textarea{min-height:68px;resize:vertical}
  .sp-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  /* Rail row (Rails count + all rail blocks on one row, top-aligned) */
  .sp-rail-row{
    display:grid;
    gap:12px;
    align-items:start;
  }
  .sp-rail-row > .sp-field{ align-self:start; }

  @media(min-width:720px){
    .sp-rail-row{ grid-template-columns: var(--rail-cols, repeat(3, minmax(200px,1fr))); }
  }
  @media(max-width:719px){
    .sp-rail-row{ grid-template-columns: 1fr; }
  }

  /* Number control */
  .sp-number{display:flex;align-items:stretch;border:1px solid var(--sp-border);border-radius:12px;overflow:hidden}
  .sp-number input{border:0;flex:1;min-width:0;padding:10px 12px;font-size:14px;-moz-appearance:textfield}
  .sp-number input::-webkit-outer-spin-button,.sp-number input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}
  .sp-step{min-width:46px;font-weight:900;display:grid;place-items:center;border:0;background:var(--sp-bg);cursor:pointer}
  .sp-step:active{filter:brightness(.95)}

  .sp-small{font-size:12px;color:var(--sp-muted)}
  .sp-output{margin-top:18px; display:grid; gap:16px}
  .sp-output textarea{width:100%;min-height:200px;border:1px solid var(--sp-border);border-radius:12px;padding:12px;background:#fff;font-size:14px}
  .sp-service-list{display:grid;gap:14px}
  .sp-service-line{display:grid;gap:12px}
  .sp-copy-row{display:flex;gap:8px;align-items:stretch}
  .sp-copy-row .sp-input,
  .sp-copy-row .sp-textarea{flex:1}
  .sp-copy-row .sp-textarea{min-height:80px}
  .sp-copy-row .sp-btn{white-space:nowrap}
  .sp-hint{font-size:12px;color:var(--sp-muted);margin-top:6px}
  .sp-hint[data-state="loading"]{color:#2563eb}
  .sp-hint[data-state="success"]{color:#047857}
  .sp-hint[data-state="warn"]{color:#b45309}
  .sp-hint[data-state="error"]{color:#b91c1c}
  .sp-divider{height:1px;background:var(--sp-border);margin:12px 0}
  .sp-chip{border:1px dashed var(--sp-border);padding:4px 8px;border-radius:999px;font-size:12px;color:var(--sp-muted)}
  .sp-chip.is-success{background:#ecfdf5;color:#047857;border-color:#bbf7d0}
  .sp-chip.is-error{background:#fef2f2;color:#b91c1c;border-color:#fecaca}
  .sp-chip.is-info{background:#eff6ff;color:#1d4ed8;border-color:#bfdbfe}
  .sp-chip.is-warn{background:#fffbeb;color:#b45309;border-color:#fde68a}
  /* Floating back-to-top button */
  .sp-top{
    position:fixed;
    right:16px;
    bottom:16px;
    z-index:9999;
    border:1px solid var(--sp-border);
    background:var(--sp-card);
    color:var(--sp-ink);
    padding:10px 12px;
    border-radius:999px;
    font-weight:800;
    box-shadow:0 2px 6px rgba(0,0,0,.08);
    cursor:pointer;
  }
  .sp-top:active{ transform:translateY(1px); }
  @media(max-width:719px){
    .sp-top{ right:12px; bottom:12px; }
  }

  #sp-map{
    width:100%;
    height:580px;
    border-radius:12px;
    overflow:hidden;
  }
  .sp-map-note{
    margin-top:8px;
    font-size:12px;
    color:var(--sp-muted);
  }
  .sp-number.is-map-linked{
    background:#f5f3ff;
    border-color:rgba(79,70,229,0.35);
  }
  .sp-number.is-map-linked input{
    background:transparent;
  }
  .sp-number.is-map-linked .sp-step{
    opacity:0.5;
    cursor:not-allowed;
  }
  .sp-btn[disabled]{
    opacity:0.55;
    cursor:not-allowed;
  }
  /* Fence type visibility */
  .sp-card.is-wood [data-wrought-only]{ display:none !important; }
  .sp-card:not(.is-wood) [data-wood-only]{ display:none !important; }
  </style>
</head>
<body>

<div id="sp-scope">
  <div class="sp-container">
    <div class="sp-header">
      <div class="sp-title">Wrought Iron Restoration – Scope Generator</div>
      <div class="sp-actions">
        <button class="sp-btn ghost" id="sp-reset" type="button">Reset</button>
        <button class="sp-btn" id="sp-add" type="button">+ Add Section</button>
        <button class="sp-btn primary" id="sp-complete" type="button">Complete → Generate Notes</button>
      </div>
    </div>

    <div class="sp-small" style="margin-bottom:10px">
      Tip: Use the big + / – buttons on number fields to bump by 1. Add as many sections as you need (front, left side, pool run, etc.).
    </div>

    <div class="sp-card" id="sp-hcp-card" style="margin-bottom:16px">
      <div class="sp-card-header">
        <div class="sp-card-title">Housecall Pro Estimate</div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-12">
          <label class="sp-label" for="sp-estimate-number">Estimate Number from Housecall Pro</label>
          <input class="sp-input" id="sp-estimate-number" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="123456" />
          <div class="sp-row" style="margin-top:8px">
            <button class="sp-btn ghost" id="sp-estimate-lookup" type="button">Fetch Estimate Address</button>
          </div>
          <div class="sp-hint">Enter the estimate number and click “Fetch Estimate Address” to load the service address from Housecall Pro.</div>
          <div class="sp-hint" id="sp-estimate-status" aria-live="polite"></div>
        </div>
      </div>
    </div>

    <div class="sp-card" id="sp-map-card">
      <div class="sp-card-header">
        <div class="sp-card-title">Map Measurements</div>
        <div class="sp-row">
          <button class="sp-btn ghost" id="sp-map-clear" type="button" disabled>Clear Map Sections</button>
        </div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-12">
          <label class="sp-label" for="sp-map-address">Search Address</label>
          <input class="sp-input" id="sp-map-address" type="text" placeholder="Search for a property" autocomplete="off" />
        </div>
        <div class="col-12">
          <div id="sp-map"></div>
          <div class="sp-map-note">Draw polylines to trace each fence run. Segments automatically create scope sections, stay in sync as you edit, and can be cleared with the button above. Right-click a line to remove vertices or delete the entire run.</div>
        </div>
      </div>
    </div>

    <div id="sp-sections" class="sp-sections"></div>

    <div class="sp-card" id="sp-crew-card">
      <div class="sp-card-header">
        <div class="sp-card-title">Crew &amp; Labor</div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-6">
          <label class="sp-label" for="sp-crew-select">Crew Lead</label>
          <select class="sp-select" id="sp-crew-select">
            <option value="in-house-4">In-House 4</option>
            <option value="in-house-3">In-House 3</option>
            <option value="in-house-3-4">In-House 3 &amp; 4</option>
            <option value="robert">Robert</option>
            <option value="jesus">Jesus</option>
            <option value="rodney">Rodney</option>
          </select>
          <div class="sp-hint" id="sp-crew-details"></div>
        </div>
      </div>
    </div>

    <div class="sp-output" id="sp-output" style="display:none">
      <div class="sp-card">
        <div class="sp-card-header">
          <div class="sp-card-title">Notes</div>
          <div class="sp-row">
            <span class="sp-chip" id="sp-totals-chip" title="Auto-calculated across sections">Totals included</span>
            <button class="sp-btn" id="sp-copy" type="button">Copy Notes</button>
            <button class="sp-btn primary" id="sp-push-hcp" type="button">Push Notes to HCP</button>
          </div>
        </div>
        <textarea id="sp-notes" readonly></textarea>
        <div class="sp-hint">These notes are formatted for easy paste into your CRM or internal documentation.</div>
      </div>

      <div class="sp-card" id="sp-sub">
        <div class="sp-card-header">
          <div class="sp-card-title">Notes for Sub</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-sub" type="button">Copy Notes</button>
          </div>
        </div>
        <textarea id="sp-notes-sub" readonly></textarea>
        <div class="sp-hint">Crew-facing summary: duration, materials, and total repairs.</div>
      </div>

      <div class="sp-card" id="sp-service-card" style="display:none">
        <div class="sp-card-header">
          <div class="sp-card-title">Service Line Items</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-service" type="button" disabled>Copy All</button>
          </div>
        </div>
        <div class="sp-service-list" id="sp-service-lines"></div>
        <div class="sp-hint">Use the copy buttons to grab titles or descriptions individually.</div>
      </div>
    </div>
  </div>
</div>

<button class="sp-top" id="sp-top-btn" type="button" aria-label="Back to top">↑ Top</button>
<script src="https://cdn.jsdelivr.net/npm/iframe-resizer/js/iframeResizer.contentWindow.min.js"></script>
<script>
window._spGoogleMapsReady = window._spGoogleMapsReady || false;
window._spInitializeMap = window._spInitializeMap || null;
window.initMap = function(){
  window._spGoogleMapsReady = true;
  if (typeof window._spInitializeMap === 'function') {
    window._spInitializeMap();
  }
};
document.addEventListener('DOMContentLoaded', function(){
  document.title = 'Scope Generator';
  (function setBackground(){
    var root = document.documentElement;
    if(!root) return;
    var href = window.location.href || '';
    if(href.indexOf('https://stagescope.strongperimeter.com/') !== -1){
      root.style.setProperty('--sp-stage-bg', '#fdf5c2');
    } else {
      root.style.setProperty('--sp-stage-bg', '#EBEBEB');
    }
  })();
  // Set favicon
  (function setFavicon(){
    var href = 'https://cdn.prod.website-files.com/6594928d27a68dfdb6474334/66e8a1e05c9e00dea43e9a1b_Strong-Perimeter-Logo-32.jpg';
    var head = document.head || document.getElementsByTagName('head')[0];
    if (!head) return;
    var olds = head.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
    olds.forEach(function(el){ el.parentNode.removeChild(el); });
    var link = document.createElement('link');
    link.rel = 'icon';
    link.type = 'image/jpeg';
    link.sizes = '32x32';
    link.href = href;
    head.appendChild(link);
  })();
(function(){
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  const SEED = {
    style:["Flat Top","Extended Picket","Extended Picket w/ Finials"],
    height:["3ft","4ft","5ft","6ft","8ft"],
    railSize:["1\u201D","1 \u00BC\u201D","1 \u00BD\u201D","1 \u00BE\u201D","1x2\u201D","2\u201D","3\u201D","Flat Bar 1/4\" x 1\""],
    picketSize:["1/2\u201D","5/8\u201D","3/4\u201D","1\u201D"],
    postSize:["1 1/2\" x 1 1/2\"","2x2","3x3","4x4"],
    postRealignSize:["2x2","3x3"],
    puppy:["None","Puppy Pickets","Puppy Pickets w/ Finials","Puppy Pickets Full Height","Puppy Pickets Full Height w/ Finials"],
    // NEW: finials
    finialStyles:["Quad Star","Banana Split","Boy Scout","Ball"],
    finialMaterials:["Cast Iron","Aluminum","Plastic"],
    // NEW: post caps
    capStyles:["Pyramid","Pressed","Ball"],
    capMaterials:["Cast Iron","Plastic","Metal"],
    capPostSizes:["1 1/2\" x 1 1/2\"","2x2","3x3","4x4"],
  };

  const WOOD_PICKET_WIDTHS = ['3.5"','4"','5.5"','6"'];
  const WOOD_RAIL_SIZES = ['2x3','2x4'];
  const WOOD_TRIM_TYPES = ['1x2','1x4','1x4 & 1x2'];
  const SIMPSON_TIE_OPTIONS = ['1 piece','2 piece'];
  const WOOD_POST_CAP_TYPES = ['Dome cap','Flat cap'];
  const WOOD_POST_METHODS = [
    { value: 'cut-weld', label: 'Cut & Weld' },
    { value: 'dig-straighten', label: 'Dig, straighten, add concrete' }
  ];
  const WOOD_POST_INSTALL_METHODS = [
    { value: 'drive', label: 'Drive posts' },
    { value: 'auger', label: 'Auger + set in concrete' }
  ];

  const POST_REALIGN_METHODS = [
    { value: 'concrete', label: 'Concrete' },
    { value: 'cut-weld', label: 'Cut & Weld' }
  ];

  const PUPPY_INSERT_SIZES = ['1/2"','5/8"'];

  const GATE = {
    latchTypes: [
      'Gravity Latch',
      'Short Pool Latch',
      'Tall Pool Latch',
      'Single Lock Box',
      'Double Lock Box'
    ],
    hingeTypes: [
      'Door Hinges',
      'Bat Wing Hinges',
      'Auto Close Hinges'
    ]
  };

  const CREWS = {
    'in-house-4': {
      id: 'in-house-4',
      label: 'In-House 4',
      maxCrew: 4,
      maxWelders: 2,
      minCrew: 4,
      description: '4-man in-house crew (2 welders + 2 helpers). $640/day (fixed).',
      dailyCost(count){
        if(!count || count <= 0) return 0;
        return 640;
      }
    },
    'in-house-3': {
      id: 'in-house-3',
      label: 'In-House 3',
      maxCrew: 3,
      maxWelders: 2,
      minCrew: 3,
      description: '3-man in-house crew (2 welders + 1 helper). $480/day (fixed).',
      dailyCost(count){
        if(!count || count <= 0) return 0;
        return 480;
      }
    },
    'in-house-3-4': {
      id: 'in-house-3-4',
      label: 'In-House 3 & 4',
      maxCrew: 7,
      maxWelders: 4,
      minCrew: 7,
      description: 'Combined in-house crews (4 welders + 3 helpers). $1,120/day (fixed).',
      dailyCost(count){
        if(!count || count <= 0) return 0;
        return 1120;
      }
    },
    robert: {
      id: 'robert',
      label: 'Robert',
      maxCrew: 7,
      maxWelders: 2,
      minCrew: 3,
      description: 'Up to 7 guys (max 2 welders). $1,000/day for 3 crew; +$200 for each additional.',
      dailyCost(count){
        if(!count || count <= 0) return 0;
        const baseRate = 1000;
        if(count <= 3) return baseRate;
        return baseRate + (count - 3) * 200;
      }
    },
    jesus: {
      id: 'jesus',
      label: 'Jesus',
      maxCrew: 4,
      maxWelders: 1,
      minCrew: 1,
      description: 'Up to 4 guys (max 1 welder). $350 for the first, $250 second, $200 third & fourth.',
      dailyCost(count){
        if(!count || count <= 0) return 0;
        const tiers = [0, 350, 250, 200, 200];
        let total = 0;
        for(let i=1;i<=count;i++){
          const rate = tiers[i] != null ? tiers[i] : tiers[tiers.length-1];
          total += rate;
        }
        return total;
      }
    },
    rodney: {
      id: 'rodney',
      label: 'Rodney',
      maxCrew: 2,
      maxWelders: 1,
      minCrew: 1,
      description: 'Up to 2 guys (max 1 welder). $300 for the first, $200 second.',
      dailyCost(count){
        if(!count || count <= 0) return 0;
        const tiers = [0, 300, 200];
        let total = 0;
        for(let i=1;i<=count;i++){
          const rate = tiers[i] != null ? tiers[i] : tiers[tiers.length-1];
          total += rate;
        }
        return total;
      }
    }
  };

  const DEFAULT_CREW_ID = 'jesus';

  const state = { sections: [], crew: DEFAULT_CREW_ID };
  const mapState = {
    map: null,
    drawingManager: null,
    polylines: [],
    geocoder: null,
    autocomplete: null,
    marker: null,
    maxZoomService: null,
    nextPolylineId: 1,
    pendingAddress: '',
  };
  let mapUpdateScheduled = false;

  const sectionsEl = $('#sp-sections');
  const outputEl   = $('#sp-output');
  const notesEl    = $('#sp-notes');
  const notesSubEl = $('#sp-notes-sub');
  const estimateNumberInput = document.getElementById('sp-estimate-number');
  const estimateLookupBtn = document.getElementById('sp-estimate-lookup');
  const mapAddressInput = document.getElementById('sp-map-address');
  const estimateStatusEl = document.getElementById('sp-estimate-status');
  const defaultEstimateStatus = estimateStatusEl ? estimateStatusEl.textContent : '';
  const pushHcpBtn = document.getElementById('sp-push-hcp');
  const serviceCardEl = $('#sp-service-card');
  const serviceListEl = $('#sp-service-lines');
  const serviceCopyAllBtn = $('#sp-copy-service');
  const crewSelectEl = document.getElementById('sp-crew-select');
  const crewDetailsEl = document.getElementById('sp-crew-details');
  const estimateLookupBtnLabel = estimateLookupBtn ? estimateLookupBtn.textContent : '';
  let lastServiceLines = [];
  let autoGenerateTimer = null;
  let isGeneratingNotes = false;
  let estimateLookupController = null;
  let lastEstimateLookupNumber = '';
  let lastEstimateAddress = '';

  function uid(){ return 'sec_' + Math.random().toString(36).slice(2,9); }

  function sanitizeEstimateNumber(value){
    return (value || '').replace(/[^0-9]/g, '');
  }

  function updateCrewUI(){
    const crewDef = getCrewDefinition(state.crew);
    if(crewSelectEl && crewDef){
      crewSelectEl.value = crewDef.id;
    }
    if(crewDetailsEl){
      crewDetailsEl.textContent = crewDetailSummary(crewDef);
    }
  }
  updateCrewUI();

  function updateEstimateStatus(message, state){
    if(!estimateStatusEl){
      return;
    }
    const nextState = state || (message ? 'info' : '');
    if(message){
      estimateStatusEl.textContent = message;
    }else{
      estimateStatusEl.textContent = defaultEstimateStatus || '';
    }
    if(nextState){
      estimateStatusEl.setAttribute('data-state', nextState);
    }else{
      estimateStatusEl.removeAttribute('data-state');
    }
  }

  function formatEstimateAddress(address){
    if(!address || typeof address !== 'object'){
      return '';
    }
    const segments = [];
    if(address.street){
      segments.push(address.street);
    }
    if(address.street_line_2){
      segments.push(address.street_line_2);
    }
    const cityState = [address.city, address.state].filter(Boolean).join(', ');
    if(cityState){
      segments.push(cityState);
    }
    if(address.zip){
      segments.push(address.zip);
    }
    if(address.country && address.country.toLowerCase() !== 'usa' && address.country.toLowerCase() !== 'us'){
      segments.push(address.country);
    }
    return segments.join(', ');
  }

  function extractEstimateAddressPayload(payload){
    if(!payload){
      return { formatted: '', hasAddress: false };
    }

    if(typeof payload === 'string'){
      const formatted = payload.trim();
      return { formatted, hasAddress: !!formatted };
    }

    if(Array.isArray(payload)){
      for(const item of payload){
        const result = extractEstimateAddressPayload(item);
        if(result.hasAddress){
          return result;
        }
      }
      return { formatted: '', hasAddress: false };
    }

    const candidates = [payload];
    ['data', 'result', 'estimate'].forEach(key=>{
      if(payload && payload[key]){
        candidates.push(payload[key]);
      }
    });

    for(const candidate of candidates){
      if(!candidate || typeof candidate !== 'object'){
        continue;
      }
      if(typeof candidate.address === 'string'){
        const formatted = candidate.address.trim();
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      if(candidate.formatted_address){
        const formatted = String(candidate.formatted_address).trim();
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      if(candidate.address && typeof candidate.address === 'object'){
        const formatted = formatEstimateAddress(candidate.address);
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      const streetLike = candidate.street || candidate.address_line_1 || candidate.address1 || candidate.line1;
      const cityLike = candidate.city;
      const stateLike = candidate.state || candidate.region;
      const zipLike = candidate.zip || candidate.postal_code || candidate.zipcode;
      if(streetLike || candidate.street_line_2 || cityLike || stateLike || zipLike){
        const formatted = formatEstimateAddress({
          street: streetLike,
          street_line_2: candidate.street_line_2 || candidate.address_line_2 || candidate.address2 || candidate.line2,
          city: cityLike,
          state: stateLike,
          zip: zipLike,
          country: candidate.country,
        });
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
    }

    return { formatted: '', hasAddress: false };
  }

  function isEstimateNotFound(payload){
    if(!payload || typeof payload !== 'object'){
      return !payload;
    }
    if(payload.found === false || payload.notFound === true){
      return true;
    }
    if(payload.success === false && typeof payload.error === 'string' && payload.error.toLowerCase().includes('not found')){
      return true;
    }
    const nestedKeys = ['data', 'result', 'estimate'];
    return nestedKeys.some(key=>{
      const value = payload[key];
      return value && typeof value === 'object' ? isEstimateNotFound(value) : false;
    });
  }

  function zoomMapToMax(location){
    if(!mapState.map || !location){
      return;
    }
    const fallbackZoom = 21;
    const hasGoogle = typeof google !== 'undefined' && google && google.maps;
    const service = mapState.maxZoomService;
    if(hasGoogle && service && typeof service.getMaxZoomAtLatLng === 'function' && google.maps.MaxZoomStatus){
      service.getMaxZoomAtLatLng(location, result=>{
        if(result && result.status === google.maps.MaxZoomStatus.OK && typeof result.zoom === 'number'){
          mapState.map.setZoom(result.zoom);
        }else{
          mapState.map.setZoom(fallbackZoom);
        }
      });
    }else{
      mapState.map.setZoom(fallbackZoom);
    }
  }

  function focusMapOnAddress(address){
    const value = (address || '').trim();
    if(!value){
      mapState.pendingAddress = '';
      updateMapAddressMarker(null);
      return;
    }
    mapState.pendingAddress = value;
    if(!mapState.map || !mapState.geocoder){
      return;
    }
    mapState.geocoder.geocode({ address: value }, (results, status)=>{
      if(status === 'OK' && results && results[0]){
        const geometry = results[0].geometry || {};
        const viewport = geometry.viewport;
        let loc = geometry.location;
        if(!loc && viewport && typeof viewport.getCenter === 'function'){
          loc = viewport.getCenter();
        }
        if(viewport){
          mapState.map.fitBounds(viewport);
        }
        if(loc){
          mapState.map.setCenter(loc);
          zoomMapToMax(loc);
        }
        if(loc){
          updateMapAddressMarker(loc);
        }
      }else{
        console.warn('Geocode failed for address', value, status);
      }
    });
  }

  function setMapAddressFromEstimate(address){
    if(!address){
      return;
    }
    if(mapAddressInput){
      mapAddressInput.value = address;
    }
    focusMapOnAddress(address);
  }

  async function fetchEstimateByNumber(estimateNumber, options){
    const opts = options || {};
    const signal = opts.signal;
    const response = await fetch('https://api.strongclicks.io/webhook/get-estimate-address', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ estimateNumber }),
      signal,
    });

    if(signal && signal.aborted){
      throw new DOMException('Aborted', 'AbortError');
    }

    if(!response.ok){
      const text = await response.text();
      throw new Error(text || `Estimate lookup failed with status ${response.status}`);
    }

    try{
      return await response.json();
    }catch(err){
      console.error('Failed to parse estimate lookup response', err);
      throw new Error('Received an invalid response while fetching the estimate address.');
    }
  }

  async function lookupEstimateAddress(estimateNumber){
    if(!estimateNumber){
      return;
    }
    if(estimateLookupController && typeof estimateLookupController.abort === 'function'){
      estimateLookupController.abort();
    }
    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
    estimateLookupController = controller;

    updateEstimateStatus('Looking up estimate address…', 'loading');
    if(estimateLookupBtn){
      estimateLookupBtn.disabled = true;
      estimateLookupBtn.textContent = 'Fetching…';
    }

    try{
      const estimate = await fetchEstimateByNumber(estimateNumber, controller ? { signal: controller.signal } : {});
      if(controller && controller.signal && controller.signal.aborted){
        return;
      }
      const addressResult = extractEstimateAddressPayload(estimate);
      if(addressResult.hasAddress){
        const formatted = addressResult.formatted;
        lastEstimateLookupNumber = estimateNumber;
        lastEstimateAddress = formatted;
        if(formatted){
          setMapAddressFromEstimate(formatted);
          updateEstimateStatus('Address loaded from Housecall Pro.', 'success');
        }else{
          updateEstimateStatus('Estimate found but no address was provided.', 'warn');
        }
      }else if(estimate){
        const notFound = isEstimateNotFound(estimate);
        if(notFound){
          lastEstimateLookupNumber = estimateNumber;
          lastEstimateAddress = '';
          updateEstimateStatus('No matching estimate found in Housecall Pro.', 'warn');
        }else{
          lastEstimateLookupNumber = estimateNumber;
          lastEstimateAddress = '';
          updateEstimateStatus('Estimate found but no address was provided.', 'warn');
        }
      }else{
        lastEstimateLookupNumber = estimateNumber;
        lastEstimateAddress = '';
        updateEstimateStatus('No matching estimate found in Housecall Pro.', 'warn');
      }
    }catch(err){
      if(controller && controller.signal && controller.signal.aborted){
        return;
      }
      console.error('Estimate lookup failed', err);
      lastEstimateLookupNumber = '';
      lastEstimateAddress = '';
      updateEstimateStatus('Unable to load estimate address. Please try again.', 'error');
    }finally{
      if(estimateLookupController === controller){
        estimateLookupController = null;
      }
      if(estimateLookupBtn){
        estimateLookupBtn.disabled = false;
        estimateLookupBtn.textContent = estimateLookupBtnLabel || 'Fetch Estimate Address';
      }
    }
  }

  function runEstimateLookup(){
    if(!estimateNumberInput){
      return;
    }
    const digits = sanitizeEstimateNumber(estimateNumberInput.value || '');
    if(!digits){
      lastEstimateLookupNumber = '';
      lastEstimateAddress = '';
      updateEstimateStatus('', '');
      return;
    }
    if(digits === lastEstimateLookupNumber){
      if(lastEstimateAddress && mapAddressInput && !mapAddressInput.value.trim()){
        setMapAddressFromEstimate(lastEstimateAddress);
        updateEstimateStatus('Address loaded from Housecall Pro.', 'success');
      }
      return;
    }
    lookupEstimateAddress(digits);
  }

  function createSectionBase(data={}){
    const scope = data.scopeType || 'repair';
    const defaultPainting = (scope === 'install' || scope === 'replace')
      ? 'Spot Paint Welds'
      : 'Paint Section';
    const base = {
      id: uid(),
      collapsed:false,
      fenceType: 'Wrought Iron',
      railsCount:2,
      rails:[
        {size:SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0},
        {size:SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0},
      ],
      postSize: '2x2',
      postReplacements: [],
      postRealignments: [],
      gapAdditions: [],
      diagonalBraces: [],
      walkGates: 0,
      walkGatesRealign: 0,
      walkGatesHardware: 0,
      walkGatesRebuild: 0,
      walkLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkRebuildFrame: SEED.railSize[0],
      walkRebuildPicket: SEED.picketSize[0],
      walkRebuildLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkRebuildHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkGatesAdd: 0,
      walkAddType: 'Single Swing Walk Gate',
      walkAddPostSize: '2x2',
      walkAddFrameSize: SEED.railSize[0],
      walkAddPicketSize: SEED.picketSize[0],
      walkAddLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkAddHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      scopeType: 'repair',
      postSpacing: '8',
      panelAttachment: 'Welding',
      installFinialStyle: SEED.finialStyles[0],
      finials: [],
      caps: [],
      panels: [],
      puppyInserts: [],
      mapGenerated: false,
      mapSegmentId: '',
      mapGeneratedLabel: '',
      notes: '',
      painting: defaultPainting,
      paintingApplication: 'By Hand',
      woodHeight: '6ft',
      woodStyle: 'Side by Side',
      woodPicketWidth: '5.5"',
      woodRailSize: '2x4',
      woodPost: 'Round Steel',
      woodType: 'Cedar',
      woodFinish: 'Oil Based Stain',
      woodKickBoardSize: '2x6',
      woodKickBoardStack: '1',
      woodTopCapSize: '2x6',
      woodTrimType: '1x4',
      woodRepairPicketReplace: 0,
      woodRepairPicketInstall: 0,
      woodRepairRailReplace: 0,
      woodRepairRailInstall: 0,
      woodRepairPostReplace: 0,
      woodRepairPostReplaceTie: SIMPSON_TIE_OPTIONS[0],
      woodRepairPostReplaceCap: '',
      woodRepairPostRealign: 0,
      woodRepairPostRealignMethod: WOOD_POST_METHODS[1].value,
      woodRepairPostInstall: 0,
      woodRepairPostInstallMethod: WOOD_POST_INSTALL_METHODS[1].value,
      woodRepairPostInstallTie: SIMPSON_TIE_OPTIONS[0],
      woodRepairPanelReplace: 0,
      woodRepairPanelWidth: 8,
      woodRepairWalkGateCount: 0,
      woodRepairWalkGateHinges: false,
      woodRepairWalkGateLatch: false,
      woodRepairWalkGateWood: false,
      woodRepairGateStrengthen: 0,
      woodRepairGateReplace: 0,
      woodRepairTopCapReplaceLf: 0,
      woodRepairTopCapReplaceSize: '2x6',
      woodRepairTrimReplaceLf: 0,
      woodRepairTrimReplaceSize: '1x4',
      woodRepairKickReplaceLf: 0,
      woodRepairKickReplaceSize: '2x6',
      woodRepairKickReplaceStack: '1',
      woodRepairStain: 'none',
      woodRepairStainSides: 'one',
      woodAddKickBoard: false,
      woodAddTopCap: false,
      woodAddTrim: false,
      retainingWallLength: 0,
      retainingWallHeight: 0,
    };
    return { ...base, ...data };
  }

  function isSectionPristine(section){
    if(!section) return false;
    const clean = v => String(v||'').trim();
    return !section.mapGenerated &&
      !clean(section.label) &&
      Number(section.length||0) === 0 &&
      Number(section.hardscape||0) === 0 &&
      Number(section.trim||0) === 0 &&
      Number(section.digOut||0) === 0 &&
      Number(section.walkGates||0) === 0 &&
      clean(section.notes) === '' &&
      (!section.postReplacements || section.postReplacements.length === 0) &&
      (!section.postRealignments || section.postRealignments.length === 0) &&
      (!section.gapAdditions || section.gapAdditions.length === 0) &&
      (!section.diagonalBraces || section.diagonalBraces.length === 0) &&
      (!section.panels || section.panels.length === 0) &&
      (!section.puppyInserts || section.puppyInserts.length === 0) &&
      (!section.finials || section.finials.length === 0) &&
      (!section.caps || section.caps.length === 0);
  }

  function updateMapControlsUI(){
    const clearBtn = document.getElementById('sp-map-clear');
    if(clearBtn){
      const hasLinkedSections = state.sections.some(sec=>sec.mapGenerated);
      clearBtn.disabled = mapState.polylines.length === 0 && !hasLinkedSections;
    }
  }

  function clearMapDrawing(options={}){
    mapState.polylines.forEach(poly=>poly.setMap(null));
    mapState.polylines = [];
    updateMapControlsUI();
    if(!options.skipSections){
      applySegmentsToSections([]);
    }
  }

  function updateMapAddressMarker(location){
    if(typeof google === 'undefined' || !google.maps || !mapState.map){
      return;
    }
    if(!location){
      if(mapState.marker){
        mapState.marker.setMap(null);
      }
      return;
    }
    if(!mapState.marker){
      mapState.marker = new google.maps.Marker({
        map: mapState.map,
        clickable: false,
      });
    }
    mapState.marker.setMap(mapState.map);
    mapState.marker.setPosition(location);
  }

  function scheduleMapSectionsUpdate(){
    if(mapUpdateScheduled) return;
    mapUpdateScheduled = true;
    const run = ()=>{
      mapUpdateScheduled = false;
      refreshSectionsFromMap();
    };
    if(typeof requestAnimationFrame === 'function'){
      requestAnimationFrame(run);
    }else{
      setTimeout(run, 80);
    }
  }

  function refreshSectionsFromMap(){
    if(!mapState.polylines.length){
      updateMapControlsUI();
      applySegmentsToSections([]);
      return;
    }
    if(typeof google === 'undefined' || !google.maps || !google.maps.geometry){
      return;
    }
    mapState.polylines = mapState.polylines.filter(poly=>!!poly.getMap());
    updateMapControlsUI();
    const segments = [];
    mapState.polylines.forEach((polyline, runIndex)=>{
      const path = polyline.getPath();
      if(!path) return;
      const length = path.getLength();
      for(let i=0;i<length-1;i++){
        const start = path.getAt(i);
        const end = path.getAt(i+1);
        if(!start || !end) continue;
        const meters = google.maps.geometry.spherical.computeDistanceBetween(start, end);
        const feet = meters * 3.28084;
        if(!isFinite(feet) || feet <= 0.1) continue;
        const segId = `${polyline.__spPolylineId}:${i}`;
        segments.push({
          id: segId,
          label: `Map Run ${runIndex+1} – Segment ${i+1}`,
          lengthFeet: feet
        });
      }
    });
    applySegmentsToSections(segments);
  }

  function applySegmentsToSections(segments){
    syncStateFromDOM();
    let needsRender = false;
    let manualSections = [];
    const existingMapSections = new Map();
    state.sections.forEach(sec=>{
      if(sec.mapGenerated){
        existingMapSections.set(sec.mapSegmentId, sec);
      }else{
        manualSections.push(sec);
      }
    });

    if(segments.length>0 && manualSections.length===1 && isSectionPristine(manualSections[0])){
      manualSections = [];
      needsRender = true;
    }

    const updatedMapSections = [];
    segments.forEach(segment=>{
      const lengthFeet = Math.round(segment.lengthFeet);
      if(!lengthFeet) return;
      const existing = existingMapSections.get(segment.id);
      if(existing){
        const prevLength = Number(existing.length)||0;
        const prevLabel = existing.label||'';
        const prevGeneratedLabel = existing.mapGeneratedLabel||'';
        if(prevLength !== lengthFeet) needsRender = true;
        existing.length = lengthFeet;
        existing.mapGenerated = true;
        existing.mapSegmentId = segment.id;
        existing.mapGeneratedLabel = segment.label;
        if(!prevLabel.trim() || prevLabel === prevGeneratedLabel || prevLabel.startsWith('Map Run ')){
          if(prevLabel !== segment.label) needsRender = true;
          existing.label = segment.label;
        }
        updatedMapSections.push(existing);
        existingMapSections.delete(segment.id);
      }else{
        const newSection = createSectionBase({
          label: segment.label,
          length: lengthFeet,
          scopeType: 'repair',
          mapGenerated: true,
          mapSegmentId: segment.id,
          mapGeneratedLabel: segment.label,
        });
        updatedMapSections.push(newSection);
        needsRender = true;
      }
    });

    if(existingMapSections.size>0){
      needsRender = true;
    }

    const nextSections = manualSections.concat(updatedMapSections);
    if(needsRender || nextSections.length !== state.sections.length){
      state.sections = nextSections;
      render();
      persist();
    }
  }

  function attachMapPolyline(polyline){
    polyline.__spPolylineId = polyline.__spPolylineId || `poly-${mapState.nextPolylineId++}`;
    mapState.polylines.push(polyline);
    updateMapControlsUI();
    const path = polyline.getPath();
    ['insert_at','set_at','remove_at'].forEach(evt=>{
      google.maps.event.addListener(path, evt, scheduleMapSectionsUpdate);
    });
    google.maps.event.addListener(polyline, 'rightclick', evt=>{
      if(typeof evt.vertex === 'number'){
        path.removeAt(evt.vertex);
        return;
      }
      if(confirm('Remove this fence run?')){
        polyline.setMap(null);
        mapState.polylines = mapState.polylines.filter(p=>p!==polyline);
        scheduleMapSectionsUpdate();
      }
    });
    scheduleMapSectionsUpdate();
  }

  function initializeMap(){
    if(mapState.map) return;
    if(typeof google === 'undefined' || !google.maps || !google.maps.drawing) return;
    const mapEl = document.getElementById('sp-map');
    if(!mapEl) return;
    mapState.map = new google.maps.Map(mapEl, {
      zoom: 11,
      mapTypeId: 'hybrid',
      center: { lat: 32.922, lng: -96.549 },
      zoomControl: true,
      streetViewControl: false,
      mapTypeControl: false,
    });
    mapState.maxZoomService = (typeof google.maps.MaxZoomService === 'function') ? new google.maps.MaxZoomService() : null;
    mapState.drawingManager = new google.maps.drawing.DrawingManager({
      drawingMode: null,
      drawingControl: true,
      drawingControlOptions: {
        position: google.maps.ControlPosition.TOP_CENTER,
        drawingModes: [google.maps.drawing.OverlayType.POLYLINE]
      },
      polylineOptions: {
        editable: true,
        draggable: true,
        strokeColor: '#d97706',
        strokeWeight: 3
      }
    });
    mapState.drawingManager.setMap(mapState.map);
    google.maps.event.addListener(mapState.drawingManager, 'polylinecomplete', polyline=>{
      attachMapPolyline(polyline);
      mapState.drawingManager.setDrawingMode(null);
    });

    mapState.geocoder = new google.maps.Geocoder();
    if(mapState.pendingAddress){
      focusMapOnAddress(mapState.pendingAddress);
    }
    if(mapAddressInput){
      mapState.autocomplete = new google.maps.places.Autocomplete(mapAddressInput);
      mapState.autocomplete.addListener('place_changed', ()=>{
        const place = mapState.autocomplete.getPlace();
        if(place && place.geometry){
          const viewport = place.geometry.viewport;
          let loc = place.geometry.location;
          if(!loc && viewport && typeof viewport.getCenter === 'function'){
            loc = viewport.getCenter();
          }
          if(viewport){
            mapState.map.fitBounds(viewport);
          }
          if(loc){
            mapState.map.setCenter(loc);
            zoomMapToMax(loc);
            updateMapAddressMarker(loc);
          }
        }
      });
      mapAddressInput.addEventListener('keydown', evt=>{
        if(evt.key === 'Enter'){
          evt.preventDefault();
          const value = mapAddressInput.value.trim();
          if(!value || !mapState.geocoder) return;
          mapState.geocoder.geocode({ address: value }, (results, status)=>{
            if(status === 'OK' && results && results[0]){
              const geometry = results[0].geometry || {};
              const viewport = geometry.viewport;
              let loc = geometry.location;
              if(!loc && viewport && typeof viewport.getCenter === 'function'){
                loc = viewport.getCenter();
              }
              if(loc){
                mapState.map.setCenter(loc);
              }
              if(viewport){
                mapState.map.fitBounds(viewport);
              }
              if(loc){
                zoomMapToMax(loc);
                updateMapAddressMarker(loc);
              }else if(viewport && typeof viewport.getCenter === 'function'){
                const center = viewport.getCenter();
                if(center){
                  zoomMapToMax(center);
                  updateMapAddressMarker(center);
                }
              }
            }
          });
        }
      });
      mapAddressInput.addEventListener('input', ()=>{
        if(!mapAddressInput.value.trim()){
          updateMapAddressMarker(null);
        }
      });
    }
    updateMapControlsUI();
  }

  function escapeHtml(t){ return String(t).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function escapeAttr(t){ return escapeHtml(t).replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

  function createSelect(options){
    return options.map(v=>`<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`).join('');
  }

  function numberControl(name, placeholder='', min=0){
    return (
      '<div class="sp-number" data-field="'+name+'">'+
        '<button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>'+
        '<input type="number" inputmode="numeric" step="1" min="'+min+'" value="" placeholder="'+placeholder+'" />'+
        '<button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>'+
      '</div>'
    );
  }

  function sectionTemplate(id, index){
    return `
    <div class="sp-card" data-id="${id}">
      <div class="sp-card-header">
        <div class="sp-card-title">Section ${index+1}</div>
        <div class="sp-row">
          <button class="sp-btn ghost sp-toggle" type="button" aria-expanded="true">Collapse</button>
          <button class="sp-btn ghost sp-dup" type="button">Duplicate</button>
          <button class="sp-btn danger sp-del" type="button">Remove</button>
        </div>
      </div>
      <div class="sp-grid">
        <!-- ========== GROUP: Section Details ========== -->
        <div class="sp-field col-6">
          <label class="sp-label">Section Label (e.g., Front Right, Right Side, Back Right, etc)</label>
          <input class="sp-input" data-field="label" placeholder="Enter a label" />
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Fence Type</label>
          <select class="sp-select" data-field="fenceType">
            <option value="Wrought Iron">Wrought Iron</option>
            <option value="Wood">Wood</option>
            <option value="Chain Link">Chain Link</option>
            <option value="Vinyl">Vinyl</option>
          </select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Section Scope</label>
          <select class="sp-select" data-field="scopeType">
            <option value="repair">Repair Existing</option>
            <option value="replace">Replace Section</option>
            <option value="install">Install New Section</option>
          </select>
        </div>
        <div class="sp-field col-2" data-wood-only>
          <label class="sp-label">Fence Height</label>
          <select class="sp-select" data-field="woodHeight">
            <option value="6ft">6ft</option>
            <option value="8ft">8ft</option>
          </select>
        </div>
        <div class="sp-field col-2" data-wood-only>
          <label class="sp-label">Construction</label>
          <select class="sp-select" data-field="woodStyle">
            <option value="Board on Board">Board on Board</option>
            <option value="Side by Side">Side by Side</option>
          </select>
        </div>
        <div class="sp-field col-2" data-wood-only>
          <label class="sp-label">Picket Width</label>
          <select class="sp-select" data-field="woodPicketWidth">${createSelect(WOOD_PICKET_WIDTHS)}</select>
        </div>
        <div class="sp-field col-2" data-wood-only>
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-field="woodRailSize">${createSelect(WOOD_RAIL_SIZES)}</select>
        </div>
        <div class="sp-field col-3" data-wood-only>
          <label class="sp-label">Posts</label>
          <select class="sp-select" data-field="woodPost">
            <option value="Wood 4x4">Wood 4x4</option>
            <option value="Round Steel">Round Steel</option>
            <option value="Postmaster">Postmaster</option>
          </select>
        </div>
        <div class="sp-field col-3" data-wood-only>
          <label class="sp-label">Wood Type</label>
          <select class="sp-select" data-field="woodType">
            <option value="Cedar">Cedar</option>
            <option value="Pressure Treated">Pressure Treated</option>
          </select>
        </div>
        <div class="sp-field col-2" data-wood-only>
          <label class="sp-label">Finish Type</label>
          <select class="sp-select" data-field="woodFinish">
            <option value="Oil Based Stain">Oil Based Stain</option>
            <option value="Water Based Stain">Water Based Stain</option>
            <option value="Painted">Painted</option>
          </select>
        </div>
        <div class="sp-field col-12" data-wood-only>
          <label class="sp-label">Add-ons</label>
          <div class="sp-row">
            <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddKickBoard" /> Kick Board</label>
            <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddTopCap" /> Top Cap</label>
            <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddTrim" /> Trim</label>
          </div>
        </div>

        <div class="sp-grid col-12" data-wood-only data-kickboard-settings style="display:none">
          <div class="sp-field col-2">
            <label class="sp-label">Kick Board Size</label>
            <select class="sp-select" data-field="woodKickBoardSize">
              <option value="2x6">2x6</option>
              <option value="2x8">2x8</option>
              <option value="2x10">2x10</option>
              <option value="2x12">2x12</option>
            </select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Kick Board Stack Height</label>
            <select class="sp-select" data-field="woodKickBoardStack">
              <option value="1">1 Board</option>
              <option value="2">2 Board Stack</option>
              <option value="3">3 Board Stack</option>
              <option value="4">4 Board Stack</option>
            </select>
          </div>
        </div>

        <div class="sp-grid col-12" data-wood-only data-topcap-settings style="display:none">
          <div class="sp-field col-2">
            <label class="sp-label">Top Cap Size</label>
            <select class="sp-select" data-field="woodTopCapSize">
              <option value="2x6">2x6</option>
              <option value="2x8">2x8</option>
              <option value="2x10">2x10</option>
            </select>
          </div>
        </div>

        <div class="sp-grid col-12" data-wood-only data-trim-settings style="display:none">
          <div class="sp-field col-3">
            <label class="sp-label">Trim Type</label>
            <select class="sp-select" data-field="woodTrimType">${createSelect(WOOD_TRIM_TYPES)}</select>
          </div>
        </div>

        <div class="sp-divider" data-wood-only data-repair-only></div>
        <div class="sp-field col-12" data-wood-only data-repair-only>
          <div class="sp-label">Wood Repair Options</div>
        </div>

        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Picket Replacement</label>
          ${numberControl('woodRepairPicketReplace','0')}
          <div class="sp-hint">Remove damaged pickets and install new ones.</div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Picket Installation</label>
          ${numberControl('woodRepairPicketInstall','0')}
          <div class="sp-hint">Install missing pickets to close gaps.</div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Rail Replacement</label>
          ${numberControl('woodRepairRailReplace','0')}
          <div class="sp-hint">Replace broken rails (${WOOD_RAIL_SIZES.join(' / ')}).</div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Rail Installation</label>
          ${numberControl('woodRepairRailInstall','0')}
          <div class="sp-hint">Add rails where missing (${WOOD_RAIL_SIZES.join(' / ')}).</div>
        </div>

        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Post Replacement</label>
          ${numberControl('woodRepairPostReplace','0')}
          <div class="sp-row">
            <select class="sp-select" data-field="woodRepairPostReplaceTie">${createSelect(SIMPSON_TIE_OPTIONS)}</select>
            <select class="sp-select" data-field="woodRepairPostReplaceCap">
              <option value="">No cap</option>
              ${createSelect(WOOD_POST_CAP_TYPES)}
            </select>
          </div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Post Realignment</label>
          ${numberControl('woodRepairPostRealign','0')}
          <select class="sp-select" data-field="woodRepairPostRealignMethod">
            ${WOOD_POST_METHODS.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}
          </select>
          <div class="sp-hint">Cut &amp; weld only for round steel or Postmaster posts.</div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Post Installation</label>
          ${numberControl('woodRepairPostInstall','0')}
          <div class="sp-row">
            <select class="sp-select" data-field="woodRepairPostInstallMethod">
              ${WOOD_POST_INSTALL_METHODS.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}
            </select>
            <select class="sp-select" data-field="woodRepairPostInstallTie">${createSelect(SIMPSON_TIE_OPTIONS)}</select>
          </div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Panel Replacement</label>
          ${numberControl('woodRepairPanelReplace','0')}
          <input class="sp-input" data-field="woodRepairPanelWidth" type="number" min="1" step="0.1" placeholder="Panel width (ft)" />
          <div class="sp-hint">Most panels are 8 ft wide.</div>
        </div>

        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Walk Gate Repair</label>
          ${numberControl('woodRepairWalkGateCount','0')}
          <div class="sp-row" style="gap:10px; margin-top:6px">
            <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateHinges" /> Replace hinges</label>
            <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateLatch" /> Replace latch</label>
            <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateWood" /> Replace wood</label>
          </div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Walk Gate Strengthen</label>
          ${numberControl('woodRepairGateStrengthen','0')}
          <div class="sp-hint">Add framing (2x4) to beef up the gate.</div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Walk Gate Replace</label>
          ${numberControl('woodRepairGateReplace','0')}
          <div class="sp-hint">Remove and rebuild with new hardware.</div>
        </div>

        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Top Cap Replacement (lf)</label>
          ${numberControl('woodRepairTopCapReplaceLf','0')}
          <select class="sp-select" data-field="woodRepairTopCapReplaceSize">
            <option value="2x6">2x6</option>
            <option value="2x8">2x8</option>
            <option value="2x10">2x10</option>
          </select>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Trim Replacement (lf)</label>
          ${numberControl('woodRepairTrimReplaceLf','0')}
          <select class="sp-select" data-field="woodRepairTrimReplaceSize">${createSelect(WOOD_TRIM_TYPES)}</select>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Kick Board Replacement (lf)</label>
          ${numberControl('woodRepairKickReplaceLf','0')}
          <div class="sp-row">
            <select class="sp-select" data-field="woodRepairKickReplaceSize">
              <option value="2x6">2x6</option>
              <option value="2x8">2x8</option>
              <option value="2x10">2x10</option>
              <option value="2x12">2x12</option>
            </select>
            <select class="sp-select" data-field="woodRepairKickReplaceStack">
              <option value="1">1 Board</option>
              <option value="2">2 Board Stack</option>
              <option value="3">3 Board Stack</option>
              <option value="4">4 Board Stack</option>
            </select>
          </div>
        </div>
        <div class="sp-field col-3" data-wood-only data-repair-only>
          <label class="sp-label">Staining</label>
          <select class="sp-select" data-field="woodRepairStain">
            <option value="none">No staining</option>
            <option value="stain">Stain section</option>
          </select>
          <select class="sp-select" data-field="woodRepairStainSides" style="margin-top:6px">
            <option value="one">Stain 1 side</option>
            <option value="both">Stain both sides</option>
          </select>
        </div>

        <div class="sp-field col-3">
          <label class="sp-label">Section Length (ft)</label>
          ${numberControl('length','e.g., 48')}
        </div>

        <div class="sp-grid col-12" data-retaining-wall data-install-only style="display:none">
          <div class="sp-field col-3">
            <label class="sp-label">Retaining Wall Length (ft)</label>
            ${numberControl('retainingWallLength','0')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Retaining Wall Height (ft)</label>
            <input class="sp-input" data-field="retainingWallHeight" type="number" inputmode="decimal" step="0.1" min="0" placeholder="e.g., 2.5" />
            <div class="sp-hint">Billed at $35/sq ft, $1,500 minimum (materials & labor).</div>
          </div>
        </div>

        <div class="sp-grid col-12" data-wrought-only>
          <div class="sp-field col-2">
            <label class="sp-label">Style</label>
            <select class="sp-select" data-field="style">${createSelect(SEED.style)}</select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Height</label>
            <select class="sp-select" data-field="height">${createSelect(SEED.height)}</select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Post Size</label>
            <select class="sp-select" data-field="postSize">${createSelect(SEED.postSize)}</select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Post Spacing (ft)</label>
            <select class="sp-select" data-field="postSpacing">
              <option value="4">4 ft</option>
              <option value="5">5 ft</option>
              <option value="6">6 ft</option>
              <option value="8">8 ft</option>
              <option value="10">10 ft</option>
            </select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Panel Attachment</label>
            <select class="sp-select" data-field="panelAttachment">
              <option value="Welding">Welding</option>
              <option value="Brackets">Brackets</option>
            </select>
          </div>
          <div class="sp-field col-2" data-install-finials style="display:none">
            <label class="sp-label">Finial Style</label>
            <select class="sp-select" data-field="installFinialStyle">${createSelect(SEED.finialStyles)}</select>
          </div>

          <div class="sp-field col-3">
            <label class="sp-label">LF Over Hardscape</label>
            ${numberControl('hardscape','e.g., 12')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">LF to Trim</label>
            ${numberControl('trim','e.g., 6')}
          </div>
          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label">LF to Dig Out</label>
            ${numberControl('digOut','e.g., 10')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Painting</label>
            <select class="sp-select" data-field="painting">
              <option value="Paint Section">Paint Section</option>
              <option value="Prime and Paint">Prime and Paint</option>
              <option value="Spot Paint Welds">Spot Paint Welds</option>
              <option value="None">None</option>
            </select>
          </div>
          <div class="sp-field col-3" data-painting-application style="display:none">
            <label class="sp-label">Paint Application</label>
            <select class="sp-select" data-field="paintingApplication">
              <option value="By Hand">By Hand</option>
              <option value="Spray">Spray</option>
            </select>
          </div>

          <div class="col-12 sp-divider"></div>

          <!-- ========== GROUP: Rails ========== -->
          <div class="sp-field col-12" data-rails-wrap>
            <div class="sp-rail-row" data-rails-row>
              <div class="sp-field" data-rail-count>
                <label class="sp-label">Rails</label>
                <select class="sp-select" data-field="railsCount">
                  <option value="2">2 Rail</option>
                  <option value="3">3 Rail</option>
                  <option value="4">4 Rail</option>
                </select>
              </div>
            </div>
          </div>

          <!-- ========== GROUP: Pickets & Finials ========== -->
          <div class="sp-field col-3">
            <label class="sp-label">Picket Size</label>
            <select class="sp-select" data-field="picketSize">${createSelect(SEED.picketSize)}</select>
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Picket Height (inches) — leave blank to auto-use fence height</label>
            ${numberControl('picketHeight','e.g., 54')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Puppy Pickets</label>
            <select class="sp-select" data-field="puppy">${createSelect(SEED.puppy)}</select>
          </div>
          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label"># Pickets to Replace</label>
            ${numberControl('wiPickets','0')}
          </div>

        <!-- Finial replacements (kept as a block) -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Finial Replacements</label>
          <div data-finials></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-finial-add>+ Add Finial Replacement</button>
            <span class="sp-hint">Each replacement adds ~30 seconds of labor. Unit cost: $1.25.</span>
          </div>
        </div>

        <!-- ========== GROUP: Posts & Caps ========== -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Replacements</label>
          <div data-post-replacements></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-post-replacement-add>+ Add Post Replacement</button>
            <span class="sp-hint">List each post size and quantity to replace.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Realignments</label>
          <div data-post-realign></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-post-realign-add>+ Add Post Realignment</button>
            <span class="sp-hint">Track leaning posts and choose the realignment method.</span>
          </div>
        </div>

        <!-- Post Cap replacements (kept as a block) -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Cap Replacements</label>
          <div data-caps></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-cap-add>+ Add Cap Replacement</button>
            <span class="sp-hint">Each cap adds ~20 seconds of labor. Pricing varies by size & style.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Diagonal Braces</label>
          <div data-diagonal-braces></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-diagonal-brace-add>+ Add Diagonal Brace</button>
            <span class="sp-hint">Each brace uses 4 ft of picket steel.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Full Rail Gap Fillers</label>
          <div data-gap-additions></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-gap-addition-add>+ Add Full Rail Gap Filler</button>
            <span class="sp-hint">Record each rail size and quantity to close open spans.</span>
          </div>
        </div>

        <div class="col-12 sp-divider"></div>

        <!-- ========== GROUP: Panel Replacements ========== -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Panel Replacements</label>
          <div data-panels></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-panel-add>+ Add Panel Replacement</button>
            <span class="sp-hint">Prefab panel eligible if width ≤ 96&quot; (8 ft), 1&quot; rails, and 1/2&quot; or 5/8&quot; pickets. Install = 30 min per panel; custom build+paint = 1.5 hr per panel.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Puppy Picket Inserts</label>
          <div data-puppy-inserts></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-puppy-insert-add>+ Add Puppy Picket Insert</button>
            <span class="sp-hint">Each insert takes a welder + helper about 30 minutes. Unit cost: $62.59 plus picket plugs.</span>
          </div>
        </div>

        <div class="col-12 sp-divider"></div>

        <!-- ========== GROUP: Gates (unchanged, follows after above groups) ========== -->
        <div class="sp-field col-3" data-repair-only>
          <label class="sp-label"># Walk Gates</label>
          ${numberControl('walkGates','0')}
        </div>
        <div class="sp-field col-12" data-wg-wrap data-repair-only style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gates to Realign</label>
              ${numberControl('walkGatesRealign','0')}
            </div>
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gate Hardware Replacements</label>
              ${numberControl('walkGatesHardware','0')}
            </div>
            <div class="sp-field col-6" data-wg-hw-wrap style="display:none">
              <div class="sp-grid">
                <div class="sp-field col-6">
                  <label class="sp-label">Latch Type</label>
                  <select class="sp-select" data-field="walkLatch">${createSelect(GATE.latchTypes)}</select>
                </div>
                <div class="sp-field col-6">
                  <label class="sp-label">Hinges</label>
                  <select class="sp-select" data-field="walkHinges">${createSelect(GATE.hingeTypes)}</select>
                </div>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gates to Rebuild</label>
              ${numberControl('walkGatesRebuild','0')}
            </div>
            <div class="sp-field col-12" data-wg-rebuild-wrap style="display:none">
              <div class="sp-grid">
                <div class="sp-field col-3">
                  <label class="sp-label">Gate Frame Size</label>
                  <select class="sp-select" data-field="walkRebuildFrame">${createSelect(SEED.railSize)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Gate Picket Size</label>
                  <select class="sp-select" data-field="walkRebuildPicket">${createSelect(SEED.picketSize)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Latch Type</label>
                  <select class="sp-select" data-field="walkRebuildLatch">${createSelect(GATE.latchTypes)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Hinges</label>
                  <select class="sp-select" data-field="walkRebuildHinges">${createSelect(GATE.hingeTypes)}</select>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- NEW: Add a Walk Gate (into existing fence) -->
        <div class="sp-field col-3">
          <label class="sp-label"># Walk Gates to Add</label>
          ${numberControl('walkGatesAdd','0')}
        </div>
        <div class="sp-field col-12" data-wg-add-wrap style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Gate Type</label>
              <select class="sp-select" data-field="walkAddType">
                <option value="Single Swing Walk Gate">Single Swing Walk Gate</option>
                <option value="Double Swing Gate">Double Swing Gate</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Post Size</label>
              <select class="sp-select" data-field="walkAddPostSize">${createSelect(SEED.postSize)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Frame Size</label>
              <select class="sp-select" data-field="walkAddFrameSize">${createSelect(SEED.railSize)}</select>
            </div>
            <div class="sp-field col-3" data-wg-add-pickets>
              <label class="sp-label">Gate Picket Size</label>
              <select class="sp-select" data-field="walkAddPicketSize">${createSelect(SEED.picketSize)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Latch Type</label>
              <select class="sp-select" data-field="walkAddLatch">${createSelect(GATE.latchTypes)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Hinges</label>
              <select class="sp-select" data-field="walkAddHinges">${createSelect(GATE.hingeTypes)}</select>
            </div>
          </div>
          <div class="sp-hint">Single swing: adds 2 labor hours, 1 post, 1 bag concrete, and 2× 12ft rails per rail size. Double swing: adds 3 labor hours, 1 post, 1 bag concrete, and 4× 12ft rails per rail size.</div>
        </div>

        </div>

        <!-- Notes (section-specific) - LAST -->
        <div class="sp-field col-12">
          <label class="sp-label">Notes (section-specific)</label>
          <textarea class="sp-textarea" data-field="notes" placeholder="Any custom notes for this section..."></textarea>
        </div>
      </div>
    </div>`;
  }

  function addSection(data={}){
    syncStateFromDOM();
    state.sections.push(createSectionBase(data));
    render();
  }
  function duplicateSection(id){
    syncStateFromDOM();
    const src = state.sections.find(s=>s.id===id);
    if(!src) return;
    const copy = JSON.parse(JSON.stringify(src));
    copy.id = uid();
    copy.collapsed = false;
    copy.mapGenerated = false;
    delete copy.mapSegmentId;
    delete copy.mapGeneratedLabel;
    state.sections.push(copy);
    render();
  }
  function removeSection(id){
    syncStateFromDOM();
    state.sections = state.sections.filter(s=>s.id!==id);
    render();
  }

  function readSectionFromDOM(card){
    const id = card.getAttribute('data-id');
    function val(field){
      const el = card.querySelector(`[data-field="${field}"]`);
      if(!el) return '';
      if(el.classList.contains('sp-number')){
        return parseInt(el.querySelector('input').value||'0',10) || 0;
      }
      if(el.type==='checkbox'){ return !!el.checked; }
      if(el.tagName==='INPUT' || el.tagName==='TEXTAREA' || el.tagName==='SELECT') return el.value;
      return '';
    }

    const railsCount = parseInt(val('railsCount') || '2', 10);
    const rails = [];
    for(let i=0;i<railsCount;i++){
      rails.push({
        size: val(`railSize_${i}`),
        stacked: !!val(`railStacked_${i}`),
        size2: val(`railSize2_${i}`),
        patches: val(`railPatches_${i}`),
        replacements: val(`railRepl_${i}`)
      });
    }

    // NEW: Finials (dynamic rows)
    const finials = [];
    const finCont = card.querySelector('[data-finials]');
    if (finCont){
      const rows = Array.from(finCont.querySelectorAll('[data-finial-row]'));
      rows.forEach(row => {
        const qty = parseInt((row.querySelector('[data-finial-qty] input')?.value)||'0',10) || 0;
        const style = (row.querySelector('[data-finial-style]')?.value) || (SEED.finialStyles && SEED.finialStyles[0]);
        const material = (row.querySelector('[data-finial-material]')?.value) || (SEED.finialMaterials && SEED.finialMaterials[0]);
        const picketSize = (row.querySelector('[data-finial-picket]')?.value) || (SEED.picketSize && SEED.picketSize[0]);
        if(qty>0){ finials.push({ qty, style, material, picketSize }); }
      });
    }

    const puppyInserts = [];
    const puppyCont = card.querySelector('[data-puppy-inserts]');
    if(puppyCont){
      const rows = Array.from(puppyCont.querySelectorAll('[data-puppy-insert-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-puppy-insert-qty] input')?.value)||'0',10) || 0;
        const picketSize = (row.querySelector('[data-puppy-insert-size]')?.value) || PUPPY_INSERT_SIZES[0];
        if(qty>0){ puppyInserts.push({ qty, picketSize }); }
      });
    }

    // NEW: Caps (dynamic rows)
    const caps = [];
    const capCont = card.querySelector('[data-caps]');
    if (capCont){
      const rows = Array.from(capCont.querySelectorAll('[data-cap-row]'));
      rows.forEach(row => {
        const qty = parseInt((row.querySelector('[data-cap-qty] input')?.value)||'0',10) || 0;
        const style = (row.querySelector('[data-cap-style]')?.value) || (SEED.capStyles && SEED.capStyles[0]);
        const material = (row.querySelector('[data-cap-material]')?.value) || (SEED.capMaterials && SEED.capMaterials[0]);
        const postSize = (row.querySelector('[data-cap-post]')?.value) || (SEED.capPostSizes && SEED.capPostSizes[0]);
        if(qty>0){ caps.push({ qty, style, material, postSize }); }
      });
    }

    // PANELs (dynamic rows)
    const panels = [];
    const panelsCont = card.querySelector('[data-panels]');
    if(panelsCont){
      const rows = Array.from(panelsCont.querySelectorAll('[data-panel-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-panel-qty] input')?.value)||'0',10) || 0;
        const height = (row.querySelector('[data-panel-height]')?.value) || SEED.height[1];
        const style  = (row.querySelector('[data-panel-style]')?.value) || SEED.style[0];
        const railSize = (row.querySelector('[data-panel-rail]')?.value) || SEED.railSize[0];
        const picketSize = (row.querySelector('[data-panel-picket]')?.value) || SEED.picketSize[0];
        const widthIn = parseInt((row.querySelector('[data-panel-width] input')?.value)||'0',10) || 0;
        const hasFinials = /Finials/i.test(style);
        const finialStyle = hasFinials
          ? ((row.querySelector('[data-panel-finial-style]')?.value) || SEED.finialStyles[0])
          : '';
        if(qty>0){ panels.push({ qty, height, style, railSize, picketSize, widthIn, finialStyle }); }
      });
    }

    const gapAdditions = [];
    const gapCont = card.querySelector('[data-gap-additions]');
    if(gapCont){
      const rows = Array.from(gapCont.querySelectorAll('[data-gap-addition-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-gap-addition-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-gap-addition-size]')?.value) || SEED.railSize[0];
        if(qty>0){ gapAdditions.push({ qty, size }); }
      });
    }

    const diagonalBraces = [];
    const braceCont = card.querySelector('[data-diagonal-braces]');
    if(braceCont){
      const rows = Array.from(braceCont.querySelectorAll('[data-diagonal-brace-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-diagonal-brace-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-diagonal-brace-size]')?.value) || SEED.picketSize[0];
        if(qty>0){ diagonalBraces.push({ qty, size }); }
      });
    }

    const postReplacements = [];
    const postRepCont = card.querySelector('[data-post-replacements]');
    if(postRepCont){
      const rows = Array.from(postRepCont.querySelectorAll('[data-post-replacement-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-post-replacement-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-post-replacement-size]')?.value) || SEED.postSize[0];
        if(qty>0){ postReplacements.push({ qty, size }); }
      });
    }

    const postRealignments = [];
    const postRealignCont = card.querySelector('[data-post-realign]');
    if(postRealignCont){
      const rows = Array.from(postRealignCont.querySelectorAll('[data-post-realign-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-post-realign-qty] input')?.value)||'0',10) || 0;
        const rawMethod = (row.querySelector('[data-post-realign-method]')?.value) || 'concrete';
        const method = rawMethod === 'cut-weld' ? 'cut-weld' : 'concrete';
        const size = method === 'cut-weld'
          ? ''
          : ((row.querySelector('[data-post-realign-size]')?.value) || SEED.postRealignSize[0]);
        if(qty>0){
          const entry = { qty, method, size };
          postRealignments.push(entry);
        }
      });
    }

    return {
      id,
      label: val('label').trim(),
      fenceType: val('fenceType') || 'Wrought Iron',
      scopeType: val('scopeType') || 'repair',
      style: val('style'),
      height: val('height'),
      postSize: val('postSize'),
      postSpacing: val('postSpacing'),
      panelAttachment: val('panelAttachment'),
      installFinialStyle: val('installFinialStyle'),
      postReplacements,
      postRealignments,

      railsCount,
      rails,
      gapAdditions,
      diagonalBraces,

      railSize: rails[0]?.size || '',
      railStacked: !!rails[0]?.stacked,
      railSize2: rails[0]?.size2 || '',

      picketSize: val('picketSize'),
      picketHeight: val('picketHeight'),
      puppy: val('puppy'),
      painting: val('painting'),
      paintingApplication: val('paintingApplication'),
      woodHeight: val('woodHeight'),
      woodStyle: val('woodStyle'),
      woodPicketWidth: val('woodPicketWidth'),
      woodRailSize: val('woodRailSize'),
      woodPost: val('woodPost'),
      woodType: val('woodType'),
      woodFinish: val('woodFinish'),
      woodKickBoardSize: val('woodKickBoardSize'),
      woodKickBoardStack: val('woodKickBoardStack'),
      woodTopCapSize: val('woodTopCapSize'),
      woodTrimType: val('woodTrimType'),
      woodRepairPicketReplace: val('woodRepairPicketReplace'),
      woodRepairPicketInstall: val('woodRepairPicketInstall'),
      woodRepairRailReplace: val('woodRepairRailReplace'),
      woodRepairRailInstall: val('woodRepairRailInstall'),
      woodRepairPostReplace: val('woodRepairPostReplace'),
      woodRepairPostReplaceTie: val('woodRepairPostReplaceTie'),
      woodRepairPostReplaceCap: val('woodRepairPostReplaceCap'),
      woodRepairPostRealign: val('woodRepairPostRealign'),
      woodRepairPostRealignMethod: val('woodRepairPostRealignMethod'),
      woodRepairPostInstall: val('woodRepairPostInstall'),
      woodRepairPostInstallMethod: val('woodRepairPostInstallMethod'),
      woodRepairPostInstallTie: val('woodRepairPostInstallTie'),
      woodRepairPanelReplace: val('woodRepairPanelReplace'),
      woodRepairPanelWidth: val('woodRepairPanelWidth'),
      woodRepairWalkGateCount: val('woodRepairWalkGateCount'),
      woodRepairWalkGateHinges: val('woodRepairWalkGateHinges'),
      woodRepairWalkGateLatch: val('woodRepairWalkGateLatch'),
      woodRepairWalkGateWood: val('woodRepairWalkGateWood'),
      woodRepairGateStrengthen: val('woodRepairGateStrengthen'),
      woodRepairGateReplace: val('woodRepairGateReplace'),
      woodRepairTopCapReplaceLf: val('woodRepairTopCapReplaceLf'),
      woodRepairTopCapReplaceSize: val('woodRepairTopCapReplaceSize'),
      woodRepairTrimReplaceLf: val('woodRepairTrimReplaceLf'),
      woodRepairTrimReplaceSize: val('woodRepairTrimReplaceSize'),
      woodRepairKickReplaceLf: val('woodRepairKickReplaceLf'),
      woodRepairKickReplaceSize: val('woodRepairKickReplaceSize'),
      woodRepairKickReplaceStack: val('woodRepairKickReplaceStack'),
      woodRepairStain: val('woodRepairStain'),
      woodRepairStainSides: val('woodRepairStainSides'),
      woodAddKickBoard: val('woodAddKickBoard'),
      woodAddTopCap: val('woodAddTopCap'),
      woodAddTrim: val('woodAddTrim'),
      retainingWallLength: val('retainingWallLength'),
      retainingWallHeight: val('retainingWallHeight'),
      length: val('length'),
      hardscape: val('hardscape'),
      trim: val('trim'),
      digOut: val('digOut'),
      wiPickets: val('wiPickets'),
      walkGates: val('walkGates'),
      walkGatesRealign: val('walkGatesRealign'),
      walkGatesHardware: val('walkGatesHardware'),
      walkGatesRebuild: val('walkGatesRebuild'),
      walkLatch: val('walkLatch'),
      walkHinges: val('walkHinges'),
      walkRebuildFrame: val('walkRebuildFrame'),
      walkRebuildPicket: val('walkRebuildPicket'),
      walkRebuildLatch: val('walkRebuildLatch'),
      walkRebuildHinges: val('walkRebuildHinges'),

      // NEW
      walkGatesAdd: val('walkGatesAdd'),
      walkAddType: val('walkAddType'),
      walkAddPostSize: val('walkAddPostSize'),
      walkAddFrameSize: val('walkAddFrameSize'),
      walkAddPicketSize: val('walkAddPicketSize'),
      walkAddLatch: val('walkAddLatch'),
      walkAddHinges: val('walkAddHinges'),

      // NEW: finials
      finials,
      // NEW: puppy picket inserts
      puppyInserts,
      // NEW: caps
      caps,
      // NEW: panels
      panels,

      mapGenerated: card.dataset.mapGenerated === 'true',
      mapSegmentId: card.dataset.mapSegmentId || '',
      mapGeneratedLabel: card.dataset.mapGeneratedLabel || '',

      notes: val('notes').trim()
    };
  }

  function syncStateFromDOM(){
    if(crewSelectEl){
      const val = crewSelectEl.value || DEFAULT_CREW_ID;
      state.crew = val in CREWS ? val : DEFAULT_CREW_ID;
    }
    const cards = $$('.sp-card', sectionsEl);
    if(!cards.length) return;
    const newSections = cards.map(readSectionFromDOM);
    newSections.forEach(ns=>{
      const old = state.sections.find(s=>s.id===ns.id);
      if(old){
        if('collapsed' in old) ns.collapsed = old.collapsed;
      }
    });
    state.sections = newSections;
  }

  function writeSectionToDOM(card, data){
    function set(field, value){
      const el = card.querySelector(`[data-field="${field}"]`);
      if(!el) return;
      if(el.classList.contains('sp-number')){
        el.querySelector('input').value = value ?? '';
      } else if(el.type==='checkbox'){
        el.checked = Boolean(value);
      } else if(el.tagName==='SELECT' || el.tagName==='INPUT' || el.tagName==='TEXTAREA'){
        el.value = value ?? '';
      }
    }
    card.dataset.mapGenerated = data.mapGenerated ? 'true' : 'false';
    if(data.mapSegmentId){
      card.dataset.mapSegmentId = data.mapSegmentId;
    }else{
      delete card.dataset.mapSegmentId;
    }
    if(data.mapGeneratedLabel){
      card.dataset.mapGeneratedLabel = data.mapGeneratedLabel;
    }else{
      delete card.dataset.mapGeneratedLabel;
    }
    set('label', data.label||'');
    set('fenceType', data.fenceType || 'Wrought Iron');
    set('scopeType', data.scopeType||'repair');
    set('style', data.style||SEED.style[0]);
    set('height', data.height||'4ft');
    set('postSize', data.postSize||'2x2');
    set('postSpacing', data.postSpacing||'8');
    set('panelAttachment', data.panelAttachment||'Welding');
    set('installFinialStyle', data.installFinialStyle||SEED.finialStyles[0]);

    set('railsCount', data.railsCount || 2);
    renderRailsControls(card, data);
    renderGapAdditionsControls(card, data);
    renderDiagonalBracesControls(card, data);

    set('picketSize', data.picketSize||SEED.picketSize[0]);
    set('picketHeight', data.picketHeight||'');
    set('puppy', data.puppy||SEED.puppy[0]);
    const scopeForPaint = data.scopeType || 'repair';
    const attachmentMethod = data.panelAttachment || 'Welding';
    const defaultPainting = (!data.painting && (scopeForPaint === 'install' || scopeForPaint === 'replace'))
      ? (attachmentMethod === 'Brackets' ? 'None' : 'Spot Paint Welds')
      : (data.painting || 'Paint Section');
    set('painting', defaultPainting);
    set('paintingApplication', data.paintingApplication || 'By Hand');
    set('woodHeight', data.woodHeight || '6ft');
    set('woodStyle', data.woodStyle || 'Side by Side');
    set('woodPicketWidth', data.woodPicketWidth || '5.5"');
    set('woodRailSize', data.woodRailSize || '2x4');
    set('woodPost', data.woodPost || 'Round Steel');
    set('woodType', data.woodType || 'Cedar');
    set('woodFinish', data.woodFinish || 'Oil Based Stain');
    set('woodKickBoardSize', data.woodKickBoardSize || '2x6');
    set('woodKickBoardStack', data.woodKickBoardStack || '1');
    set('woodTopCapSize', data.woodTopCapSize || '2x6');
    set('woodTrimType', data.woodTrimType || '1x4');
    set('woodRepairPicketReplace', data.woodRepairPicketReplace || '');
    set('woodRepairPicketInstall', data.woodRepairPicketInstall || '');
    set('woodRepairRailReplace', data.woodRepairRailReplace || '');
    set('woodRepairRailInstall', data.woodRepairRailInstall || '');
    set('woodRepairPostReplace', data.woodRepairPostReplace || '');
    set('woodRepairPostReplaceTie', data.woodRepairPostReplaceTie || SIMPSON_TIE_OPTIONS[0]);
    set('woodRepairPostReplaceCap', data.woodRepairPostReplaceCap || '');
    set('woodRepairPostRealign', data.woodRepairPostRealign || '');
    set('woodRepairPostRealignMethod', data.woodRepairPostRealignMethod || WOOD_POST_METHODS[1].value);
    set('woodRepairPostInstall', data.woodRepairPostInstall || '');
    set('woodRepairPostInstallMethod', data.woodRepairPostInstallMethod || WOOD_POST_INSTALL_METHODS[1].value);
    set('woodRepairPostInstallTie', data.woodRepairPostInstallTie || SIMPSON_TIE_OPTIONS[0]);
    set('woodRepairPanelReplace', data.woodRepairPanelReplace || '');
    set('woodRepairPanelWidth', data.woodRepairPanelWidth || '');
    set('woodRepairWalkGateCount', data.woodRepairWalkGateCount || '');
    set('woodRepairWalkGateHinges', Boolean(data.woodRepairWalkGateHinges));
    set('woodRepairWalkGateLatch', Boolean(data.woodRepairWalkGateLatch));
    set('woodRepairWalkGateWood', Boolean(data.woodRepairWalkGateWood));
    set('woodRepairGateStrengthen', data.woodRepairGateStrengthen || '');
    set('woodRepairGateReplace', data.woodRepairGateReplace || '');
    set('woodRepairTopCapReplaceLf', data.woodRepairTopCapReplaceLf || '');
    set('woodRepairTopCapReplaceSize', data.woodRepairTopCapReplaceSize || data.woodTopCapSize || '2x6');
    set('woodRepairTrimReplaceLf', data.woodRepairTrimReplaceLf || '');
    set('woodRepairTrimReplaceSize', data.woodRepairTrimReplaceSize || data.woodTrimType || WOOD_TRIM_TYPES[1]);
    set('woodRepairKickReplaceLf', data.woodRepairKickReplaceLf || '');
    set('woodRepairKickReplaceSize', data.woodRepairKickReplaceSize || data.woodKickBoardSize || '2x6');
    set('woodRepairKickReplaceStack', data.woodRepairKickReplaceStack || data.woodKickBoardStack || '1');
    set('woodRepairStain', data.woodRepairStain || 'none');
    set('woodRepairStainSides', data.woodRepairStainSides || 'one');
    set('woodAddKickBoard', Boolean(data.woodAddKickBoard));
    set('woodAddTopCap', Boolean(data.woodAddTopCap));
    set('woodAddTrim', Boolean(data.woodAddTrim));
    set('retainingWallLength', data.retainingWallLength || '');
    set('retainingWallHeight', data.retainingWallHeight || '');
    updateWoodAddonsConditional(card);
    set('length', data.length||'');
    set('hardscape', data.hardscape||'');
    set('trim', data.trim||'');
    set('digOut', data.digOut||'');
    set('wiPickets', data.wiPickets||'');
    set('walkGates', data.walkGates||'');
    set('walkGatesRealign', data.walkGatesRealign||'');
    set('walkGatesHardware', data.walkGatesHardware||'');
    set('walkGatesRebuild', data.walkGatesRebuild||'');
    set('walkLatch', data.walkLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkHinges', data.walkHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');
    set('walkRebuildFrame', data.walkRebuildFrame || SEED.railSize[0]);
    set('walkRebuildPicket', data.walkRebuildPicket || SEED.picketSize[0]);
    set('walkRebuildLatch', data.walkRebuildLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkRebuildHinges', data.walkRebuildHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');

    set('walkGatesAdd', data.walkGatesAdd||'');
    set('walkAddType', data.walkAddType || 'Single Swing Walk Gate');
    set('walkAddPostSize', data.walkAddPostSize || data.postSize || '2x2');
    set('walkAddFrameSize', data.walkAddFrameSize || SEED.railSize[0]);
    set('walkAddPicketSize', data.walkAddPicketSize || SEED.picketSize[0]);
    set('walkAddLatch', data.walkAddLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkAddHinges', data.walkAddHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');

    set('notes', data.notes||'');

    // NEW: render post groups
    renderPostReplacementControls(card, data);
    renderPostRealignControls(card, data);
    // NEW: render finial rows
    renderFinialsControls(card, data);
    renderPuppyInsertControls(card, data);
    // NEW: render cap rows
    renderCapsControls(card, data);
    // NEW: render panel rows
    renderPanelsControls(card, data);
    const toggleBtn = card.querySelector('.sp-toggle');
    const isCollapsed = Boolean(data.collapsed);
    card.classList.toggle('is-collapsed', isCollapsed);
    if(toggleBtn){
      toggleBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      toggleBtn.setAttribute('aria-expanded', (!isCollapsed).toString());
    }
  }
  // === NEW: cap row rendering & persistence ===
  function renderPostGroups(card, data, cfg){
    const cont = card.querySelector(cfg.container);
    if(!cont) return;
    cont.innerHTML = '';
    const options = Array.isArray(cfg.options) && cfg.options.length ? cfg.options : SEED.postSize;
    const arr = Array.isArray(data[cfg.prop]) ? data[cfg.prop] : [];

    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute(cfg.rowAttr, '');
      row.innerHTML = `
        <div class="sp-field col-3">
          <label class="sp-label">Qty</label>
          <div class="sp-number" ${cfg.qtyAttr}>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Post Size</label>
          <select class="sp-select" ${cfg.sizeAttr}>${createSelect(options)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" ${cfg.removeAttr} type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector(cfg.sizeSel);
      if(sizeSel){
        sizeSel.value = item.size || options[0];
      }
    });

    const addBtn = card.querySelector(cfg.addBtn);
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s[cfg.prop])) s[cfg.prop] = [];
        const defaultSize = typeof cfg.defaultSize === 'function'
          ? cfg.defaultSize(s)
          : cfg.defaultSize;
        const nextSize = defaultSize || options[0] || '';
        s[cfg.prop].push({ qty: 1, size: nextSize });
        renderPostGroups(card, s, cfg);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest(cfg.removeSel);
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll(cfg.rowSel));
      const row = btn.closest(cfg.rowSel);
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s[cfg.prop])) return;
      if(idx >= 0){
        s[cfg.prop].splice(idx,1);
        renderPostGroups(card, s, cfg);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches(cfg.sizeSel)){
        persistPostGroupsFromDOM(card, cfg);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest(cfg.qtySel)){
        persistPostGroupsFromDOM(card, cfg);
        persist();
      }
    });
    updateMapControlsUI();
  }

  function persistPostGroupsFromDOM(card, cfg){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector(cfg.container);
    const rows = cont ? Array.from(cont.querySelectorAll(cfg.rowSel)) : [];
    const options = Array.isArray(cfg.options) && cfg.options.length ? cfg.options : SEED.postSize;
    s[cfg.prop] = rows.map(row=>{
      const qty = parseInt((row.querySelector(`${cfg.qtySel} input`)?.value)||'0',10) || 0;
      const size = (row.querySelector(cfg.sizeSel)?.value) || options[0] || '';
      return { qty, size };
    });
  }

  function persistPostRealignmentsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-post-realign]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-post-realign-row]')) : [];
    s.postRealignments = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-post-realign-qty] input')?.value)||'0',10) || 0;
      const rawMethod = (row.querySelector('[data-post-realign-method]')?.value) || 'concrete';
      const method = rawMethod === 'cut-weld' ? 'cut-weld' : 'concrete';
      const size = method === 'cut-weld'
        ? ''
        : ((row.querySelector('[data-post-realign-size]')?.value) || SEED.postRealignSize[0] || '');
      return { qty, method, size };
    });
  }

  function renderPostReplacementControls(card, data){
    renderPostGroups(card, data, {
      prop: 'postReplacements',
      container: '[data-post-replacements]',
      rowAttr: 'data-post-replacement-row',
      rowSel: '[data-post-replacement-row]',
      qtyAttr: 'data-post-replacement-qty',
      qtySel: '[data-post-replacement-qty]',
      sizeAttr: 'data-post-replacement-size',
      sizeSel: '[data-post-replacement-size]',
      removeAttr: 'data-post-replacement-remove',
      removeSel: '[data-post-replacement-remove]',
      addBtn: '[data-post-replacement-add]',
      options: SEED.postSize,
      defaultSize: (section)=> section.postSize || SEED.postSize[0]
    });
  }

  function updatePostRealignRowState(row){
    if(!row) return;
    const methodSel = row.querySelector('[data-post-realign-method]');
    const sizeWrap = row.querySelector('[data-post-realign-size-wrap]');
    const sizeSel = row.querySelector('[data-post-realign-size]');
    const method = (methodSel?.value) || 'concrete';
    const isCutWeld = method === 'cut-weld';
    if(sizeWrap){
      sizeWrap.style.display = isCutWeld ? 'none' : '';
    }
    if(sizeSel){
      sizeSel.disabled = isCutWeld;
    }
  }

  function renderPostRealignControls(card, data){
    const cont = card.querySelector('[data-post-realign]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.postRealignments) ? data.postRealignments : [];
    const methodOptions = POST_REALIGN_METHODS.map(opt=>`<option value="${escapeAttr(opt.value)}">${escapeHtml(opt.label)}</option>`).join('');

    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-post-realign-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-post-realign-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Method</label>
          <select class="sp-select" data-post-realign-method>${methodOptions}</select>
        </div>
        <div class="sp-field col-4" data-post-realign-size-wrap>
          <label class="sp-label">Post Size</label>
          <select class="sp-select" data-post-realign-size>${createSelect(SEED.postRealignSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-post-realign-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const methodSel = row.querySelector('[data-post-realign-method]');
      if(methodSel){
        const normalized = String(item.method || 'concrete').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'concrete';
        methodSel.value = normalized;
      }
      const sizeSel = row.querySelector('[data-post-realign-size]');
      if(sizeSel){ sizeSel.value = item.size || SEED.postRealignSize[0]; }
      updatePostRealignRowState(row);
    });

    const addBtn = card.querySelector('[data-post-realign-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.postRealignments)) s.postRealignments = [];
        const defaultSize = SEED.postRealignSize[0] || '2x2';
        s.postRealignments.push({ qty: 1, size: defaultSize, method: 'concrete' });
        renderPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-post-realign-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-post-realign-row]'));
      const row = btn.closest('[data-post-realign-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.postRealignments)) return;
      if(idx >= 0){
        s.postRealignments.splice(idx,1);
        renderPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      const methodSel = e.target.closest('[data-post-realign-method]');
      const sizeSel = e.target.closest('[data-post-realign-size]');
      if(methodSel){
        const row = methodSel.closest('[data-post-realign-row]');
        updatePostRealignRowState(row);
        persistPostRealignmentsFromDOM(card);
        persist();
      } else if(sizeSel){
        persistPostRealignmentsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-post-realign-qty]')){
        persistPostRealignmentsFromDOM(card);
        persist();
      }
    });
  }

  const POST_SIZE_KEY = {
    '1 1/2" x 1 1/2"': 'posts1p5',
    '2x2': 'posts2x2',
    '3x3': 'posts3x3',
    '4x4': 'posts4x4'
  };
  const POST_KEY_LABEL = {
    posts1p5: '1 1/2" x 1 1/2"',
    posts2x2: '2x2',
    posts3x3: '3x3',
    posts4x4: '4x4'
  };
  const CAP_LABEL_RE = /^caps - (.+?) - (.+?) \((.+?)\)$/; // material, style, postSize

  function postSizeKey(size){
    const raw = String(size||'').trim();
    if(POST_SIZE_KEY[raw]) return POST_SIZE_KEY[raw];
    const compact = raw
      .toLowerCase()
      .replace(/×/g,'x')
      .replace(/\s+/g,'')
      .replace(/inch|\"/g,'');
    if(compact === '11/2x11/2' || compact === '1.5x1.5') return 'posts1p5';
    if(compact === '2x2') return 'posts2x2';
    if(compact === '3x3') return 'posts3x3';
    if(compact === '4x4') return 'posts4x4';
    return null;
  }

  function countPostGroups(arr){
    const counts = { posts1p5:0, posts2x2:0, posts3x3:0, posts4x4:0 };
    (Array.isArray(arr) ? arr : []).forEach(item=>{
      const qty = parseInt(item?.qty,10) || 0;
      if(qty <= 0) return;
      if((item?.method || 'concrete') === 'cut-weld') return;
      const key = postSizeKey(item?.size || item?.postSize);
      if(key && Object.prototype.hasOwnProperty.call(counts, key)){
        counts[key] += qty;
      }
    });
    return counts;
  }

  function postKeyToLabel(key){
    return POST_KEY_LABEL[key] || '';
  }

  function countRealignCutWeld(arr){
    let total = 0;
    (Array.isArray(arr) ? arr : []).forEach(item=>{
      const qty = parseInt(item?.qty,10) || 0;
      if(qty <= 0) return;
      if((item?.method || 'concrete') === 'cut-weld'){
        total += qty;
      }
    });
    return total;
  }

  function addPostCounts(target, counts){
    Object.keys(counts).forEach(key=>{
      target[key] = (target[key]||0) + (parseInt(counts[key],10) || 0);
    });
  }

  function renderCapsControls(card, data){
    const cont = card.querySelector('[data-caps]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.caps) ? data.caps : [];
    arr.forEach((c)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-cap-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-cap-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${c.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-cap-style>${createSelect(SEED.capStyles)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Material</label>
          <select class="sp-select" data-cap-material>${createSelect(SEED.capMaterials)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Post Size</label>
          <select class="sp-select" data-cap-post>${createSelect(SEED.capPostSizes)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-cap-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const styleSel = row.querySelector('[data-cap-style]'); if(styleSel) styleSel.value = c.style || SEED.capStyles[0];
      const matSel   = row.querySelector('[data-cap-material]'); if(matSel) matSel.value = c.material || SEED.capMaterials[0];
      const postSel  = row.querySelector('[data-cap-post]'); if(postSel) postSel.value = c.postSize || SEED.capPostSizes[0];
    });

    const addBtn = card.querySelector('[data-cap-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.caps)) s.caps = [];
        s.caps.push({ qty: 1, style: SEED.capStyles[0], material: SEED.capMaterials[0], postSize: SEED.capPostSizes[0] });
        renderCapsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-cap-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-cap-row]'));
      const row = btn.closest('[data-cap-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.caps)) return;
      s.caps.splice(idx,1);
      renderCapsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-cap-style], [data-cap-material], [data-cap-post]')){
        persistCapsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-cap-qty]')){
        persistCapsFromDOM(card);
        persist();
      }
    });
  }

  function persistCapsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-caps]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-cap-row]')) : [];
    s.caps = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-cap-qty] input')?.value)||'0',10) || 0;
      const style = (row.querySelector('[data-cap-style]')?.value) || SEED.capStyles[0];
      const material = (row.querySelector('[data-cap-material]')?.value) || SEED.capMaterials[0];
      const postSize = (row.querySelector('[data-cap-post]')?.value) || SEED.capPostSizes[0];
      return { qty, style, material, postSize };
    });
  }

  // ===== Rails helpers/handlers =====
  function railLabels(count){
    const n = parseInt(count||2,10);
    if(n===4) return ['Top Rail','Second Rail','Third Rail','Bottom Rail'];
    if(n===3) return ['Top Rail','Middle Rail','Bottom Rail'];
    return ['Top Rail','Bottom Rail'];
  }

  function sectionRailSizes(section){
    const sizes = new Set();
    const rails = Array.isArray(section?.rails) ? section.rails : [];
    const count = section?.railsCount || rails.length;
    for(let i=0;i<count;i++){
      const r = rails[i] || {};
      if(r.size) sizes.add(r.size);
      if(r.stacked && r.size2) sizes.add(r.size2);
    }
    const gaps = Array.isArray(section?.gapAdditions) ? section.gapAdditions : [];
    gaps.forEach(g=>{ if(g && g.size) sizes.add(g.size); });
    if(!sizes.size){
      if(section?.railSize) sizes.add(section.railSize);
      if(section?.railStacked && section?.railSize2) sizes.add(section.railSize2);
    }
    return Array.from(sizes).filter(Boolean);
  }

  function renderRailsControls(card, data){
    const row  = card.querySelector('[data-rails-row]');
    if(!row) return;
    $$('[data-rail-block]', row).forEach(el=> el.remove());
    const count = parseInt((data.railsCount!=null?data.railsCount:2),10);
    const labels = railLabels(count);
    const rails = Array.isArray(data.rails) ? data.rails : [];
    row.style.setProperty('--rail-cols', `repeat(${count+1}, minmax(200px, 1fr))`);
    labels.forEach((label,i)=>{
      const block = document.createElement('div');
      block.className = `sp-field`;
      block.setAttribute('data-rail-block','');
      const patchesHtml = numberControl('railPatches_'+i,'0');
      const replHtml    = numberControl('railRepl_'+i,'0');
      block.innerHTML = `
        <label class="sp-label">${label} Size</label>
        <select class="sp-select" data-field="railSize_${i}">${createSelect(SEED.railSize)}</select>
        <div class="sp-row" style="margin-top:6px">
          <label class="sp-row" style="gap:6px; align-items:center">
            <input type="checkbox" data-field="railStacked_${i}" />
            <span>Stacked</span>
          </label>
        </div>
        <div class="sp-field" data-if="railStacked_${i}" style="display:none; margin-top:6px">
          <label class="sp-label">Second ${label} Size</label>
          <select class="sp-select" data-field="railSize2_${i}">${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field" data-rail-repair style="margin-top:6px">
          <label class="sp-label"># Rail Patches (${label})</label>
          ${patchesHtml}
        </div>
        <div class="sp-field" data-rail-repair style="margin-top:6px">
          <label class="sp-label"># Full Rail Replacements (${label})</label>
          ${replHtml}
        </div>
      `;
      row.appendChild(block);
      const r = rails[i] || {};
      const sizeEl    = card.querySelector(`[data-field="railSize_${i}"]`);
      const stackEl   = card.querySelector(`[data-field="railStacked_${i}"]`);
      const size2El   = card.querySelector(`[data-field="railSize2_${i}"]`);
      const patchesBox= card.querySelector(`[data-field="railPatches_${i}"]`);
      const replBox   = card.querySelector(`[data-field="railRepl_${i}"]`);
      if(sizeEl) sizeEl.value = r.size || SEED.railSize[0];
      if(stackEl) stackEl.checked = Boolean(r.stacked);
      if(size2El) size2El.value = r.size2 || SEED.railSize[0];
      if(patchesBox) patchesBox.querySelector('input').value = r.patches || 0;
      if(replBox)    replBox.querySelector('input').value    = r.replacements || 0;
      const cond = card.querySelector(`[data-if="railStacked_${i}"]`);
      if(cond && stackEl) cond.style.display = stackEl.checked ? 'block' : 'none';
    });
  }

  function renderGapAdditionsControls(card, data){
    const cont = card.querySelector('[data-gap-additions]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.gapAdditions) ? data.gapAdditions : [];
    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-gap-addition-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-gap-addition-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-gap-addition-size>${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-gap-addition-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-gap-addition-size]');
      if(sizeSel) sizeSel.value = item.size || SEED.railSize[0];
    });

    const addBtn = card.querySelector('[data-gap-addition-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.gapAdditions)) s.gapAdditions = [];
        s.gapAdditions.push({ qty:1, size: SEED.railSize[0] });
        renderGapAdditionsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-gap-addition-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-gap-addition-row]'));
      const row = btn.closest('[data-gap-addition-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.gapAdditions)) return;
      s.gapAdditions.splice(idx,1);
      renderGapAdditionsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-gap-addition-size]')){
        persistGapAdditionsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-gap-addition-qty]')){
        persistGapAdditionsFromDOM(card);
        persist();
      }
    });
  }

  function persistGapAdditionsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-gap-additions]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-gap-addition-row]')) : [];
    s.gapAdditions = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-gap-addition-qty] input')?.value)||'0',10) || 0;
      const size = (row.querySelector('[data-gap-addition-size]')?.value) || SEED.railSize[0];
      return { qty, size };
    });
  }

  function renderDiagonalBracesControls(card, data){
    const cont = card.querySelector('[data-diagonal-braces]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.diagonalBraces) ? data.diagonalBraces : [];
    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-diagonal-brace-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-diagonal-brace-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Brace Size</label>
          <select class="sp-select" data-diagonal-brace-size>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-diagonal-brace-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-diagonal-brace-size]');
      if(sizeSel) sizeSel.value = item.size || SEED.picketSize[0];
    });

    const addBtn = card.querySelector('[data-diagonal-brace-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.diagonalBraces)) s.diagonalBraces = [];
        const defaultSize = s.picketSize || SEED.picketSize[0];
        s.diagonalBraces.push({ qty:1, size: defaultSize });
        renderDiagonalBracesControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-diagonal-brace-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-diagonal-brace-row]'));
      const row = btn.closest('[data-diagonal-brace-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.diagonalBraces)) return;
      s.diagonalBraces.splice(idx,1);
      renderDiagonalBracesControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-diagonal-brace-size]')){
        persistDiagonalBracesFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-diagonal-brace-qty]')){
        persistDiagonalBracesFromDOM(card);
        persist();
      }
    });
  }

  function persistDiagonalBracesFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-diagonal-braces]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-diagonal-brace-row]')) : [];
    s.diagonalBraces = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-diagonal-brace-qty] input')?.value)||'0',10) || 0;
      const size = (row.querySelector('[data-diagonal-brace-size]')?.value) || SEED.picketSize[0];
      return { qty, size };
    });
  }

  // === NEW: finial row rendering & persistence ===
  // === PANEL REPLACEMENTS: row rendering & persistence ===
  function renderPanelsControls(card, data){
    const cont = card.querySelector('[data-panels]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.panels) ? data.panels : [];

    arr.forEach((p)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-panel-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-panel-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${p.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Height</label>
          <select class="sp-select" data-panel-height>${createSelect(SEED.height)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-panel-style>${createSelect(SEED.style)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-panel-rail>${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-panel-picket>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Panel Width (in)</label>
          <div class="sp-number" data-panel-width>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="1" value="${p.widthIn||96}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3" data-panel-finial-wrap style="display:none">
          <label class="sp-label">Finial Style (26 / panel)</label>
          <select class="sp-select" data-panel-finial-style>${createSelect(SEED.finialStyles)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-panel-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);

      // set defaults
      row.querySelector('[data-panel-height]').value = p.height || SEED.height[1];
      row.querySelector('[data-panel-style]').value  = p.style  || SEED.style[0];
      row.querySelector('[data-panel-rail]').value   = p.railSize || SEED.railSize[0];
      row.querySelector('[data-panel-picket]').value = p.picketSize || SEED.picketSize[0];
      const finWrap = row.querySelector('[data-panel-finial-wrap]');
      const styleSel = row.querySelector('[data-panel-style]');
      const finSel = row.querySelector('[data-panel-finial-style]');
      if(styleSel){
        const show = /Finials/i.test(styleSel.value);
        finWrap.style.display = show ? 'block' : 'none';
      }
      if(finSel){ finSel.value = p.finialStyle || SEED.finialStyles[0]; }
    });

    const addBtn = card.querySelector('[data-panel-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.panels)) s.panels = [];
        s.panels.push({ qty:1, height: SEED.height[1], style: SEED.style[0], railSize: SEED.railSize[0], picketSize: SEED.picketSize[0], widthIn: 96, finialStyle: ''});
        renderPanelsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-panel-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-panel-row]'));
      const row = btn.closest('[data-panel-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.panels)) return;
      s.panels.splice(idx,1);
      renderPanelsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-panel-style], [data-panel-height], [data-panel-rail], [data-panel-picket], [data-panel-finial-style]')){
        // Toggle finial picker visibility
        if(e.target.matches('[data-panel-style]')){
          const wrap = e.target.closest('[data-panel-row]').querySelector('[data-panel-finial-wrap]');
          const show = /Finials/i.test(e.target.value);
          wrap.style.display = show ? 'block' : 'none';
          if(show){
            const finSel = wrap.querySelector('[data-panel-finial-style]');
            if(finSel && !finSel.value){ finSel.value = SEED.finialStyles[0]; }
          }
        }
        persistPanelsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-panel-qty]') || e.target.closest('[data-panel-width]')){
        persistPanelsFromDOM(card);
        persist();
      }
    });
  }

  function persistPanelsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-panels]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-panel-row]')) : [];
    s.panels = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-panel-qty] input')?.value)||'0',10) || 0;
      const height = (row.querySelector('[data-panel-height]')?.value) || SEED.height[1];
      const style  = (row.querySelector('[data-panel-style]')?.value) || SEED.style[0];
      const railSize = (row.querySelector('[data-panel-rail]')?.value) || SEED.railSize[0];
      const picketSize = (row.querySelector('[data-panel-picket]')?.value) || SEED.picketSize[0];
      const widthIn = parseInt((row.querySelector('[data-panel-width] input')?.value)||'0',10) || 0;
      const hasFinials = /Finials/i.test(style);
      const finialStyle = hasFinials
        ? ((row.querySelector('[data-panel-finial-style]')?.value) || SEED.finialStyles[0])
        : '';
      return { qty, height, style, railSize, picketSize, widthIn, finialStyle };
    });
  }
  function renderFinialsControls(card, data){
    const cont = card.querySelector('[data-finials]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.finials) ? data.finials : [];
    arr.forEach((f)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-finial-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-finial-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${f.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-finial-style>${createSelect(SEED.finialStyles)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Material</label>
          <select class="sp-select" data-finial-material>${createSelect(SEED.finialMaterials)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-finial-picket>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-finial-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const styleSel = row.querySelector('[data-finial-style]'); if(styleSel) styleSel.value = f.style || SEED.finialStyles[0];
      const matSel   = row.querySelector('[data-finial-material]'); if(matSel)  matSel.value  = f.material || SEED.finialMaterials[0];
      const pickSel  = row.querySelector('[data-finial-picket]'); if(pickSel)   pickSel.value = f.picketSize || SEED.picketSize[0];
    });

    const addBtn = card.querySelector('[data-finial-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.finials)) s.finials = [];
        s.finials.push({ qty: 1, style: SEED.finialStyles[0], material: SEED.finialMaterials[0], picketSize: s.picketSize || SEED.picketSize[0] });
        renderFinialsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-finial-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-finial-row]'));
      const row = btn.closest('[data-finial-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.finials)) return;
      s.finials.splice(idx,1);
      renderFinialsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-finial-style], [data-finial-material], [data-finial-picket]')){
        persistFinialsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-finial-qty]')){
        persistFinialsFromDOM(card);
        persist();
      }
    });
  }

  function renderPuppyInsertControls(card, data){
    const cont = card.querySelector('[data-puppy-inserts]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.puppyInserts) ? data.puppyInserts : [];
    arr.forEach(item=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-puppy-insert-row','');
      row.innerHTML = `
        <div class="sp-field col-3">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-puppy-insert-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-puppy-insert-size>${createSelect(PUPPY_INSERT_SIZES)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-puppy-insert-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-puppy-insert-size]');
      const normalized = normalizeSize(item.picketSize);
      const preferred = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
      if(sizeSel){ sizeSel.value = preferred; }
    });

    const addBtn = card.querySelector('[data-puppy-insert-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.puppyInserts)) s.puppyInserts = [];
        const normalized = normalizeSize(s.picketSize);
        const defaultSize = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
        s.puppyInserts.push({ qty: 1, picketSize: defaultSize });
        renderPuppyInsertControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-puppy-insert-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-puppy-insert-row]'));
      const row = btn.closest('[data-puppy-insert-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.puppyInserts)) return;
      if(idx>=0){
        s.puppyInserts.splice(idx,1);
        renderPuppyInsertControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-puppy-insert-size]')){
        persistPuppyInsertsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-puppy-insert-qty]')){
        persistPuppyInsertsFromDOM(card);
        persist();
      }
    });
  }

  function persistPuppyInsertsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-puppy-inserts]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-puppy-insert-row]')) : [];
    s.puppyInserts = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-puppy-insert-qty] input')?.value)||'0',10) || 0;
      let picketSize = (row.querySelector('[data-puppy-insert-size]')?.value) || PUPPY_INSERT_SIZES[0];
      const normalized = normalizeSize(picketSize);
      if(PUPPY_INSERT_SIZES.includes(normalized)){
        picketSize = normalized;
      } else {
        picketSize = PUPPY_INSERT_SIZES[0];
      }
      return { qty, picketSize };
    });
  }

  function persistFinialsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-finials]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-finial-row]')) : [];
    s.finials = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-finial-qty] input')?.value)||'0',10) || 0;
      const style = (row.querySelector('[data-finial-style]')?.value) || SEED.finialStyles[0];
      const material = (row.querySelector('[data-finial-material]')?.value) || SEED.finialMaterials[0];
      const picketSize = (row.querySelector('[data-finial-picket]')?.value) || SEED.picketSize[0];
      return { qty, style, material, picketSize };
    });
  }

  function attachRailsHandlers(card){
    const countSel = card.querySelector('[data-field="railsCount"]');
    if(countSel){
      countSel.addEventListener('change', ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId) || {};
        const newCount = parseInt(countSel.value||'2',10);
        s.railsCount = newCount;
        if(!Array.isArray(s.rails)) s.rails = [];
        const labels = railLabels(newCount);
        s.rails = labels.map((_, i)=> s.rails[i] || { size: SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0 });
        renderRailsControls(card, s);
        renderGapAdditionsControls(card, s);
        renderDiagonalBracesControls(card, s);
        attachNumberHandlers(card);
        persist();
      });
    }

    card.addEventListener('change', (e)=>{
      const t = e.target;
      if(!t) return;
      if(t.matches('input[data-field^="railStacked_"]')){
        const key = t.getAttribute('data-field');
        const cond = card.querySelector(`[data-if="${key}"]`);
        if(cond) cond.style.display = t.checked ? 'block' : 'none';
      }
      updateWalkGateConditional(card);
      updateWoodAddonsConditional(card);
      updateWoodRepairControls(card);
      updateInstallConditional(card);
      persist();
    });
  }

  function attachNumberHandlers(card){
    $$(".sp-number", card).forEach(box=>{
      const input = $('input', box);
      $$(".sp-step", box).forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const dir = parseInt(btn.getAttribute('data-dir'),10);
          const current = parseInt(input.value||'0',10) || 0;
          const min = parseInt(input.getAttribute('min')||'0',10) || 0;
          const next = Math.max(min, current + dir);
          input.value = next;
          updateWalkGateConditional(card);
          updateInstallConditional(card);
          persist();
        });
      });
      input.addEventListener('change', ()=>{
        const val = parseInt(input.value||'0',10) || 0;
        const min = parseInt(input.getAttribute('min')||'0',10)||0;
        input.value = Math.max(min, val);
        updateWalkGateConditional(card);
        updateInstallConditional(card);
        persist();
      });
    });
  }

  function allowInstallFinials(style, puppy){
    return /finials/i.test(String(style||'')) || /finials/i.test(String(puppy||''));
  }

  function updatePaintingApplicationUI(card){
    const wrap = card.querySelector('[data-painting-application]');
    if(!wrap) return;
    const paintingSel = card.querySelector('[data-field="painting"]');
    const methodSel = card.querySelector('[data-field="paintingApplication"]');
    const paintingVal = paintingSel ? paintingSel.value : '';
    const show = paintingVal === 'Paint Section' || paintingVal === 'Prime and Paint';
    wrap.style.display = show ? '' : 'none';
    if(show){
      if(methodSel && !methodSel.value){
        methodSel.value = 'By Hand';
      }
    }else if(methodSel && methodSel.value !== 'By Hand'){
      methodSel.value = 'By Hand';
      methodSel.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  function updateInstallConditional(card){
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isInstall = scope === 'install' || scope === 'replace';
    card.querySelectorAll('[data-install-only]').forEach(el=>{
      el.style.display = isInstall ? '' : 'none';
    });
    card.querySelectorAll('[data-repair-only]').forEach(el=>{
      el.style.display = isInstall ? 'none' : '';
    });

    const styleVal = (card.querySelector('[data-field="style"]') || {}).value || '';
    const puppyVal = (card.querySelector('[data-field="puppy"]') || {}).value || '';
    const finialsWrap = card.querySelector('[data-install-finials]');
    if(finialsWrap){
      const showFinials = isInstall && allowInstallFinials(styleVal, puppyVal);
      finialsWrap.style.display = showFinials ? '' : 'none';
      const finSel = card.querySelector('[data-field="installFinialStyle"]');
      if(finSel && showFinials && !finSel.value){
        finSel.value = SEED.finialStyles[0];
      }
    }

    card.querySelectorAll('[data-rail-repair]').forEach(el=>{
      el.style.display = isInstall ? 'none' : '';
      if(isInstall){
        const input = el.querySelector('input');
        if(input){ input.value = '0'; }
      }
    });

    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const showRetainingWall = isInstall && (fenceType === 'wrought iron' || fenceType === 'wood');
    const retainingWrap = card.querySelector('[data-retaining-wall]');
    if(retainingWrap){
      retainingWrap.style.display = showRetainingWall ? '' : 'none';
    }

    const paintingSel = card.querySelector('[data-field="painting"]');
    if(paintingSel){
      const currentVal = paintingSel.value;
      if(isInstall){
        const attachmentSel = card.querySelector('[data-field="panelAttachment"]');
        const usesBrackets = attachmentSel ? attachmentSel.value === 'Brackets' : false;
        const desired = usesBrackets ? 'None' : 'Spot Paint Welds';
        const autoValues = new Set(['', 'Paint Section', 'Spot Paint Welds', 'None']);
        if(autoValues.has(currentVal) && currentVal !== desired){
          paintingSel.value = desired;
          paintingSel.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }
    updatePaintingApplicationUI(card);
  }

  function updateFenceTypeConditional(card){
    const typeSel = card.querySelector('[data-field="fenceType"]');
    const fenceType = (typeSel?.value || 'Wrought Iron').toLowerCase();
    const isWood = fenceType === 'wood';
    card.classList.toggle('is-wood', isWood);
    card.classList.toggle('is-wrought', !isWood);
    if(isWood){
      const defaults = {
        woodHeight: '6ft',
        woodStyle: 'Side by Side',
        woodPicketWidth: '5.5"',
        woodRailSize: '2x4',
        woodPost: 'Round Steel',
        woodType: 'Cedar',
        woodFinish: 'Oil Based Stain',
        woodKickBoardSize: '2x6',
        woodKickBoardStack: '1',
        woodTopCapSize: '2x6',
        woodTrimType: '1x4',
        woodRepairPostRealignMethod: WOOD_POST_METHODS[1].value,
        woodRepairPostInstallMethod: WOOD_POST_INSTALL_METHODS[1].value,
        woodRepairPostReplaceTie: SIMPSON_TIE_OPTIONS[0],
        woodRepairPostInstallTie: SIMPSON_TIE_OPTIONS[0],
        woodRepairTopCapReplaceSize: '2x6',
        woodRepairTrimReplaceSize: '1x4',
        woodRepairKickReplaceSize: '2x6',
        woodRepairKickReplaceStack: '1',
        woodRepairStain: 'none',
        woodRepairStainSides: 'one'
      };
      Object.entries(defaults).forEach(([field, val])=>{
        const el = card.querySelector(`[data-field="${field}"]`);
        if(!el) return;
        if((el.tagName === 'SELECT' || el.tagName === 'INPUT') && !el.value){
          el.value = val;
        }
      });
    }
    updateWoodAddonsConditional(card);
    updateWoodRepairControls(card);
  }

  function updateWoodAddonsConditional(card){
    const checkbox = card.querySelector('[data-field="woodAddKickBoard"]');
    const kickboardDetails = card.querySelector('[data-kickboard-settings]');
    const topCapCheckbox = card.querySelector('[data-field="woodAddTopCap"]');
    const topCapDetails = card.querySelector('[data-topcap-settings]');
    const trimCheckbox = card.querySelector('[data-field="woodAddTrim"]');
    const trimDetails = card.querySelector('[data-trim-settings]');
    const showKickboard = checkbox && checkbox.checked;
    const showTopCap = topCapCheckbox && topCapCheckbox.checked;
    const showTrim = trimCheckbox && trimCheckbox.checked;

    if(kickboardDetails){
      kickboardDetails.style.display = showKickboard ? '' : 'none';
    }
    if(topCapDetails){
      topCapDetails.style.display = showTopCap ? '' : 'none';
    }
    if(trimDetails){
      trimDetails.style.display = showTrim ? '' : 'none';
    }
  }

  function updateWoodRepairControls(card){
    const postType = (card.querySelector('[data-field="woodPost"]')?.value || '').toLowerCase();
    const allowCutWeld = postType === 'round steel' || postType === 'postmaster';
    const realignSel = card.querySelector('[data-field="woodRepairPostRealignMethod"]');
    if(realignSel){
      realignSel.querySelectorAll('option').forEach(opt=>{
        if(opt.value === 'cut-weld'){
          opt.disabled = !allowCutWeld;
        }
      });
      if(!allowCutWeld && realignSel.value === 'cut-weld'){
        realignSel.value = 'dig-straighten';
      }
    }
    const stainSel = card.querySelector('[data-field="woodRepairStain"]');
    const stainSidesSel = card.querySelector('[data-field="woodRepairStainSides"]');
    if(stainSel && stainSidesSel){
      const showSides = stainSel.value === 'stain';
      stainSidesSel.style.display = showSides ? '' : 'none';
      if(!showSides){
        stainSidesSel.value = 'one';
      }
    }
  }

  function updateWalkGateConditional(card){
    const getN = (f)=>{
      const box = card.querySelector(`.sp-number[data-field="${f}"] input`);
      return parseInt((box && box.value) || '0',10) || 0;
    };
    const wg = getN('walkGates');
    const hw = getN('walkGatesHardware');
    const rb = getN('walkGatesRebuild');
    const add = getN('walkGatesAdd');
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isInstall = scope === 'install' || scope === 'replace';

    const wrap = card.querySelector('[data-wg-wrap]');
    if(wrap){ wrap.style.display = (!isInstall && wg>0) ? 'block' : 'none'; }
    const hwWrap = card.querySelector('[data-wg-hw-wrap]');
    if(hwWrap){ hwWrap.style.display = (!isInstall && wg>0 && hw>0) ? 'block' : 'none'; }
    const rbWrap = card.querySelector('[data-wg-rebuild-wrap]');
    if(rbWrap){ rbWrap.style.display = (!isInstall && wg>0 && rb>0) ? 'block' : 'none'; }

    const addWrap = card.querySelector('[data-wg-add-wrap]');
    if(addWrap){ addWrap.style.display = add>0 ? 'block' : 'none'; }
  }

  function applyMapLinkedStateToCard(card, sectionData){
    const lengthControl = card.querySelector('[data-field="length"]');
    if(lengthControl && lengthControl.classList.contains('sp-number')){
      const input = lengthControl.querySelector('input');
      const buttons = lengthControl.querySelectorAll('button');
      if(sectionData.mapGenerated){
        lengthControl.classList.add('is-map-linked');
        if(input){
          input.readOnly = true;
          input.setAttribute('aria-readonly','true');
        }
        buttons.forEach(btn=>{
          btn.disabled = true;
          btn.setAttribute('aria-disabled','true');
        });
      }else{
        lengthControl.classList.remove('is-map-linked');
        if(input){
          input.readOnly = false;
          input.removeAttribute('aria-readonly');
        }
        buttons.forEach(btn=>{
          btn.disabled = false;
          btn.removeAttribute('aria-disabled');
        });
      }
    }

    const removeBtn = card.querySelector('.sp-del');
    if(removeBtn){
      if(sectionData.mapGenerated){
        removeBtn.disabled = true;
        removeBtn.title = 'Remove this run on the map to delete the section';
      }else{
        removeBtn.disabled = false;
        removeBtn.title = '';
      }
    }

    const duplicateBtn = card.querySelector('.sp-dup');
    if(duplicateBtn){
      if(sectionData.mapGenerated){
        duplicateBtn.disabled = true;
        duplicateBtn.title = 'Duplicate not available for map-linked sections';
      }else{
        duplicateBtn.disabled = false;
        duplicateBtn.title = '';
      }
    }

    const actionRow = card.querySelector('.sp-card-header .sp-row');
    if(actionRow){
      let chip = actionRow.querySelector('[data-map-chip]');
      if(sectionData.mapGenerated){
        if(!chip){
          chip = document.createElement('span');
          chip.className = 'sp-chip is-info';
          chip.dataset.mapChip = 'true';
          chip.textContent = 'Map linked';
          actionRow.insertBefore(chip, actionRow.firstChild);
        }
      }else if(chip){
        chip.remove();
      }
    }
  }

  function render(){
    updateCrewUI();
    const sectionsEl = document.getElementById('sp-sections');
    sectionsEl.innerHTML = '';
    state.sections.forEach((s, idx)=>{
      const wrapper = document.createElement('div');
      wrapper.innerHTML = sectionTemplate(s.id, idx);
      const card = wrapper.firstElementChild;
      sectionsEl.appendChild(card);
      writeSectionToDOM(card, s);
      updateFenceTypeConditional(card);
      attachNumberHandlers(card);
      attachRailsHandlers(card);
      updateWalkGateConditional(card);
      updateInstallConditional(card);
      applyMapLinkedStateToCard(card, s);

      const titleEl = $('.sp-card-title', card);
      const labelInput = card.querySelector('[data-field="label"]');
      function refreshTitle(){
        const v = (labelInput.value||'').trim();
        titleEl.textContent = `Section ${idx+1}${v ? ' - ' + v : ''}`;
      }
      refreshTitle();
      labelInput.addEventListener('input', refreshTitle);

      const deleteBtn = $('.sp-del', card);
      if(deleteBtn){
        let confirmTimer = null;
        const resetConfirm = ()=>{
          deleteBtn.dataset.confirm = '';
          deleteBtn.textContent = 'Remove';
          deleteBtn.classList.remove('is-confirm');
          if(confirmTimer){
            clearTimeout(confirmTimer);
            confirmTimer = null;
          }
        };
        deleteBtn.addEventListener('click', ()=>{
          if(deleteBtn.dataset.confirm === 'true'){
            resetConfirm();
            removeSection(s.id);
            persist();
            return;
          }
          deleteBtn.dataset.confirm = 'true';
          deleteBtn.textContent = 'Confirm Remove';
          deleteBtn.classList.add('is-confirm');
          if(confirmTimer){
            clearTimeout(confirmTimer);
          }
          confirmTimer = setTimeout(()=>{ resetConfirm(); }, 4000);
        });
      }
      $('.sp-dup', card).addEventListener('click', ()=>{ duplicateSection(s.id); persist(); });

      const toggleBtn = $('.sp-toggle', card);
      if(toggleBtn){
        toggleBtn.addEventListener('click', ()=>{
          const next = !card.classList.contains('is-collapsed');
          card.classList.toggle('is-collapsed', next);
          toggleBtn.textContent = next ? 'Expand' : 'Collapse';
          toggleBtn.setAttribute('aria-expanded', (!next).toString());
          const sec = state.sections.find(x=>x.id===s.id);
          if(sec){ sec.collapsed = next; }
          persist();
        });
      }

      $$('input, select, textarea', card).forEach(el=>{
        el.addEventListener('input', ()=>{ persist(); });
        el.addEventListener('change', ()=>{
          updateFenceTypeConditional(card);
          updateWalkGateConditional(card);
          updateInstallConditional(card);
          persist();
        });
      });
    });
  }

  function feetFromStr(h){
    const m = String(h||'').match(/(\\d+)/);
    return m ? parseInt(m[1],10) : 0;
  }
  function styleFactor(v){
    if(v === 'Flat Top') return 2;
    if(v === 'Extended Picket') return 1.75;
    return 1.5;
  }
  function railPacePenalty(count){
    const rails = parseInt(count, 10);
    if(!rails || rails <= 2) return 0;
    return (rails - 2) * 0.25;
  }
  function puppyAdj(v){
    if(v === 'Puppy Pickets') return 0.25;
    if(v === 'Puppy Pickets w/ Finials') return 0.5;
    return 0;
  }
  function normalizeLabelText(text){
    return String(text||'')
      .replace(/\u201D|”/g,'"')
      .replace(/\u201C|“/g,'"')
      .replace(/\u2019|’/g,"'")
      .replace(/\u2018|‘/g,"'")
      .replace(/×/g,'x')
      .trim();
  }
  function addMat(map, label, qty){
    if(!qty || qty <= 0) return;
    const cleanLabel = normalizeLabelText(label);
    map[cleanLabel] = (map[cleanLabel]||0) + qty;
  }

  function normalizeSize(txt){
    return String(txt||'')
      .replace(/\\u201D|”/g,'"')
      .replace(/\\u201C|“/g,'"')
      .replace(/\\u00BC|¼/g,'1/4')
      .replace(/\\u00BD|½/g,'1/2')
      .replace(/\\u00BE|¾/g,'3/4')
      .replace(/×/g,'x')
      .trim();
  }

  const PRICE_FT = {
    '1/2\"': 0.57,
    '5/8\"': 0.68,
    '3/4\"': 0.74,
    '1\"':   1.07,
    '1x2\"': 1.65,
    '1 1/2\"': 1.46,
    '1 1/4\"': 1.46,
    '1 3/4\"': 2.57,
    '2x2\"': 2.57,
    '3x3\"': 6.00,
    '4x4': 11.6441666667,
    '2\"': 2.57,
    '3\"': 6.00,
    'Flat Bar 1/4\" x 1\"': 0.58
  };

  const PRICE_MISC = {
    'Gravity Latch': 5,
    'Short Pool Latch': 80,
    'Tall Pool Latch': 90,
    'Single Lock Box': 5,
    'Double Lock Box': 10,
    'Pair of Door Hinges': 5,
    'Pair of Bat Wing Hinges': 5,
    'Pair of Auto Close Hinges': 50,
    // NEW
    'replacement finial': 1.25,
    'puppy picket insert (1/2")': 62.59,
    'puppy picket insert (5/8")': 62.59,
    'picket plugs (1/2")': 0.10,
    'picket plugs (5/8")': 0.11,
    'prefab gate panel': 0,
    'panel mount bracket': 1.27
  };

  const PRICE = {
    paintGallon: 50,
    paintCan: 8,
    primerGallon: 50,
    primerCan: 8,
    concrete: 12,
    post2x2: { 8:18, 9:24 }
  };
  function getCrewDefinition(id){
    return CREWS[id] || CREWS[DEFAULT_CREW_ID];
  }
  function crewCostForCount(crewDef, count){
    if(!crewDef || typeof crewDef.dailyCost !== 'function') return 0;
    return crewDef.dailyCost(count);
  }
  function crewSummary(crewDef){
    if(!crewDef) return 'TBD';
    return `${crewDef.label}`;
  }

  function crewDetailSummary(crewDef){
    if(!crewDef) return 'TBD';
    return `${crewDef.label} – ${crewDef.description}`;
  }
  function money(n){ return Number(n||0).toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }

  const RATES = {
    netTarget:  0.25,
    overhead:   0.0590,
    commission: 0.25,
    cac:        417.34,
    mcor:       0.1067
  };

  function computeChargeRevenue(B1_directCosts){
    const B1 = B1_directCosts;
    const B4 = RATES.netTarget;
    const B5 = RATES.overhead;
    const B6 = RATES.commission;
    const B7 = RATES.cac;
    const B8 = RATES.mcor;

    const denom1 = (1-B4)*(1-B6) - B8 - B5;
    if (denom1 <= 0) return { revenue: NaN, mode: 'invalid' };

    const candidateA = ((1-B4) * B1) / denom1;
    const candidateB = (B1 + 100/B4) / (1 - B6);
    const rev1 = Math.max(candidateA, candidateB);

    if (B8 * rev1 <= B7){
      return { revenue: rev1, mode: 'percent' };
    } else {
      const denom2 = (1-B4)*(1-B6) - B5;
      if (denom2 <= 0) return { revenue: NaN, mode: 'invalid' };
      const candidateC = (((1-B4) * B1) + B7) / denom2;
      const candidateD = (B1 + 75/B4) / (1 - B6);
      const rev2 = Math.max(candidateC, candidateD);
      return { revenue: rev2, mode: 'capped' };
    }
  }

  function generateNotes(eventOrOptions){
    let options = {};
    if(eventOrOptions && typeof eventOrOptions === 'object'){
      if('target' in eventOrOptions || 'currentTarget' in eventOrOptions){
        if(typeof eventOrOptions.preventDefault === 'function'){
          eventOrOptions.preventDefault();
        }
      }else{
        options = eventOrOptions;
      }
    }

    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
      autoGenerateTimer = null;
    }
    if(isGeneratingNotes){
      return;
    }
    isGeneratingNotes = true;

    const shouldScroll = !options.skipScroll;

    try{
      syncStateFromDOM();
      state.sections.forEach(s=>{ delete s._panelCalc; delete s._installCalc; });

    // --- PANEL REPLACEMENT helpers ---
    const PANEL_PRICE = {
      // keyed as: `${feet}ft|p${psize}|style`
      // style key: 'base' for standard/extended (no finials); 'finials' when Extended Picket w/ Finials
      '3|p1/2"|base': 59.91,
      '3|p5/8"|base': 59.91,
      '4|p1/2"|base': 64.48,
      '4|p5/8"|base': 72.11,
      '5|p1/2"|base': 66.39,
      '5|p5/8"|base': 66.39,
      '5|p1/2"|finials': 72.63,
      '5|p5/8"|finials': 91.75,
      '6|p1/2"|base': 76.35,
      '6|p5/8"|base': 91.13,
    };
    function feetFromHeightStr(h){ const m = String(h||'').match(/(\d+)/); return m? parseInt(m[1],10):0; }
    function pkey(feet, picketSize, style){
      const ps = normalizeSize(picketSize);
      const p = (ps==='1/2"')? 'p1/2"' : (ps==='5/8"'? 'p5/8"' : `p${ps}`);
      const sKey = /Finials/i.test(style) ? 'finials' : 'base';
      return `${feet}|${p}|${sKey}`;
    }
    function isPrefabEligible(widthIn, railSize, picketSize){
      const rs = normalizeSize(railSize);
      const ps = normalizeSize(picketSize);
      return (parseInt(widthIn,10)||0) <= 96 && rs === '1"' && (ps==='1/2"' || ps==='5/8"');
    }
    function picketCountForWidth(widthIn, picketSize){
      const gap = 3 + 15/16; // 3.9375
      const ps = normalizeSize(picketSize);
      const widths = { '1/2"': 0.5, '5/8"': 0.625, '3/4"': 0.75, '1"': 1 };
      const pw = widths[ps] || 0.5;
      const stride = pw + gap/12; // inches to feet then combine? keep inches to avoid rounding
      // Work fully in inches
      const strideIn = (pw*1) * 1.0 + 3.9375; // picket width inches + gap inches
      return Math.max(1, Math.floor( (parseFloat(widthIn)||0 + 3.9375) / strideIn ));
    }

    const lines = [];
    const SERVICE_BUCKET_LABELS = {
      installation: 'Wrought Iron Installation',
      replacement: 'Wrought Iron Replacement',
      repairs: 'Wrought Iron Repairs',
      painting: 'Wrought Iron Painting',
      woodRepairs: 'Wood Fence Repairs',
      woodStain: 'Wood Fence Staining'
    };
    const serviceBuckets = Object.keys(SERVICE_BUCKET_LABELS).reduce((acc, key)=>{
      acc[key] = [];
      return acc;
    }, {});
    const SERVICE_NAME_TO_BUCKET = {
      'Wrought Iron Fence Installation': 'installation',
      'Install New Fence Sections': 'installation',
      'Add Single Walk Gate': 'installation',
      'Add Double Walk Gate': 'installation',
      'Wrought Iron Fence Replacement': 'replacement',
      'Remove Fence Sections': 'replacement',
      'Surface Preparation & Painting': 'painting',
      'Dig Out Encroaching Soil': 'repairs',
      'Replace Damaged Pickets': 'repairs',
      'Rail Patch Repairs': 'repairs',
      'Full Rail Replacement': 'repairs',
      'Full Rail Gap Filler': 'repairs',
      'Replace Fence Posts': 'repairs',
      'Realign Leaning Posts': 'repairs',
      'Finial Replacement': 'repairs',
      'Post Cap Replacement': 'repairs',
      'Install Prefab Panels': 'repairs',
      'Build Custom Panels': 'repairs',
      'Realign Walk Gates': 'repairs',
      'Replace Walk Gate Hardware': 'repairs',
      'Rebuild Walk Gates': 'repairs',
      'Add Diagonal Braces': 'repairs',
      'Install Puppy Picket Inserts': 'repairs',
      'Wood Fence Repairs': 'woodRepairs',
      'Wood Fence Staining': 'woodStain'
    };
    function ensureSentence(text){
      const trimmed = (text || '').trim();
      if(!trimmed) return '';
      return /[.!?]$/.test(trimmed) ? trimmed : `${trimmed}.`;
    }
    function addServiceLine(name, desc){
      if(!name || !desc) return;
      const normalizedName = name.trim();
      const bucket = SERVICE_NAME_TO_BUCKET[normalizedName]
        || (normalizedName.includes('Paint') ? 'painting' : 'repairs');
      const sentence = ensureSentence(desc);
      if(!sentence) return;
      if(!serviceBuckets[bucket]){
        serviceBuckets[bucket] = [];
      }
      serviceBuckets[bucket].push(sentence);
    }
    function buildServiceLineOutput(){
      return Object.entries(SERVICE_BUCKET_LABELS)
        .map(([key, label])=>{
          const parts = serviceBuckets[key] || [];
          if(!parts.length) return null;
          return { name: label, desc: parts.join(' ') };
        })
        .filter(Boolean);
    }
    function describeCount(count, singular, plural){
      const n = parseInt(count,10) || 0;
      if(n <= 0) return '';
      const label = n === 1 ? singular : (plural || singular + 's');
      return `${n} ${label}`;
    }
    function joinParts(parts){
      const clean = parts.filter(Boolean);
      if(clean.length === 0) return '';
      if(clean.length === 1) return clean[0];
      if(clean.length === 2) return `${clean[0]} and ${clean[1]}`;
      return `${clean.slice(0,-1).join(', ')}, and ${clean[clean.length-1]}`;
    }
    function formatFtValue(value){
      const n = parseFloat(value);
      if(!isFinite(n) || n <= 0) return '';
      return n
        .toFixed(2)
        .replace(/(\.\d*?)0+$/,'$1')
        .replace(/\.$/,'');
    }
    function buildInstallServiceDescription(sections, includeRemoval){
      if(!Array.isArray(sections) || !sections.length) return '';
      let totalLength = 0;
      const heights = new Set();
      const styles = new Set();
      const rails = new Set();
      const railSizes = new Set();
      const spacing = new Set();
      const postSizes = new Set();
      const styleGroups = new Map();

      sections.forEach(section=>{
        const len = parseInt(section.length,10) || 0;
        totalLength += len;
        if(section.height){ heights.add(String(section.height).trim()); }
        if(section.style){ styles.add(String(section.style).trim()); }
        const groupKey = (()=>{
          const height = section.height ? String(section.height).trim() : '';
          const style = section.style ? String(section.style).trim() : '';
          return JSON.stringify({ height, style });
        })();
        if(!styleGroups.has(groupKey)){
          styleGroups.set(groupKey, {
            length: 0,
            height: section.height ? String(section.height).trim() : '',
            style: section.style ? String(section.style).trim() : '',
            postSizes: new Set(),
            picketSizes: new Set(),
            railSizes: new Set()
          });
        }
        const group = styleGroups.get(groupKey);
        if(len > 0){
          group.length += len;
        }
        const rCount = parseInt(section.railsCount,10) || (Array.isArray(section.rails) ? section.rails.length : 0);
        if(rCount > 0){ rails.add(`${rCount} rail${rCount === 1 ? '' : 's'}`); }
        if(Array.isArray(section.rails) && section.rails.length){
          section.rails.forEach(r=>{
            if(r && r.size){
              const normalized = normalizeSize(r.size);
              railSizes.add(normalized);
              group.railSizes.add(normalized);
            }
            if(r && r.stacked && r.size2){
              const normalized = normalizeSize(r.size2);
              railSizes.add(normalized);
              group.railSizes.add(normalized);
            }
          });
        } else if(section.railSize){
          const normalized = normalizeSize(section.railSize);
          railSizes.add(normalized);
          group.railSizes.add(normalized);
          if(section.railStacked && section.railSize2){
            const normalizedStack = normalizeSize(section.railSize2);
            railSizes.add(normalizedStack);
            group.railSizes.add(normalizedStack);
          }
        }
        if(section.postSize){
          const normalized = normalizeSize(section.postSize);
          postSizes.add(normalized);
          group.postSizes.add(normalized);
        }
        if(section.picketSize){
          group.picketSizes.add(normalizeSize(section.picketSize));
        }
        const spacingCandidate = (section._installCalc && section._installCalc.spacingFt) || parseFloat(section.postSpacing||'');
        const spacingStr = formatFtValue(spacingCandidate);
        if(spacingStr){ spacing.add(spacingStr); }
      });

      const descriptorParts = [];
      if(heights.size){
        const heightLabel = joinParts(Array.from(heights).map(h=> `${h} tall`));
        descriptorParts.push(heightLabel);
      }
      const styleLabel = styles.size ? `${joinParts(Array.from(styles))} fence` : 'wrought iron fence';
      descriptorParts.push(styleLabel);
      const descriptor = descriptorParts.filter(Boolean).join(' ').trim();

      const withParts = [];
      if(rails.size){ withParts.push(joinParts(Array.from(rails))); }
      const withText = withParts.length ? ` with ${joinParts(withParts)}` : '';
      const actionPrefix = includeRemoval ? 'Remove existing fence and install' : 'Install';
      const breakdownParts = Array.from(styleGroups.values())
        .filter(item=>item.length > 0)
        .map(item=>{
          const heightLabel = item.height ? `${item.height} tall` : '';
          const styleLabel = item.style || 'wrought iron';
          const phraseParts = [heightLabel, `${styleLabel}${/fence/i.test(styleLabel)?'':' fence'}`].filter(Boolean);
          const postDetail = item.postSizes.size ? `posts: ${joinParts(Array.from(item.postSizes))}` : '';
          const picketDetail = item.picketSizes.size ? `pickets: ${joinParts(Array.from(item.picketSizes))}` : '';
          const railDetail = item.railSizes.size ? `rails: ${joinParts(Array.from(item.railSizes).map(v=> `${v} stock`))}` : '';
          const detailParts = [postDetail, picketDetail, railDetail].filter(Boolean);
          const detailText = detailParts.length ? ` (${detailParts.join('; ')})` : '';
          return `${item.length}ft of ${phraseParts.join(' ')}${detailText}`;
        });
      let firstSentence = '';
      if(breakdownParts.length){
        firstSentence = `${actionPrefix} ${joinParts(breakdownParts)}${withText}.`;
      } else {
        const lengthText = totalLength > 0 ? `${totalLength}ft` : '';
        firstSentence = lengthText
          ? `${actionPrefix} ${lengthText} of ${descriptor}${withText}.`
          : `${actionPrefix} ${descriptor}${withText}.`;
      }

      const spacingValues = Array.from(spacing).sort((a,b)=> parseFloat(a) - parseFloat(b));
      const railSizeValues = Array.from(railSizes).filter(Boolean);
      const postSizeValues = Array.from(postSizes).filter(Boolean);
      let postsSentence = '';
      const postSizeLabel = postSizeValues.length ? ` (${joinParts(postSizeValues)})` : '';
      if(spacingValues.length){
        if(spacingValues.length === 1){
          postsSentence = `Posts${postSizeLabel} will be spaced ${spacingValues[0]}ft apart and set in concrete 36\" deep.`;
        } else {
          const spacingLabels = spacingValues.map(v=> `${v}ft`);
          postsSentence = `Posts${postSizeLabel} will be spaced between ${joinParts(spacingLabels)} apart and set in concrete 36\" deep.`;
        }
      } else {
        postsSentence = `Posts${postSizeLabel} will be set in concrete 36\" deep.`;
      }

      let railSentence = '';
      if(railSizeValues.length){
        railSentence = `Rails will use ${joinParts(railSizeValues)} stock.`;
      }

      return [firstSentence, postsSentence, railSentence].filter(Boolean).join(' ');
    }
    const zeroPostCounts = ()=>({ posts1p5:0, posts2x2:0, posts3x3:0, posts4x4:0 });
    const totals = {
      length:0, hardscape:0, trim:0, digOut:0, finials:0, caps:0,
      puppyInserts:0,
      diagonalBraces:0,
      wiPickets:0, wiPatches:0, wiRails:0, wiRailGaps:0,
      wiPicketSizes: new Set(),
      wiPatchSizes: new Set(),
      wiRailReplaceSizes: new Set(),
      wiRailGapSizes: new Set(),
      diagonalBraceSizes: new Map(),
      puppyInsertSizes: new Map(),
      woodPicketReplace:0, woodPicketInstall:0, woodRailReplace:0, woodRailInstall:0,
      woodPostReplace6:0, woodPostReplace8:0, woodPostRealignCutWeld:0, woodPostRealignDig:0,
      woodPostInstall:0, woodPanels:0, woodGateRepair:0, woodGateStrengthen:0, woodGateReplace:0,
      woodTopCapLf:0, woodTrimLf:0, woodKickLf:0, woodStainSqft:0,
      posts2x2:0, posts3x3:0, posts1p5:0, posts4x4:0, postsRealign2x2:0, postsRealign3x3:0, postsRealignCutWeld:0,
      walkGates:0, walkRealign:0, walkHardware:0, walkRebuild:0,
      walkGateAdds:0,
      walkGateAddsSingle:0,
      walkGateAddsDouble:0,
      walkGateAddsRepair:0,
      walkGateAddsInstall:0,
      retainingWallSqft:0,
      retainingWallCost:0,
      panelsPrefab:0, panelsCustom:0,
      panelsInstallPrefab:0, panelsInstallCustom:0,
      installSections:0, replaceSections:0,
      removalLf:0, removalCost:0,
      postsInstall: zeroPostCounts(),
      postsReplace: zeroPostCounts()
    };
    const materials = {};
    const installCapsByLabel = new Map();
    const picketStickTotals = {};
    const railStickTotals = {};
    const steelStickTotals = { raw1p5:0, raw3x3:0, raw4x4:0 };
    const diagonalBraceFeetBySize = {};

    const addPicketSticks = (size, qty) => {
      if(!qty || qty <= 0) return;
      const normalized = normalizeSize(size);
      const labelSize = normalized || normalizeLabelText(size);
      addMat(materials, `12ft picket sticks (${labelSize})`, qty);
      if(normalized){
        picketStickTotals[normalized] = (picketStickTotals[normalized]||0) + qty;
      }
    };

    const addRailSticks = (size, qty) => {
      if(!qty || qty <= 0) return;
      const normalized = normalizeSize(size);
      const labelSize = normalized || normalizeLabelText(size);
      addMat(materials, `12ft rail sticks (${labelSize})`, qty);
      if(normalized){
        railStickTotals[normalized] = (railStickTotals[normalized]||0) + qty;
      }
    };
    let manHours = 0;
    let welderHours = 0;
    let helperHours = 0;
    let woodHelperHours = 0;
    let woodWelderHours = 0;
    let woodManHours = 0;
    let woodRequiresTwoPerson = false;

    state.sections.forEach((s, idx)=>{
      const title  = s.label ? `Section ${idx+1} - ${s.label}` : `Section ${idx+1}`;
      const picket = s.picketHeight ? `${s.picketSize} (height ${s.picketHeight} in)` : `${s.picketSize}`;
      const gapAdditionsArr = Array.isArray(s.gapAdditions) ? s.gapAdditions : [];
      const diagonalBracesArr = Array.isArray(s.diagonalBraces) ? s.diagonalBraces : [];
      const braceCountByLabel = new Map();
      let braceTotalQty = 0;
      diagonalBracesArr.forEach(item=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        if(!qty) return;
        braceTotalQty += qty;
        const rawSize = item?.size || '';
        const normalized = normalizeSize(rawSize);
        const label = normalized ? normalizeLabelText(normalized) : normalizeLabelText(rawSize) || rawSize || 'picket steel';
        const displayLabel = label || 'picket steel';
        braceCountByLabel.set(displayLabel, (braceCountByLabel.get(displayLabel)||0) + qty);
        if(normalized){
          const prevCount = totals.diagonalBraceSizes.get(normalized) || 0;
          totals.diagonalBraceSizes.set(normalized, prevCount + qty);
          diagonalBraceFeetBySize[normalized] = (diagonalBraceFeetBySize[normalized]||0) + qty * 4;
        }
      });
      if(braceTotalQty > 0){
        totals.diagonalBraces += braceTotalQty;
      }
      const braceLineParts = [];
      braceCountByLabel.forEach((qty,label)=>{ braceLineParts.push(`${qty} × ${label}`); });

      const railsDesc = (Array.isArray(s.rails) && s.rails.length)
        ? (()=>{
            const labels = railLabels(s.railsCount || s.rails.length);
            return s.rails.slice(0, s.railsCount || s.rails.length).map((r,i)=>
              r && r.stacked
                ? `${labels[i]}: ${r.size} + ${r.size2} (stacked)`
                : `${labels[i]}: ${r.size}`
            ).join('; ');
          })()
        : (s.railStacked ? `${s.railSize} + ${s.railSize2} (stacked)` : `${s.railSize}`);

      const scopeType = (s.scopeType || 'repair');
      const fenceType = (s.fenceType || '').toLowerCase();
      const isInstall = scopeType === 'install' || scopeType === 'replace';
      const isRepair = !isInstall;
      if(scopeType === 'install'){ totals.installSections += 1; }
      if(scopeType === 'replace'){ totals.replaceSections += 1; }

      let installInfo = null;
      if(isInstall){
        const lengthFt = parseInt(s.length||0,10) || 0;
        const spacingRaw = parseFloat(s.postSpacing||'8');
        const spacingFt = (isFinite(spacingRaw) && spacingRaw > 0) ? spacingRaw : 8;
        let spanCount = 0;
        if(lengthFt > 0){ spanCount = Math.max(1, Math.ceil(lengthFt / spacingFt)); }
        const postsTotal = spanCount > 0 ? spanCount + 1 : (lengthFt > 0 ? 2 : 0);
        const installCounts = zeroPostCounts();
        const pKey = postSizeKey(s.postSize);
        if(pKey){ installCounts[pKey] = postsTotal; }
        addPostCounts(totals.postsInstall, installCounts);
        addPostCounts(totals, installCounts);

        const panelWidths = [];
        if(spanCount > 0){
          const standardWidthIn = Math.max(12, Math.round(spacingFt * 12));
          for(let iPanel=0; iPanel<spanCount; iPanel++){
            if(iPanel === spanCount - 1){
              const consumed = spacingFt * (spanCount - 1);
              const remainingFt = lengthFt - consumed;
              const widthIn = Math.max(12, Math.round((remainingFt>0 ? remainingFt : spacingFt) * 12));
              panelWidths.push(widthIn);
            } else {
              panelWidths.push(standardWidthIn);
            }
          }
        }

        const finialStyle = allowInstallFinials(s.style, s.puppy)
          ? (s.installFinialStyle || SEED.finialStyles[0])
          : '';

        const gateAddsForInstall = parseInt(s.walkGatesAdd||0,10) || 0;
        const gatePostKey = postSizeKey(s.walkAddPostSize || s.postSize);
        if(gateAddsForInstall>0 && gatePostKey){
          installCounts[gatePostKey] = (installCounts[gatePostKey]||0) + gateAddsForInstall;
        }

        installInfo = {
          lengthFt,
          spacingFt,
          spanCount,
          postsTotal,
          postCounts: installCounts,
          panelWidths,
          attachment: s.panelAttachment || 'Welding',
          finialStyle,
          removalCost: 0
        };

        if(gateAddsForInstall>0){
          installInfo.postsTotal += gateAddsForInstall;
        }

        if(scopeType === 'replace' && lengthFt > 0){
          const removalCost = lengthFt * 3.9;
          installInfo.removalCost = removalCost;
          totals.removalLf += lengthFt;
          totals.removalCost += removalCost;
        }

        const autoCaps = [];
        const defaultCapStyle = (SEED.capStyles && SEED.capStyles[0]) || 'Pyramid';
        const defaultCapMaterial = (SEED.capMaterials && SEED.capMaterials[0]) || 'Cast Iron';
        Object.entries(installInfo.postCounts || {}).forEach(([postKey, count])=>{
          const qty = parseInt(count,10) || 0;
          if(qty <= 0) return;
          const postSizeLabel = postKeyToLabel(postKey) || (s.postSize || '2x2');
          const capLabel = `caps - ${defaultCapMaterial} - ${defaultCapStyle} (${postSizeLabel})`;
          addMat(materials, capLabel, qty);
          installCapsByLabel.set(capLabel, (installCapsByLabel.get(capLabel)||0) + qty);
          autoCaps.push({ count: qty, postSize: postSizeLabel, style: defaultCapStyle, material: defaultCapMaterial });
        });
        if(autoCaps.length){
          installInfo.autoCaps = autoCaps;
        }
      }

      if(isInstall && (fenceType === 'wrought iron' || fenceType === 'wood')){
        const wallLength = parseFloat(s.retainingWallLength || 0) || 0;
        const wallHeight = parseFloat(s.retainingWallHeight || 0) || 0;
        if(wallLength > 0 && wallHeight > 0){
          const wallSqft = wallLength * wallHeight;
          const wallCost = Math.max(wallSqft * 35, 1500);
          totals.retainingWallSqft += wallSqft;
          totals.retainingWallCost += wallCost;
        }
      }

      let sectionPatchTotal = 0;
      let sectionReplTotal = 0;
      let sectionGapTotal = 0;
      const sectionPatchSizes = new Set();
      const sectionReplSizes = new Set();
      const sectionGapSizes = new Set();
      const gapCountByLabel = new Map();
      if(isRepair){
        const railsArr = (s.rails||[]).slice(0, s.railsCount||0);
        railsArr.forEach(r=>{
          const patchCount = parseInt(r?.patches||0,10) || 0;
          const replCount = parseInt(r?.replacements||0,10) || 0;
          const primarySize = normalizeSize(r?.size);
          const secondarySize = r?.stacked ? normalizeSize(r?.size2) : '';
          if(patchCount){
            sectionPatchTotal += patchCount;
            if(primarySize) sectionPatchSizes.add(primarySize);
            if(secondarySize) sectionPatchSizes.add(secondarySize);
          }
          if(replCount){
            sectionReplTotal += replCount;
            if(primarySize) sectionReplSizes.add(primarySize);
            if(secondarySize) sectionReplSizes.add(secondarySize);
          }
        });
        gapAdditionsArr.forEach(item=>{
          const qty = parseInt(item?.qty||0,10) || 0;
          if(!qty) return;
          sectionGapTotal += qty;
          const rawSize = item?.size || '';
          const normalized = normalizeSize(rawSize);
          if(normalized) sectionGapSizes.add(normalized);
          const label = normalized ? normalizeLabelText(normalized) : normalizeLabelText(rawSize) || rawSize || 'matching rail stock';
          const displayLabel = label || 'matching rail stock';
          gapCountByLabel.set(displayLabel, (gapCountByLabel.get(displayLabel)||0) + qty);
        });
      }

      lines.push(`${title}`);
      const scopeLabel = scopeType === 'install'
        ? 'Install new section'
        : scopeType === 'replace'
          ? 'Remove & replace section'
          : 'Repair existing section';
      lines.push(`- Scope: ${scopeLabel}`);
      lines.push(`- Style: ${s.style}`);
      lines.push(`- Height: ${s.height}`);
      lines.push(`- Rails: ${railsDesc}`);
      lines.push(`- Picket: ${picket}`);
      lines.push(`- Puppy Pickets: ${s.puppy}`);
      const attachmentMethod = s.panelAttachment || (installInfo && installInfo.attachment) || 'Welding';
      const paintingDefault = s.painting || 'Paint Section';
      const paintingLabel = (scopeType === 'install' && attachmentMethod === 'Brackets')
        ? 'None'
        : paintingDefault;
      lines.push(`- Painting: ${paintingLabel}`);
      if(paintingLabel === 'Paint Section' || paintingLabel === 'Prime and Paint'){
        const application = s.paintingApplication || 'By Hand';
        lines.push(`- Paint application: ${application}`);
      }
      const braceLine = braceLineParts.length ? `- Diagonal brace additions: ${braceLineParts.join('; ')} (4 ft each)` : '';
      if(braceLine && !isRepair){
        lines.push(braceLine);
      }

      if(isInstall && installInfo){
        lines.push(`- Post spacing: ${installInfo.spacingFt} ft`);
        lines.push(`- Panel attachment: ${installInfo.attachment}`);
        lines.push(`- Posts to set: ${installInfo.postsTotal} (${s.postSize})`);
        if(installInfo.finialStyle){
          lines.push(`- Finials: ${installInfo.finialStyle}`);
        }
        if(Array.isArray(installInfo.autoCaps) && installInfo.autoCaps.length){
          const capParts = installInfo.autoCaps.map(cap=>`${cap.count} × ${cap.material} ${cap.style} (${cap.postSize})`);
          lines.push(`- Post caps: ${capParts.join('; ')}`);
        }
        if(scopeType === 'replace' && installInfo.lengthFt > 0){
          lines.push(`- Remove existing section (${installInfo.lengthFt} lf) and haul away (sub paid $${money(installInfo.removalCost)})`);
        }
      }

      lines.push(`- Length: ${numOrDash(s.length)} ft`);
      if (s.hardscape > 0) lines.push(`- Over hardscape: ${s.hardscape} lf`);
      if (s.trim > 0)      lines.push(`- Trim: ${s.trim} lf`);
      if (!isInstall && s.digOut > 0)    lines.push(`- Dig out: ${s.digOut} lf`);

      const i = (v)=> (parseInt(v||0,10) || 0);
      const picketReplaceCount = isRepair ? i(s.wiPickets) : 0;
      const replaceCounts = isRepair ? countPostGroups(s.postReplacements) : zeroPostCounts();
      const realignCounts = isRepair ? countPostGroups(s.postRealignments) : zeroPostCounts();
      const realignCutWeld = isRepair ? countRealignCutWeld(s.postRealignments) : 0;
      if(isRepair){
        lines.push(`- Repairs:`);
        lines.push(`  - Pickets to replace: ${picketReplaceCount}`);
        lines.push(`  - Rail patches: ${sectionPatchTotal}`);
        lines.push(`  - Full rail replacements: ${sectionReplTotal}`);
        const gapLineParts = [];
        gapCountByLabel.forEach((qty,label)=>{ gapLineParts.push(`${qty} × ${label}`); });
        const gapSummary = (sectionGapTotal > 0 && gapLineParts.length)
          ? ` (${gapLineParts.join('; ')})`
          : '';
        lines.push(`  - Full rail gap fillers: ${sectionGapTotal}${gapSummary}`);
        lines.push(`  - 2x2 posts to replace: ${replaceCounts.posts2x2}`);
        lines.push(`  - 3x3 posts to replace: ${replaceCounts.posts3x3}`);
        lines.push(`  - 1 1/2" x 1 1/2" posts to replace: ${replaceCounts.posts1p5}`);
        lines.push(`  - 4x4 posts to replace: ${replaceCounts.posts4x4}`);
        lines.push(`  - 2x2 posts to realign: ${realignCounts.posts2x2}`);
        lines.push(`  - 3x3 posts to realign: ${realignCounts.posts3x3}`);
        if(realignCutWeld > 0){
          lines.push(`  - Posts to realign (cut & weld): ${realignCutWeld}`);
        }
        if(braceTotalQty > 0){
          const braceSummary = braceLineParts.length ? ` (${braceLineParts.join('; ')})` : '';
          lines.push(`  - Diagonal brace additions: ${braceTotalQty}${braceSummary}`);
        }
      }

      // NEW: Finials
      const finArr = isRepair && Array.isArray(s.finials) ? s.finials : [];
      const finCount = finArr.reduce((acc,f)=> acc + (parseInt(f?.qty||0,10) || 0), 0);
      if(finCount){
        lines.push(`- Finial replacements: ${finCount}`);
        finArr.forEach(f=>{
          const q = parseInt(f?.qty||0,10) || 0; if(!q) return;
          lines.push(`  - ${q} × ${f.material} ${f.style} on ${f.picketSize} pickets`);
        });
      }

      const puppyInsertArr = isRepair && Array.isArray(s.puppyInserts) ? s.puppyInserts : [];
      const puppyInsertCount = puppyInsertArr.reduce((acc,item)=> acc + (parseInt(item?.qty||0,10) || 0), 0);
      if(puppyInsertCount){
        lines.push(`- Puppy picket inserts: ${puppyInsertCount}`);
        puppyInsertArr.forEach(item=>{
          const qty = parseInt(item?.qty||0,10) || 0;
          if(!qty) return;
          const normalized = normalizeSize(item?.picketSize);
          const sizeLabel = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
          lines.push(`  - ${qty} × ${sizeLabel} pickets (includes 25 plugs per insert)`);
        });
      }

      function processPanels(list, heading, source, extra={}){
        if(!Array.isArray(list) || list.length === 0) return;
        const prepared = [];
        const defaultRail = (Array.isArray(s.rails) && s.rails[0] && s.rails[0].size) || s.railSize || SEED.railSize[0];
        list.forEach(p=>{
          if(!p) return;
          const qty = parseInt(p.qty,10) || 0;
          if(qty <= 0) return;
          const widthRaw = parseInt(p.widthIn,10) || 0;
          const widthIn = Math.max(12, widthRaw);
          const railSize = p.railSize || defaultRail;
          const picketSize = p.picketSize || s.picketSize || SEED.picketSize[0];
          const height = p.height || s.height;
          let style = p.style || s.style || '';
          if(source === 'install' && extra.style){ style = extra.style; }
          const hasFinials = /Finials/i.test(style);
          const finialStyle = hasFinials
            ? (p.finialStyle || extra.finialStyle || SEED.finialStyles[0])
            : '';
          prepared.push({ qty, widthIn, railSize, picketSize, height, style, finialStyle });
        });
        if(!prepared.length) return;
        lines.push(heading);
        prepared.forEach(entry=>{
          const { qty, widthIn, railSize, picketSize, height, style, finialStyle } = entry;
          const feet = feetFromHeightStr(height);
          const eligible = isPrefabEligible(widthIn, railSize, picketSize);
          const hasFinials = /Finials/i.test(style);
          const finStyleLabel = hasFinials ? (finialStyle || SEED.finialStyles[0]) : '';
          const finialNote = hasFinials && finStyleLabel ? ` (finials: ${finStyleLabel})` : '';
          const desc = `${height}, ${style}${finialNote}, rails ${railSize}, pickets ${picketSize} ${eligible?'(prefab eligible)':'(build on site)'}`;
          lines.push(`  - ${qty} × ${widthIn}" wide panel — ${desc}`);
          const panelHours = eligible ? qty * 0.5 : qty * 1.5;
          manHours += panelHours;
          const attachment = (source === 'install') ? (extra.attachment || 'Welding') : 'Welding';
          const usesBrackets = attachment === 'Brackets';
          if(!usesBrackets){ welderHours += panelHours; }
          if(eligible){
            totals.panelsPrefab += qty;
            if(source === 'install') totals.panelsInstallPrefab += qty;
          } else {
            totals.panelsCustom += qty;
            if(source === 'install') totals.panelsInstallCustom += qty;
          }
          if(!s._panelCalc) s._panelCalc = [];
          s._panelCalc.push({
            qty,
            feet,
            eligible,
            style,
            picketSize,
            railSize,
            height,
            widthIn,
            finialStyle,
            source,
            attachment
          });
          if(hasFinials){
            addMat(materials, `finials - Cast Iron - ${finStyleLabel} (${picketSize})`, qty*25);
          }
          if(source === 'install' && attachment === 'Brackets'){
            addMat(materials, 'panel mount bracket', qty * 4);
          }
        });
        if(source === 'install' && extra.installInfo){
          if(!extra.installInfo.panels) extra.installInfo.panels = [];
          prepared.forEach(entry=>{
            extra.installInfo.panels.push({ ...entry, attachment: extra.attachment || 'Welding' });
          });
        }
      }

      // PANEL REPLACEMENTS (per-row)
      const panelArr = isRepair && Array.isArray(s.panels) ? s.panels : [];
      processPanels(panelArr, '- Panel replacements:', 'repair');

      if(installInfo && installInfo.spanCount > 0){
        const widthCounts = {};
        installInfo.panelWidths.forEach(w=>{
          widthCounts[w] = (widthCounts[w]||0) + 1;
        });
        const installStyle = (()=>{
          let base = s.style || '';
          const puppyVal = s.puppy || '';
          if(/Finials/i.test(puppyVal) && !/Finials/i.test(base)){
            base = base ? `${base} (${puppyVal})` : puppyVal;
          }
          return base || s.style || '';
        })();
        const installPanels = Object.entries(widthCounts).map(([width, qty])=>({
          qty,
          widthIn: parseInt(width,10) || 0,
          height: s.height,
          style: installStyle,
          railSize: (Array.isArray(s.rails) && s.rails[0] && s.rails[0].size) || s.railSize || SEED.railSize[0],
          picketSize: s.picketSize,
          finialStyle: installInfo.finialStyle
        }));
        processPanels(installPanels, '- Panel installation:', 'install', {
          attachment: installInfo.attachment,
          finialStyle: installInfo.finialStyle,
          style: installStyle,
          installInfo
        });
      }

      // NEW: Caps
      const capArr = isRepair && Array.isArray(s.caps) ? s.caps : [];
      const capCount = capArr.reduce((acc,c)=> acc + (parseInt(c?.qty||0,10) || 0), 0);
      if(capCount){
        lines.push(`- Post cap replacements: ${capCount}`);
        capArr.forEach(c=>{
          const q = parseInt(c?.qty||0,10) || 0; if(!q) return;
          lines.push(`  - ${q} × ${c.material} ${c.style} caps for ${c.postSize} posts`);
        });
      }

      if(installInfo){
        s._installCalc = installInfo;
      }

      // Walk gate details
      const wg  = isRepair ? i(s.walkGates) : 0;
      const wgr = isRepair ? i(s.walkGatesRealign) : 0;
      const wgh = isRepair ? i(s.walkGatesHardware) : 0;
      const wgb = isRepair ? i(s.walkGatesRebuild) : 0;
      if (isRepair && (wg || wgr || wgh || wgb)){
        lines.push(`- Walk gates: ${wg}`);
        if (wgr) lines.push(`  - Realign: ${wgr}`);
        if (wgh) lines.push(`  - Hardware replacements: ${wgh} (Latch: ${s.walkLatch||'-'}, Hinges: ${s.walkHinges||'-'})`);
        if (wgb) lines.push(`  - Rebuild: ${wgb} (Frame: ${s.walkRebuildFrame}, Pickets: ${s.walkRebuildPicket}, Latch: ${s.walkRebuildLatch}, Hinges: ${s.walkRebuildHinges})`);
      }

      // Add walk gate into existing fence
      const wga = i(s.walkGatesAdd);
      if (wga){
        const gateTypeLabel = s.walkAddType || 'Single Swing Walk Gate';
        lines.push(`- Add walk gate(s): ${wga} — ${gateTypeLabel}`);
        lines.push(`  - Post: ${s.walkAddPostSize}; Frame: ${s.walkAddFrameSize}; Pickets: ${s.walkAddPicketSize}; Latch: ${s.walkAddLatch}; Hinges: ${s.walkAddHinges}`);
      }

      if(isInstall && (fenceType === 'wrought iron' || fenceType === 'wood')){
        const wallLength = parseFloat(s.retainingWallLength || 0) || 0;
        const wallHeight = parseFloat(s.retainingWallHeight || 0) || 0;
        if(wallLength > 0 && wallHeight > 0){
          lines.push(`- Retaining wall: ${wallLength}ft long × ${wallHeight}ft tall ($35/sq ft, $1,500 minimum).`);
        }
      }

      if (s.notes) lines.push(`- Notes: ${s.notes}`);
      lines.push('');

      totals.length       += i(s.length);
      totals.hardscape    += i(s.hardscape);
      totals.trim         += i(s.trim);
      if(isRepair){
        totals.digOut       += i(s.digOut);
        totals.finials      += finCount;
        totals.puppyInserts += puppyInsertCount;
        if(puppyInsertCount > 0){
          puppyInsertArr.forEach(item=>{
            const qty = parseInt(item?.qty||0,10) || 0;
            if(!qty) return;
            const normalized = normalizeSize(item?.picketSize);
            const sizeLabel = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
            totals.puppyInsertSizes.set(sizeLabel, (totals.puppyInsertSizes.get(sizeLabel)||0) + qty);
            addMat(materials, `puppy picket insert (${sizeLabel})`, qty);
            addMat(materials, `picket plugs (${sizeLabel})`, qty * 25);
          });
        }
        totals.wiPickets    += picketReplaceCount;
        if(picketReplaceCount > 0){
          const picketSizeNormalized = normalizeSize(s.picketSize);
          if(picketSizeNormalized) totals.wiPicketSizes.add(picketSizeNormalized);
        }
        totals.wiPatches    += sectionPatchTotal;
        if(sectionPatchTotal > 0){
          sectionPatchSizes.forEach(size=> totals.wiPatchSizes.add(size));
        }
        totals.wiRails      += sectionReplTotal;
        if(sectionReplTotal > 0){
          sectionReplSizes.forEach(size=> totals.wiRailReplaceSizes.add(size));
        }
        totals.wiRailGaps   += sectionGapTotal;
        if(sectionGapTotal > 0){
          sectionGapSizes.forEach(size=> totals.wiRailGapSizes.add(size));
        }
        addPostCounts(totals.postsReplace, replaceCounts);
        addPostCounts(totals, replaceCounts);
        totals.postsRealign2x2 += realignCounts.posts2x2;
        totals.postsRealign3x3 += realignCounts.posts3x3;
        totals.postsRealignCutWeld += realignCutWeld;
        totals.walkGates   += wg;
        totals.walkRealign += wgr;
        totals.walkHardware+= wgh;
        totals.walkRebuild += wgb;
        totals.caps        += capCount;
      }
      totals.walkGateAdds += wga;
      if(isInstall){
        totals.walkGateAddsInstall += wga;
      } else {
        totals.walkGateAddsRepair += wga;
      }
      const gateTypeLabel = s.walkAddType || 'Single Swing Walk Gate';
      if(gateTypeLabel === 'Double Swing Gate'){
        totals.walkGateAddsDouble += wga;
      } else {
        totals.walkGateAddsSingle += wga;
      }
    });

    if (state.sections.length){
      const t = totals;
      lines.push(`TOTALS`);
      lines.push(`- Sections: ${state.sections.length}`);
      lines.push(`- Length: ${t.length} ft`);
      if (t.hardscape)     lines.push(`- Over hardscape: ${t.hardscape} lf`);
      if (t.trim)          lines.push(`- Trim: ${t.trim} lf`);
      if (t.digOut)        lines.push(`- Dig out: ${t.digOut} lf`);
      if (t.replaceSections) lines.push(`- Sections to replace: ${t.replaceSections}`);
      if (t.installSections) lines.push(`- New sections to install: ${t.installSections}`);
      if (t.removalLf)      lines.push(`- Removal & haul away: ${t.removalLf} lf (sub paid $${money(t.removalCost)})`);
      if (t.finials)        lines.push(`- Finials to replace: ${t.finials}`);
      if (t.puppyInserts)   lines.push(`- Puppy picket inserts: ${t.puppyInserts}`);
      if (t.caps)           lines.push(`- Post caps to replace: ${t.caps}`);
      if (t.wiPickets)      lines.push(`- Pickets to replace: ${t.wiPickets}`);
      if (t.wiPatches)      lines.push(`- Rail patches: ${t.wiPatches}`);
      if (t.wiRails)        lines.push(`- Full rail replacements: ${t.wiRails}`);
      if (t.wiRailGaps)     lines.push(`- Full rail gap fillers: ${t.wiRailGaps}`);
      const postSummary = (label, counts)=>{
        const parts = [];
        if(counts.posts1p5) parts.push(`${counts.posts1p5} × 1 1/2" x 1 1/2"`);
        if(counts.posts2x2) parts.push(`${counts.posts2x2} × 2x2`);
        if(counts.posts3x3) parts.push(`${counts.posts3x3} × 3x3`);
        if(counts.posts4x4) parts.push(`${counts.posts4x4} × 4x4`);
        if(parts.length) lines.push(`- ${label}: ${parts.join(', ')}`);
      };
      postSummary('Posts to replace', t.postsReplace || zeroPostCounts());
      postSummary('Posts to set (new sections)', t.postsInstall || zeroPostCounts());
      if (t.postsRealign2x2) lines.push(`- 2x2 posts to realign: ${t.postsRealign2x2}`);
      if (t.postsRealign3x3) lines.push(`- 3x3 posts to realign: ${t.postsRealign3x3}`);
      if (t.postsRealignCutWeld) lines.push(`- Posts to realign (cut & weld): ${t.postsRealignCutWeld}`);
      if (t.walkGates)     lines.push(`- Walk gates: ${t.walkGates}`);
      if (t.walkRealign)   lines.push(`- Walk gates to realign: ${t.walkRealign}`);
      if (t.walkHardware)  lines.push(`- Walk gate hardware replacements: ${t.walkHardware}`);
      if (t.walkRebuild)   lines.push(`- Walk gates to rebuild: ${t.walkRebuild}`);
      if (t.walkGateAdds)  lines.push(`- Walk gates to add: ${t.walkGateAdds}`);
      if (t.walkGateAddsSingle) lines.push(`- Single swing walk gates to add: ${t.walkGateAddsSingle}`);
      if (t.walkGateAddsDouble) lines.push(`- Double swing gates to add: ${t.walkGateAddsDouble}`);
      if (t.panelsPrefab) lines.push(`- Prefab panels to install: ${t.panelsPrefab}`);
      if (t.panelsCustom) lines.push(`- Panels to custom-build: ${t.panelsCustom}`);
      if (t.panelsInstallPrefab) lines.push(`- New prefab panels: ${t.panelsInstallPrefab}`);
      if (t.panelsInstallCustom) lines.push(`- New custom panels: ${t.panelsInstallCustom}`);
    }


    const installSectionsOnly = state.sections.filter(s=> (s?.scopeType || 'repair') === 'install');
    const replacementSectionsOnly = state.sections.filter(s=> (s?.scopeType || 'repair') === 'replace');

    if(replacementSectionsOnly.length){
      const detail = buildInstallServiceDescription(replacementSectionsOnly, true);
      addServiceLine('Wrought Iron Fence Replacement', detail || 'Remove existing fence and install new wrought iron fence. Posts will be set in concrete 36" deep.');
    }

    if(installSectionsOnly.length){
      const detail = buildInstallServiceDescription(installSectionsOnly, false);
      addServiceLine('Wrought Iron Fence Installation', detail || 'Install wrought iron fence. Posts will be set in concrete 36" deep.');
    }

    const paintingSummary = state.sections.reduce((acc, s)=>{
      const len = parseInt(s.length||0,10) || 0;
      if(len > 0){
        const hardscape = parseInt(s.hardscape||0,10) || 0;
        const trim = parseInt(s.trim||0,10) || 0;
        if(s.painting === 'Paint Section'){
          acc.full.len += len;
          acc.full.hardscape += hardscape;
          acc.full.trim += trim;
        } else if (s.painting === 'Prime and Paint'){
          acc.primePaint.len += len;
          acc.primePaint.hardscape += hardscape;
          acc.primePaint.trim += trim;
        } else if (s.painting === 'Spot Paint Welds'){
          acc.spot += len;
        }
      }
      return acc;
    }, { full: { len: 0, hardscape: 0, trim: 0 }, primePaint: { len: 0, hardscape: 0, trim: 0 }, spot: 0 });

    if (paintingSummary.full.len || paintingSummary.primePaint.len || paintingSummary.spot){
      const segments = [];
      if(paintingSummary.full.len){
        let detail = `Scrape and brush off loose rust and debris, then apply gloss black oil-based paint to approximately ${paintingSummary.full.len} linear feet of fence`;
        const extras = [];
        if(paintingSummary.full.hardscape) extras.push(`${paintingSummary.full.hardscape} lf over hardscape`);
        if(paintingSummary.full.trim) extras.push(`${paintingSummary.full.trim} lf of trim detail`);
        if(extras.length) detail += ` (${extras.join(', ')})`;
        segments.push(detail);
      }
      if(paintingSummary.primePaint.len){
        let detail = `Prime with red oxide primer, then apply gloss black oil-based paint to approximately ${paintingSummary.primePaint.len} linear feet of fence`;
        const extras = [];
        if(paintingSummary.primePaint.hardscape) extras.push(`${paintingSummary.primePaint.hardscape} lf over hardscape`);
        if(paintingSummary.primePaint.trim) extras.push(`${paintingSummary.primePaint.trim} lf of trim detail`);
        if(extras.length) detail += ` (${extras.join(', ')})`;
        detail += ` with two mobilizations: prime on day one and return after cure for the finish coat`;
        segments.push(detail);
      }
      if(paintingSummary.spot){
        segments.push(`Spot prep and apply gloss black oil-based paint to weld areas along ${paintingSummary.spot} linear feet`);
      }
      addServiceLine('Surface Preparation & Painting', segments.join('; ') + '.');
    }

    const woodRepairSections = state.sections.filter(s=> ((s.fenceType||'').toLowerCase() === 'wood') && ((s.scopeType||'repair') === 'repair'));
    if(woodRepairSections.length){
      const methodLabel = (list, val)=>{
        const match = list.find(item=>item.value === val);
        return match ? match.label : (val || '');
      };
      woodRepairSections.forEach(s=>{
        const parts = [];
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const railSize = s.woodRailSize || '';
        const picketWidth = s.woodPicketWidth || '';
        const woodHeightFt = feetFromStr(s.woodHeight || '');
        const sectionLengthFt = parseFloat(s.length||0) || 0;
        const isBoardOnBoard = /board on board/i.test(s.woodStyle || '');
        const addCount = (count, singular, plural)=>{
          const n = parseInt(count||0,10) || 0;
          if(!n) return '';
          const label = n === 1 ? singular : (plural || `${singular}s`);
          return `${n} ${label}`;
        };
        const picketReplaceCount = parseInt(s.woodRepairPicketReplace||0,10) || 0;
        const picketInstallCount = parseInt(s.woodRepairPicketInstall||0,10) || 0;
        const railReplaceCount = parseInt(s.woodRepairRailReplace||0,10) || 0;
        const railInstallCount = parseInt(s.woodRepairRailInstall||0,10) || 0;
        const postReplaceCount = parseInt(s.woodRepairPostReplace||0,10) || 0;
        const postRealignCount = parseInt(s.woodRepairPostRealign||0,10) || 0;
        const postInstallCount = parseInt(s.woodRepairPostInstall||0,10) || 0;
        const panels = parseInt(s.woodRepairPanelReplace||0,10) || 0;
        const walkGates = parseInt(s.woodRepairWalkGateCount||0,10) || 0;
        const strengthen = parseInt(s.woodRepairGateStrengthen||0,10) || 0;
        const replaceGate = parseInt(s.woodRepairGateReplace||0,10) || 0;
        const topCapLf = parseInt(s.woodRepairTopCapReplaceLf||0,10) || 0;
        const trimLf = parseInt(s.woodRepairTrimReplaceLf||0,10) || 0;
        const kickLf = parseInt(s.woodRepairKickReplaceLf||0,10) || 0;
        const kickStack = parseInt(s.woodRepairKickReplaceStack||0,10) || 1;

        const picketReplace = picketWidth
          ? addCount(picketReplaceCount, `${picketWidth} picket`, `${picketWidth} pickets`)
          : addCount(picketReplaceCount, 'picket', 'pickets');
        if(picketReplace){
          parts.push(`Replace ${picketReplace}`);
          const perPicketMinutes = isBoardOnBoard ? 10 : 5;
          const hours = (picketReplaceCount * perPicketMinutes) / 60;
          totals.woodPicketReplace += picketReplaceCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const picketInstall = picketWidth
          ? addCount(picketInstallCount, `${picketWidth} picket`, `${picketWidth} pickets`)
          : addCount(picketInstallCount, 'picket', 'pickets');
        if(picketInstall){
          parts.push(`Install ${picketInstall}`);
          const perPicketMinutes = isBoardOnBoard ? 10 : 5;
          const hours = (picketInstallCount * perPicketMinutes) / 60;
          totals.woodPicketInstall += picketInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const railReplace = addCount(railReplaceCount, railSize ? `${railSize} rail` : 'rail', railSize ? `${railSize} rails` : 'rails');
        if(railReplace){
          parts.push(`Replace ${railReplace}`);
          const hours = (railReplaceCount * 20) / 60;
          totals.woodRailReplace += railReplaceCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const railInstall = addCount(railInstallCount, railSize ? `${railSize} rail` : 'rail', railSize ? `${railSize} rails` : 'rails');
        if(railInstall){
          parts.push(`Install ${railInstall}`);
          const hours = (railInstallCount * 10) / 60;
          totals.woodRailInstall += railInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const postReplace = addCount(postReplaceCount, 'post', 'posts');
        if(postReplace){
          const tie = (s.woodRepairPostReplaceTie || '').trim();
          const cap = (s.woodRepairPostReplaceCap || '').trim();
          const extras = [tie ? `Simpson tie ${tie}` : '', cap ? `cap: ${cap}` : ''].filter(Boolean).join(', ');
          parts.push(`Replace ${postReplace}${extras ? ` (${extras})` : ''}`);
          const perPostHours = (woodHeightFt >= 8) ? 1.5 : 1;
          const hours = postReplaceCount * perPostHours * 2; // two-person task
          if(woodHeightFt >= 8){ totals.woodPostReplace8 += postReplaceCount; }
          else { totals.woodPostReplace6 += postReplaceCount; }
          woodHelperHours += hours;
          woodManHours += hours;
          woodRequiresTwoPerson = woodRequiresTwoPerson || postReplaceCount > 0;
        }
        const realign = addCount(postRealignCount, 'post realignment', 'post realignments');
        if(realign){
          const method = methodLabel(WOOD_POST_METHODS, s.woodRepairPostRealignMethod);
          parts.push(`${realign}${method ? ` via ${method}` : ''}`);
          const isCutWeld = s.woodRepairPostRealignMethod === 'cut-weld';
          const perPostHours = isCutWeld ? (20/60) : (45/60);
          if(isCutWeld){
            totals.woodPostRealignCutWeld += postRealignCount;
            const hours = postRealignCount * perPostHours;
            woodWelderHours += hours;
            woodHelperHours += hours;
            woodManHours += hours * 2;
            woodRequiresTwoPerson = true;
          } else {
            totals.woodPostRealignDig += postRealignCount;
            const hours = postRealignCount * perPostHours;
            woodHelperHours += hours;
            woodManHours += hours;
          }
        }
        const postInstall = addCount(postInstallCount, 'post installation', 'post installations');
        if(postInstall){
          const method = methodLabel(WOOD_POST_INSTALL_METHODS, s.woodRepairPostInstallMethod);
          const tie = (s.woodRepairPostInstallTie || '').trim();
          const extras = [method, tie ? `Simpson tie ${tie}` : ''].filter(Boolean).join('; ');
          parts.push(`${postInstall}${extras ? ` (${extras})` : ''}`);
          const hours = postInstallCount * (45/60);
          totals.woodPostInstall += postInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(panels>0){
          const width = parseFloat(s.woodRepairPanelWidth||0) || 0;
          const widthLabel = width ? `${width} ft` : 'approx. 8 ft';
          parts.push(`Replace ${panels} panel${panels===1?'':'s'} (~${widthLabel} each)`);
          const hours = panels * 1.5;
          totals.woodPanels += panels;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(walkGates>0){
          const tasks = [];
          if(s.woodRepairWalkGateHinges) tasks.push('replace hinges');
          if(s.woodRepairWalkGateLatch) tasks.push('replace latch');
          if(s.woodRepairWalkGateWood) tasks.push('repair wood around gate');
          const taskLabel = tasks.length ? ` (${tasks.join(', ')})` : '';
          parts.push(`Repair ${walkGates} walk gate${walkGates===1?'':'s'}${taskLabel}`);
          const hours = walkGates * 2;
          totals.woodGateRepair += walkGates;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(strengthen>0){
          parts.push(`Strengthen ${strengthen} walk gate${strengthen===1?'':'s'} with additional 2x4 framing`);
          const hours = strengthen * 1;
          totals.woodGateStrengthen += strengthen;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(replaceGate>0){
          parts.push(`Replace ${replaceGate} walk gate${replaceGate===1?'':'s'} with new build and hardware`);
          const hours = replaceGate * 2;
          totals.woodGateReplace += replaceGate;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(topCapLf>0){
          const size = s.woodRepairTopCapReplaceSize || s.woodTopCapSize || '2x6';
          parts.push(`Replace ${topCapLf} lf of top cap (${size})`);
          const hours = topCapLf * ((20/60)/16);
          totals.woodTopCapLf += topCapLf;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(trimLf>0){
          const size = s.woodRepairTrimReplaceSize || s.woodTrimType || '';
          parts.push(`Replace ${trimLf} lf of trim${size ? ` (${size})` : ''}`);
          const hours = trimLf * ((10/60)/8);
          totals.woodTrimLf += trimLf;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(kickLf>0){
          const size = s.woodRepairKickReplaceSize || s.woodKickBoardSize || '';
          const stack = kickStack > 0 ? kickStack : 1;
          parts.push(`Replace ${kickLf} lf of kick board (${size}, ${stack} board stack)`);
          const hours = kickLf * stack * ((20/60)/8);
          totals.woodKickLf += kickLf;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(parts.length){
          addServiceLine('Wood Fence Repairs', `${labelPrefix}${parts.join('; ')}.`);
        }
        if(s.woodRepairStain === 'stain'){
          const sideLabel = s.woodRepairStainSides === 'both' ? 'both sides' : '1 side';
          const heightFt = woodHeightFt || feetFromStr(s.height);
          const stainSqft = Math.max(0, sectionLengthFt) * Math.max(0, heightFt) * (sideLabel === 'both sides' ? 2 : 1);
          if(stainSqft > 0){
            totals.woodStainSqft += stainSqft;
            const hours = stainSqft * (14/3000); // two-person production rate
            woodHelperHours += hours;
            woodManHours += hours;
            woodRequiresTwoPerson = true;
          }
          addServiceLine('Wood Fence Staining', `${labelPrefix}Stain ${sideLabel} of the section.`);
        }
      });
    }

    manHours += woodManHours;
    helperHours += woodHelperHours;
    welderHours += woodWelderHours;

    if (totals.digOut > 0){
      addServiceLine('Dig Out Encroaching Soil', `Remove built-up soil along ${totals.digOut} linear feet to expose fence bottom rails. If any additional repairs are exposed, we can let you know and get you a quote for the additional repairs.`);
    }
    const picketCount = parseInt(totals.wiPickets, 10) || 0;
    if (picketCount > 0){
      const picketPlural = picketCount === 1 ? '' : 's';
      const picketSizes = Array.from(totals.wiPicketSizes || []).filter(Boolean);
      let picketDesc = '';
      if(picketSizes.length === 1){
        const size = picketSizes[0];
        picketDesc = `Cut out ${picketCount}x rusted ${size} picket${picketPlural} and weld in ${picketCount}x new ${size} steel picket${picketPlural}.`;
      } else {
        const sizeSuffix = picketSizes.length > 1 ? ` (${joinParts(picketSizes)})` : '';
        picketDesc = `Cut out ${picketCount}x rusted picket${picketPlural}${sizeSuffix} and weld in ${picketCount}x new steel picket${picketPlural}${sizeSuffix}.`;
      }
      addServiceLine('Replace Damaged Pickets', picketDesc);
    }
    if (totals.wiPatches > 0){
      const rustedPortionText = totals.wiPatches === 1
        ? '1x rusted portion'
        : `${totals.wiPatches}x rusted portions`;
      const patchSizes = Array.from(totals.wiPatchSizes || []).filter(Boolean);
      let patchDesc = '';
      if(patchSizes.length === 1){
        patchDesc = `Cut out ${rustedPortionText} of ${patchSizes[0]} rail steel and weld in new steel.`;
      } else {
        const sizeSuffix = patchSizes.length > 1 ? ` (${joinParts(patchSizes)})` : '';
        patchDesc = `Cut out ${rustedPortionText} of rail steel${sizeSuffix} and weld in new steel.`;
      }
      addServiceLine('Rail Patch Repairs', patchDesc);
    }
    if (totals.wiRails > 0){
      const railCount = parseInt(totals.wiRails, 10) || 0;
      const railLabel = railCount === 1 ? 'old rail' : 'old rails';
      const railVerb = railCount === 1 ? 'is' : 'are';
      const railNeedVerb = railCount === 1 ? 'needs' : 'need';
      const replaceSizes = Array.from(totals.wiRailReplaceSizes || []).filter(Boolean);
      const sizeSuffix = replaceSizes.length ? ` (${joinParts(replaceSizes)})` : '';
      addServiceLine(
        'Full Rail Replacement',
        `Cut out ${railCount}x ${railLabel}${sizeSuffix} that ${railVerb} rusted through and ${railNeedVerb} to be replaced. Weld in new rail steel.`
      );
    }
    if (totals.wiRailGaps > 0){
      const gapCount = parseInt(totals.wiRailGaps, 10) || 0;
      const gapLabel = describeCount(gapCount, 'full rail gap filler', 'full rail gap fillers');
      const gapSizes = Array.from(totals.wiRailGapSizes || []).filter(Boolean);
      const sizeText = gapSizes.length ? ` using ${joinParts(gapSizes)} rail stock` : ' using matching rail stock';
      addServiceLine('Full Rail Gap Filler', `Add ${gapLabel}${sizeText} to close open spans and match the existing fence.`);
    }
    const replaceServiceCounts = totals.postsReplace || zeroPostCounts();
    if (replaceServiceCounts.posts2x2 > 0 || replaceServiceCounts.posts3x3 > 0 || replaceServiceCounts.posts1p5 > 0 || replaceServiceCounts.posts4x4 > 0){
      const parts = [];
      if(replaceServiceCounts.posts2x2 > 0) parts.push(describeCount(replaceServiceCounts.posts2x2, '2x2 post', '2x2 posts'));
      if(replaceServiceCounts.posts3x3 > 0) parts.push(describeCount(replaceServiceCounts.posts3x3, '3x3 post', '3x3 posts'));
      if(replaceServiceCounts.posts1p5 > 0) parts.push(describeCount(replaceServiceCounts.posts1p5, '1 1/2" x 1 1/2" post', '1 1/2" x 1 1/2" posts'));
      if(replaceServiceCounts.posts4x4 > 0) parts.push(describeCount(replaceServiceCounts.posts4x4, '4x4 post', '4x4 posts'));
      const partText = joinParts(parts);
      if(partText) addServiceLine('Replace Fence Posts', `Set new ${partText} in concrete and tie into existing panels.`);
    }
    if (totals.postsRealign2x2 > 0 || totals.postsRealign3x3 > 0){
      const parts = [];
      if(totals.postsRealign2x2 > 0) parts.push(describeCount(totals.postsRealign2x2, '2x2 post', '2x2 posts'));
      if(totals.postsRealign3x3 > 0) parts.push(describeCount(totals.postsRealign3x3, '3x3 post', '3x3 posts'));
      const partText = joinParts(parts);
      if(partText) addServiceLine('Realign Leaning Posts', `Plumb and secure ${partText} without replacement.`);
    }
    if (totals.postsRealignCutWeld > 0){
      addServiceLine(
        'Realign Leaning Posts (Cut & Weld)',
        `Cut, brace, and weld ${describeCount(totals.postsRealignCutWeld, 'leaning post', 'leaning posts')} back plumb without resetting in concrete.`
      );
    }
    if (totals.finials > 0){
      addServiceLine('Finial Replacement', `Install ${describeCount(totals.finials, 'new finial', 'new finials')} to restore decorative picket tops.`);
    }
    if (totals.puppyInserts > 0){
      const sizeParts = [];
      if(totals.puppyInsertSizes && typeof totals.puppyInsertSizes.forEach === 'function'){
        totals.puppyInsertSizes.forEach((count, size)=>{
          if(count>0){ sizeParts.push(`${count} × ${size}`); }
        });
      }
      const sizeNote = sizeParts.length ? ` (${sizeParts.join(', ')})` : '';
      addServiceLine('Install Puppy Picket Inserts', `Install ${describeCount(totals.puppyInserts, 'puppy picket insert', 'puppy picket inserts')}${sizeNote} to close spacing near the bottom of the fence for small pets.`);
    }
    if (totals.caps > 0){
      addServiceLine('Post Cap Replacement', `Install ${describeCount(totals.caps, 'new post cap', 'new post caps')} to protect posts and match the existing style.`);
    }
    if (totals.diagonalBraces > 0){
      const braceDesc = describeCount(totals.diagonalBraces, 'diagonal brace', 'diagonal braces');
      const braceSizeLabels = [];
      if(totals.diagonalBraceSizes && typeof totals.diagonalBraceSizes.forEach === 'function'){
        totals.diagonalBraceSizes.forEach((count, size)=>{
          const qty = parseInt(count,10) || 0;
          if(qty <= 0) return;
          const cleanSize = normalizeLabelText(size || '');
          braceSizeLabels.push(cleanSize ? `${cleanSize} picket steel` : 'picket steel');
        });
      }
      const uniqueBraceLabels = Array.from(new Set(braceSizeLabels)).filter(Boolean);
      const sizeDetail = uniqueBraceLabels.length ? ` using ${joinParts(uniqueBraceLabels)}` : '';
      addServiceLine('Add Diagonal Braces', `Fabricate and install ${braceDesc}${sizeDetail} to close gaps near the bottom of the fence.`);
    }
    const prefabSwapCount = Math.max(0, totals.panelsPrefab - (totals.panelsInstallPrefab || 0));
    if (prefabSwapCount > 0){
      addServiceLine('Install Prefab Panels', `Swap in ${describeCount(prefabSwapCount, 'prefabricated panel', 'prefabricated panels')} and secure them to existing posts.`);
    }
    const customSwapCount = Math.max(0, totals.panelsCustom - (totals.panelsInstallCustom || 0));
    if (customSwapCount > 0){
      addServiceLine('Build Custom Panels', `Fabricate and install ${describeCount(customSwapCount, 'custom panel', 'custom panels')} on site to match the wrought iron design.`);
    }
    if (totals.walkRealign > 0){
      addServiceLine('Realign Walk Gates', `Adjust and plumb ${describeCount(totals.walkRealign, 'walk gate', 'walk gates')} for smooth swing and latch.`);
    }
    if (totals.walkHardware > 0){
      addServiceLine('Replace Walk Gate Hardware', `Install new latch and hinge hardware on ${describeCount(totals.walkHardware, 'walk gate', 'walk gates')}.`);
    }
    if (totals.walkRebuild > 0){
      addServiceLine('Rebuild Walk Gates', `Rebuild ${describeCount(totals.walkRebuild, 'walk gate', 'walk gates')} with new frame and pickets to match the fence.`);
    }
    if (totals.walkGateAddsSingle > 0){
      addServiceLine('Add Single Walk Gate', `Cut in and install ${describeCount(totals.walkGateAddsSingle, 'single swing walk gate', 'single swing walk gates')} complete with posts, frame, and hardware.`);
    }
    if (totals.walkGateAddsDouble > 0){
      addServiceLine('Add Double Walk Gate', `Cut in and install ${describeCount(totals.walkGateAddsDouble, 'double swing gate', 'double swing gates')} complete with posts, frame, and hardware.`);
    }
    if (totals.replaceSections > 0){
      addServiceLine('Remove Fence Sections', `Take down and haul away ${describeCount(totals.replaceSections, 'existing fence section', 'existing fence sections')} prior to installation.`);
    }
    if (totals.installSections > 0){
      addServiceLine('Install New Fence Sections', `Set posts in concrete and install panels for ${describeCount(totals.installSections, 'new wrought iron fence section', 'new wrought iron fence sections')}.`);
    }

    const serviceLines = buildServiceLineOutput();
    renderServiceLineNotes(serviceLines);

    // ==== Materials aggregation ====
    let paintLenTotal = 0;
    let paintGallons = 0;
    let paintCans = 0;
    let primerGallons = 0;
    let primerCans = 0;

    const weldRepairHours = (
      totals.wiPickets*12 +
      totals.diagonalBraces*12 +
      totals.wiPatches*20 +
      totals.wiRails*30 +
      totals.wiRailGaps*20 +
      totals.posts1p5*60 +
      totals.posts2x2*60 +
      totals.posts3x3*90 +
      totals.posts4x4*120 +
      (totals.postsRealign2x2 + totals.postsRealign3x3)*30
    )/60;
    manHours += weldRepairHours;
    welderHours += weldRepairHours;
    const cutWeldWelderHours = totals.postsRealignCutWeld * 0.5;
    const cutWeldHelperHours = totals.postsRealignCutWeld * 0.5;
    if(totals.postsRealignCutWeld > 0){
      manHours += cutWeldWelderHours + cutWeldHelperHours;
      welderHours += cutWeldWelderHours;
      helperHours += cutWeldHelperHours;
    }
    const gateRepairHours = totals.walkRealign * 1 + totals.walkHardware * 1 + totals.walkRebuild * 3;
    manHours += gateRepairHours;
    welderHours += gateRepairHours;
    // Dig out: 5 minutes per LF
    const digHours = totals.digOut * (5/60);
    manHours += digHours;
    helperHours += digHours;
    // Finials: 0.5 minutes each
    const finialHours = totals.finials * (0.5/60);
    manHours += finialHours;
    welderHours += finialHours;
    // Caps: 20 seconds each
    const capHours = totals.caps * (20/60);
    manHours += capHours;
    helperHours += capHours;
    const puppyInsertWelderHours = totals.puppyInserts * 0.5;
    const puppyInsertHelperHours = totals.puppyInserts * 0.5;
    const puppyInsertManHours = puppyInsertWelderHours + puppyInsertHelperHours;
    manHours += puppyInsertManHours;
    welderHours += puppyInsertWelderHours;
    helperHours += puppyInsertHelperHours;
    // Added gates: 4 hours each
    const addedGateHours = (totals.walkGateAddsSingle * 2) + (totals.walkGateAddsDouble * 3);
    manHours += addedGateHours;
    welderHours += addedGateHours;

    // posts (1.5" x 1.5" raw sticks)
    let raw1p5Total = 0;
    state.sections.forEach(s=>{
      const hft = feetFromStr(s.height);
      const postLen = Math.max(8, hft + 3);
      const repCounts = countPostGroups(s.postReplacements);
      const count = repCounts.posts1p5 || 0;
      if(count>0){
        const perStick = Math.max(1, Math.floor(12 / Math.max(1, postLen)));
        raw1p5Total += Math.ceil(count / perStick);
      }
      const installCount1p5 = parseInt(s._installCalc?.postCounts?.posts1p5 || 0,10) || 0;
      if(installCount1p5>0){
        const perStickInstall = Math.max(1, Math.floor(12 / Math.max(1, postLen)));
        raw1p5Total += Math.ceil(installCount1p5 / perStickInstall);
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '1 1/2" x 1 1/2"'){
        const perStickAdd = Math.max(1, Math.floor(12 / Math.max(1, postLen)));
        raw1p5Total += Math.ceil(addG / perStickAdd);
      }
    });
    if(raw1p5Total>0){
      steelStickTotals.raw1p5 += raw1p5Total;
      addMat(materials, '1.5x1.5x12 raw steel', raw1p5Total);
    }

    // posts (2x2 by length)
    const posts2x2ByLenCalc = {};
    state.sections.forEach(s=>{
      const hft = feetFromStr(s.height);
      const postLen = Math.max(8, hft + 3);
      const repCounts = countPostGroups(s.postReplacements);
      const nReplace = repCounts.posts2x2 || 0;
      if(nReplace>0){ posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + nReplace; }
      const nInstall2x2 = parseInt(s._installCalc?.postCounts?.posts2x2 || 0,10) || 0;
      if(nInstall2x2>0){ posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + nInstall2x2; }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '2x2'){
        posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + addG;
      }
    });
    Object.keys(posts2x2ByLenCalc).sort((a,b)=>parseInt(a,10)-parseInt(b,10)).forEach(len=>{
      addMat(materials, `2x2x${len} posts`, posts2x2ByLenCalc[len]);
    });

    // 3x3 raw sticks (12ft) incl. gate adds
    const posts3x3ByLenCalc = {};
    state.sections.forEach(s=>{
      const repCounts = countPostGroups(s.postReplacements);
      const count = repCounts.posts3x3 || 0;
      const L = Math.max(8, feetFromStr(s.height) + 3);
      if(count>0){
        const perStick = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticks = Math.ceil(count / perStick);
        posts3x3ByLenCalc[L] = (posts3x3ByLenCalc[L]||0) + sticks;
      }
      const installCount3x3 = parseInt(s._installCalc?.postCounts?.posts3x3 || 0,10) || 0;
      if(installCount3x3>0){
        const perStickInstall = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksInstall = Math.ceil(installCount3x3 / perStickInstall);
        posts3x3ByLenCalc[L] = (posts3x3ByLenCalc[L]||0) + sticksInstall;
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '3x3'){
        const perStickAdd = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksAdd = Math.ceil(addG / perStickAdd);
        posts3x3ByLenCalc[L] = (posts3x3ByLenCalc[L]||0) + sticksAdd;
      }
    });
    let raw3x3Total = 0;
    Object.values(posts3x3ByLenCalc).forEach(v=>{ raw3x3Total += v; });
    if(raw3x3Total>0){
      steelStickTotals.raw3x3 += raw3x3Total;
      addMat(materials, '3x3x12 raw steel', raw3x3Total);
    }

    // 4x4 raw sticks (12ft) incl. gate adds
    const posts4x4ByLenCalc = {};
    state.sections.forEach(s=>{
      const repCounts = countPostGroups(s.postReplacements);
      const count = repCounts.posts4x4 || 0;
      const L = Math.max(8, feetFromStr(s.height) + 3);
      if(count>0){
        const perStick = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticks = Math.ceil(count / perStick);
        posts4x4ByLenCalc[L] = (posts4x4ByLenCalc[L]||0) + sticks;
      }
      const installCount4x4 = parseInt(s._installCalc?.postCounts?.posts4x4 || 0,10) || 0;
      if(installCount4x4>0){
        const perStickInstall = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksInstall = Math.ceil(installCount4x4 / perStickInstall);
        posts4x4ByLenCalc[L] = (posts4x4ByLenCalc[L]||0) + sticksInstall;
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0 && (s.walkAddPostSize||'').trim() === '4x4'){
        const perStickAdd = Math.max(1, Math.floor(12 / Math.max(1, L)));
        const sticksAdd = Math.ceil(addG / perStickAdd);
        posts4x4ByLenCalc[L] = (posts4x4ByLenCalc[L]||0) + sticksAdd;
      }
    });
    let raw4x4Total = 0;
    Object.values(posts4x4ByLenCalc).forEach(v=>{ raw4x4Total += v; });
    if(raw4x4Total>0){
      steelStickTotals.raw4x4 += raw4x4Total;
      addMat(materials, '4x4x12 raw steel', raw4x4Total);
    }

    // Concrete
    const concreteBagsCalc = totals.posts2x2 + totals.posts3x3 + totals.posts1p5 + totals.posts4x4 + Math.ceil((totals.postsRealign2x2 + totals.postsRealign3x3) * 0.5) + totals.walkRealign + totals.walkGateAddsRepair;

    // Gate bits + gate materials
    const latchCounts = {};
    const hingeCounts = {};
    state.sections.forEach(s=>{
      const hw = parseInt(s.walkGatesHardware||0,10) || 0;
      const rb = parseInt(s.walkGatesRebuild||0,10) || 0;
      if(hw>0){
        if(s.walkLatch) latchCounts[s.walkLatch] = (latchCounts[s.walkLatch]||0) + hw;
        if(s.walkHinges) hingeCounts[s.walkHinges] = (hingeCounts[s.walkHinges]||0) + hw;
      }
      if(rb>0){
        if(s.walkRebuildLatch) latchCounts[s.walkRebuildLatch] = (latchCounts[s.walkRebuildLatch]||0) + rb;
        if(s.walkRebuildHinges) hingeCounts[s.walkRebuildHinges] = (hingeCounts[s.walkRebuildHinges]||0) + rb;
        const frame = s.walkRebuildFrame || '';
        const pick  = s.walkRebuildPicket || '';
        const fN = normalizeSize(frame);
        const pN = normalizeSize(pick);
        if(fN === '1\"' && (pN === '1/2\"' || pN === '5/8\"')){
          const gateDescParts = [];
          if((s.walkRebuildFrame||'').trim()){ gateDescParts.push(`frame ${s.walkRebuildFrame.trim()}`); }
          if((s.walkRebuildPicket||'').trim()){ gateDescParts.push(`pickets ${s.walkRebuildPicket.trim()}`); }
          const gateDesc = gateDescParts.length ? ` (${gateDescParts.join(', ')})` : '';
          addMat(materials, `prefab gate panel${gateDesc}`, rb);
          addRailSticks(frame, rb * 2);
        } else {
          addRailSticks(frame, rb * 2);
          addPicketSticks(pick, rb * 2);
        }
      }
      const addG = parseInt(s.walkGatesAdd||0,10) || 0;
      if(addG>0){
        if(s.walkAddLatch) latchCounts[s.walkAddLatch] = (latchCounts[s.walkAddLatch]||0) + addG;
        if(s.walkAddHinges) hingeCounts[s.walkAddHinges] = (hingeCounts[s.walkAddHinges]||0) + addG;
        const gateType = s.walkAddType || 'Single Swing Walk Gate';
        const perGateRail = gateType === 'Double Swing Gate' ? 4 : 2;
        const sectionRails = sectionRailSizes(s);
        const frame = s.walkAddFrameSize || '';
        const railsToCount = sectionRails.length ? sectionRails : (frame ? [frame] : []);
        railsToCount.forEach(size=>{
          addRailSticks(size, addG * perGateRail);
        });
      }
    });

    // Add latches/hinges
    Object.keys(latchCounts).forEach(k=> addMat(materials, k, latchCounts[k]));
    const hingeLabel = (k)=> k==='Door Hinges' ? 'Pair of Door Hinges'
                            : k==='Bat Wing Hinges' ? 'Pair of Bat Wing Hinges'
                            : k==='Auto Close Hinges' ? 'Pair of Auto Close Hinges'
                            : k;
    Object.keys(hingeCounts).forEach(k=> addMat(materials, hingeLabel(k), hingeCounts[k]));

    addMat(materials, 'Maximizer bags of concrete', concreteBagsCalc);

    // WI picket sticks from replacements
    const picketBySizeCalc = {};
    state.sections.forEach(s=>{
      const need = parseInt(s.wiPickets||0,10) || 0;
      if(!need) return;
      let ph = parseInt(s.picketHeight||0,10) || 0; // inches
      if (ph <= 0) {
        const hf = feetFromStr(s.height);
        if (hf > 0) ph = hf * 12;
      }
      if (ph <= 0) ph = 54;
      const perStick = Math.max(1, Math.floor(144 / ph));
      const sticks = Math.ceil(need / perStick);
      const size = normalizeSize(s.picketSize);
      picketBySizeCalc[size] = (picketBySizeCalc[size]||0) + sticks;
    });
    Object.entries(picketBySizeCalc).forEach(([size, qty])=>{
      addPicketSticks(size, qty);
    });

    Object.entries(diagonalBraceFeetBySize).forEach(([size, feetTotal])=>{
      const totalFeet = parseFloat(feetTotal) || 0;
      if(totalFeet <= 0) return;
      const sticks = Math.ceil(totalFeet / 12);
      if(sticks > 0){
        addPicketSticks(size, sticks);
      }
    });

    // Rails: patches & replacements → sticks
    const railStickBySizeMat = {};
    const patchBySizeMat = {};
    const replBySizeMat = {};
    const gapBySizeMat = {};
    function inc(map, key, delta){ if(!key) return; map[key] = (map[key]||0) + (delta||0); }

    state.sections.forEach(s=>{
      const rCount = s.railsCount || (s.rails||[]).length || 0;
      for(let i=0;i<rCount;i++){
        const r = (s.rails||[])[i] || {};
        const p = parseInt(r.patches||0,10) || 0;
        const rep = parseInt(r.replacements||0,10) || 0;
        if(p>0){
          inc(patchBySizeMat, normalizeSize(r.size), p);
          if(r.stacked) inc(patchBySizeMat, normalizeSize(r.size2), p);
        }
        if(rep>0){
          inc(replBySizeMat, normalizeSize(r.size), rep);
          if(r.stacked) inc(replBySizeMat, normalizeSize(r.size2), rep);
        }
      }
      const gapArr = Array.isArray(s.gapAdditions) ? s.gapAdditions : [];
      gapArr.forEach(item=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        if(qty<=0) return;
        const normalized = normalizeSize(item?.size);
        inc(gapBySizeMat, normalized, qty);
      });
    });

    Object.entries(replBySizeMat).forEach(([size, rep])=>{
      if(rep>0) inc(railStickBySizeMat, size, rep);
    });

    Object.entries(gapBySizeMat).forEach(([size, gapCount])=>{
      if(gapCount>0) inc(railStickBySizeMat, size, gapCount);
    });

    Object.entries(patchBySizeMat).forEach(([size, pcount])=>{
      const credits = replBySizeMat[size] || 0;
      const remaining = Math.max(0, (pcount||0) - credits);
      if(remaining>0){
        inc(railStickBySizeMat, size, Math.ceil(remaining/6));
      }
    });

    Object.keys(railStickBySizeMat).forEach(size=>{
      addRailSticks(size, railStickBySizeMat[size]);
    });

    // Paint estimates
    let totalLenPaint = 0;
    let totalLenPrimePaint = 0;
    let totalLenSpot  = 0;
    state.sections.forEach(s=>{
      const len = (parseInt(s.length||0,10) || 0);
      if(!len) return;
      if (s.painting === 'Paint Section') {
        totalLenPaint += len;
      } else if (s.painting === 'Prime and Paint') {
        totalLenPaint += len;
        totalLenPrimePaint += len;
      } else if (s.painting === 'Spot Paint Welds') {
        totalLenSpot += len;
      }
    });
    paintLenTotal = totalLenPaint;
    paintGallons  = Math.ceil(totalLenPaint / 100);
    if (paintGallons > 0) paintCans += Math.ceil(paintGallons * 0.5);
    primerGallons = Math.ceil(totalLenPrimePaint / 100);
    if (primerGallons > 0) primerCans += Math.ceil(primerGallons * 0.5);
    if (totalLenSpot > 0) {
      const unitsSpot = Math.ceil(totalLenSpot / 100);
      paintCans += Math.max(1, Math.ceil(unitsSpot * 0.5));
    }
    if (paintGallons > 0) addMat(materials, 'gallons of gloss black paint', paintGallons);
    if (paintCans > 0)    addMat(materials, 'spray cans (gloss black)', paintCans);
    if (primerGallons > 0) addMat(materials, 'gallons of red oxide primer', primerGallons);
    if (primerCans > 0)    addMat(materials, 'spray cans (red oxide primer)', primerCans);

    // Finials (descriptive labels) for MATERIALS list
    state.sections.forEach(s=>{
      const arr = Array.isArray(s.finials) ? s.finials : [];
      arr.forEach(f=>{
        const q = parseInt(f?.qty||0,10) || 0; if(!q) return;
        const picketLabel = normalizeSize(f?.picketSize);
        addMat(materials, `finials - ${f.material} - ${f.style} (${picketLabel})`, q);
      });
    });
    // Caps (descriptive labels) for MATERIALS list
    state.sections.forEach(s=>{
      const arr = Array.isArray(s.caps) ? s.caps : [];
      arr.forEach(c=>{
        const q = parseInt(c?.qty||0,10) || 0; if(!q) return;
        addMat(materials, `caps - ${c.material} - ${c.style} (${c.postSize})`, q);
      });
    });

    // ===== Panel purchase vs build materials & direct costs =====
    let costPanels = 0;
    state.sections.forEach(s=>{
      const lst = s._panelCalc || [];
      lst.forEach(p=>{
        if(p.eligible){
          const price = PANEL_PRICE[pkey(p.feet, p.picketSize, p.style)];
          const unit = (typeof price==='number') ? price : 0;
          costPanels += p.qty * unit;
          const panelDescParts = [];
          if(p.height) panelDescParts.push(p.height);
          if(p.style) panelDescParts.push(p.style);
          const styleText = p.style || '';
          const hasFinialsInStyle = /Finials?/i.test(styleText);
          const isFlatTopStyle = /Flat Top/i.test(styleText);
          if(p.finialStyle && !hasFinialsInStyle && !isFlatTopStyle){
            panelDescParts.push(`(${p.finialStyle})`);
          }
          const picketLabel = p.picketSize ? `${p.picketSize} pickets` : '';
          const panelDesc = panelDescParts.length ? panelDescParts.join(' ') : 'wrought iron';
          const labelParts = [`prefab fence panel ${panelDesc}`];
          if(picketLabel) labelParts.push(`(${picketLabel})`);
          addMat(materials, labelParts.join(' '), p.qty);
          // No extra raw steel for prefab
        } else {
          // Build on site: rails (2 per panel) and pickets per width
          const totalRailInches = 2 * p.widthIn * p.qty; // two horizontals
          const railFeet = totalRailInches / 12;
          const railSticks = Math.ceil(railFeet / 12);
          addRailSticks(p.railSize, railSticks);

          const picketsPerPanel = picketCountForWidth(p.widthIn, p.picketSize);
          // assume picket height = selected panel height in inches (fallback 54)
          let ph = p.feet>0 ? p.feet*12 : 54;
          const perStick = Math.max(1, Math.floor(144 / ph));
          const totalPickets = picketsPerPanel * p.qty;
          const picketSticks = Math.ceil(totalPickets / perStick);
          addPicketSticks(p.picketSize, picketSticks);
        }
      });
    });

    // ===== Costing =====
    let unpriced = false;
    const matBreak = [];
    let costMaterials = 0;

    if(totals.retainingWallCost > 0){
      costMaterials += totals.retainingWallCost;
      matBreak.push('  - Retaining wall installation: $'+money(totals.retainingWallCost)+' ($35/sq ft, $1,500 minimum)');
    }

    // PRICE_MISC line-items
    Object.entries(materials).forEach(([label, qty])=>{
      if(Object.prototype.hasOwnProperty.call(PRICE_MISC, label)){
        const unit = PRICE_MISC[label] || 0;
        const c = qty * unit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
      }
    });

    if(costPanels>0){
      costMaterials += costPanels;
      matBreak.push('  - Prefab fence panels: $'+money(costPanels));
    }

    if(paintGallons>0){
      const c = paintGallons * PRICE.paintGallon;
      costMaterials += c;
      matBreak.push('  - Paint (gallons): '+paintGallons+' x $'+money(PRICE.paintGallon)+' = $'+money(c));
    }
    if(paintCans>0){
      const c = paintCans * PRICE.paintCan;
      costMaterials += c;
      matBreak.push('  - Paint (spray cans): '+paintCans+' x $'+money(PRICE.paintCan)+' = $'+money(c));
    }
    if(primerGallons>0){
      const c = primerGallons * PRICE.primerGallon;
      costMaterials += c;
      matBreak.push('  - Red oxide primer (gallons): '+primerGallons+' x $'+money(PRICE.primerGallon)+' = $'+money(c));
    }
    if(primerCans>0){
      const c = primerCans * PRICE.primerCan;
      costMaterials += c;
      matBreak.push('  - Red oxide primer (spray cans): '+primerCans+' x $'+money(PRICE.primerCan)+' = $'+money(c));
    }

    const concreteBagsMat = (materials['Maximizer bags of concrete']||0);
    if(concreteBagsMat>0){
      const c = concreteBagsMat * PRICE.concrete;
      costMaterials += c;
      matBreak.push('  - Concrete (Maximizer): '+concreteBagsMat+' x $'+money(PRICE.concrete)+' = $'+money(c));
    }

    const posts2x2CountsCost = {};
    Object.keys(materials).forEach(k=>{
      const m = k.match(/^2x2x(\d+)\s+posts$/);
      if(m){ posts2x2CountsCost[m[1]] = (posts2x2CountsCost[m[1]]||0) + materials[k]; }
    });
    Object.entries(posts2x2CountsCost).forEach(([lenStr, qty])=>{
      const len = parseInt(lenStr,10) || 0;
      let unit = PRICE.post2x2[len];
      if(unit==null){
        const perFt = PRICE_FT['2x2\"']||0;
        unit = perFt * len;
      }
      const c = qty * (unit||0);
      if((unit||0)===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 2x2x'+len+' posts: '+qty+' x $'+money(unit)+' = $'+money(c));
    });

    const raw1p5Count = steelStickTotals.raw1p5 || 0;
    if(raw1p5Count>0){
      const perFt1p5 = PRICE_FT['1 1/2\"'] || 0;
      const unit1p5 = 12 * perFt1p5;
      if(perFt1p5 === 0) unpriced = true;
      const c = raw1p5Count * unit1p5;
      costMaterials += c;
      matBreak.push('  - 1.5x1.5 raw steel sticks: '+raw1p5Count+' x 12ft x $'+money(perFt1p5)+'/ft = $'+money(c));
    }

    const raw3x3Count = steelStickTotals.raw3x3 || 0;
    if(raw3x3Count>0){
      const unit3x3 = 12 * (PRICE_FT['3x3\"']||0);
      const c = raw3x3Count * unit3x3;
      costMaterials += c;
      matBreak.push('  - 3x3 raw steel sticks: '+raw3x3Count+' x 12ft x $'+money(PRICE_FT['3x3\"']||0)+'/ft = $'+money(c));
    }

    const raw4x4Count = steelStickTotals.raw4x4 || 0;
    if(raw4x4Count>0){
      const unit4x4 = 139.73;
      const c = raw4x4Count * unit4x4;
      costMaterials += c;
      matBreak.push('  - 4x4 raw steel sticks: '+raw4x4Count+' x $'+money(unit4x4)+' = $'+money(c));
    }

    Object.keys(picketStickTotals).sort().forEach(size=>{
      const qty = picketStickTotals[size];
      const perFt = PRICE_FT[size]||0;
      const c = qty * 12 * perFt;
      if(perFt===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 12ft picket sticks '+size+': '+qty+' x 12ft x $'+money(perFt)+'/ft = $'+money(c));
    });

    Object.keys(railStickTotals).sort().forEach(size=>{
      const qty = railStickTotals[size];
      const perFt = PRICE_FT[size]||0;
      const c = qty * 12 * perFt;
      if(perFt===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 12ft rail sticks '+size+': '+qty+' x 12ft x $'+money(perFt)+'/ft = $'+money(c));
    });

    // NEW: Finials cost (flat $1.25 each via total of descriptive labels)
    const finialsPricedUnit = PRICE_MISC['replacement finial'] || 0;
    const finialsTotalForCost = Object.keys(materials).reduce((acc,k)=>{
      if(k.startsWith('finials - ')) return acc + (materials[k]||0);
      return acc;
    }, 0);
    if(finialsTotalForCost>0){
      const c = finialsTotalForCost * finialsPricedUnit;
      costMaterials += c;
      matBreak.push('  - Replacement finials: '+finialsTotalForCost+' x $'+money(finialsPricedUnit)+' = $'+money(c));
    }

    // NEW: Caps cost by size/style
    Object.entries(materials).forEach(([label, qty])=>{
      const m = label.match(CAP_LABEL_RE);
      if(!m) return;
      const style = m[2];
      const postSize = m[3];
      let unit = 0;
      // Normalize style to handle typos like "bal" -> "ball"
      const styleNorm = String(style||'').toLowerCase();
      const isBall = /ball/.test(styleNorm);
      if(postSize === '1 1/2" x 1 1/2"' || postSize === '2x2'){
        unit = isBall ? 4 : 1;
      } else if(postSize === '3x3'){
        unit = isBall ? 7 : 2;
      } else if(postSize === '4x4'){
        unit = isBall ? 15 : 8;
      } else {
        unit = 0;
        unpriced = true;
      }
      const c = qty * unit;
      costMaterials += c;
      matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
    });

    // Labor + totals
    let primePaintReturnHours = 0;
    let sprayBaseHours = 0;
    let sprayFinishHours = 0;
    const paintingHours = state.sections.reduce((acc, s)=>{
      if (s.painting !== 'Paint Section' && s.painting !== 'Prime and Paint') return acc;
      const len = parseInt(s.length||0,10) || 0;
      const method = s.paintingApplication || 'By Hand';
      let totalSectionHours = 0;
      if(method === 'Spray'){
        let panelCount = 0;
        if(Array.isArray(s.panels)){
          panelCount = s.panels.reduce((sum, panel)=>{
            const qty = parseInt(panel?.qty||0, 10) || 0;
            return sum + qty;
          }, 0);
        }
        if(panelCount <= 0 && len > 0){
          panelCount = Math.max(1, Math.ceil(len / 8));
        }
        if(panelCount > 0){
          totalSectionHours = panelCount / 4;
        }
      }else{
        if(!len) return acc;
        const railsPenalty = railPacePenalty(s.railsCount || (s.rails||[]).length || 0);
        const denom = styleFactor(s.style) - puppyAdj(s.puppy) - railsPenalty;
        const baseHours = (len/8) / Math.max(0.5, denom);
        const hardscapeHours = (parseInt(s.hardscape||0,10)||0) / 20;
        const trimHours = (parseInt(s.trim||0,10)||0) / 50;
        totalSectionHours = baseHours + hardscapeHours + trimHours;
      }
      if(totalSectionHours <= 0) return acc;
      if(method === 'Spray'){
        sprayBaseHours += totalSectionHours;
      }
      if (s.painting === 'Prime and Paint'){
        primePaintReturnHours += totalSectionHours;
        if(method === 'Spray'){
          sprayFinishHours += totalSectionHours;
        }
      }
      return acc + totalSectionHours;
    }, 0);
    manHours += paintingHours + primePaintReturnHours;
    helperHours += paintingHours + primePaintReturnHours;
    welderHours += sprayBaseHours + sprayFinishHours;

    function describeCrewSplit(welders, helpers){
      const parts = [];
      if(welders > 0){ parts.push(`${welders} ${welders === 1 ? 'welder' : 'welders'}`); }
      if(helpers > 0){ parts.push(`${helpers} ${helpers === 1 ? 'helper' : 'helpers'}`); }
      return parts.join(' + ');
    }

    const crewDef = getCrewDefinition(state.crew);
    const primePaintScheduled = totalLenPrimePaint > 0;
    const HOURS_PER_PERSON = 7;
    const hasInstallOrReplace = (totals.installSections > 0) || (totals.replaceSections > 0);
    const requiresTwoPersonCrew = hasInstallOrReplace || (totals.postsRealignCutWeld > 0) || woodRequiresTwoPerson;
    const minCrewBase = requiresTwoPersonCrew ? 2 : 1;
    const MIN_CREW_PER_DAY = Math.max(minCrewBase, crewDef && typeof crewDef.minCrew === 'number' ? crewDef.minCrew : 1);
    const MAX_CREW_PER_DAY = crewDef && typeof crewDef.maxCrew === 'number' ? crewDef.maxCrew : 7;
    const MAX_WELDERS = Math.max(0, crewDef && typeof crewDef.maxWelders === 'number' ? crewDef.maxWelders : MAX_CREW_PER_DAY);
    const day2Hours = primePaintReturnHours;
    const helperHoursDay2 = day2Hours;
    const helperHoursDay1 = Math.max(0, helperHours - helperHoursDay2);
    const finishWelderHours = sprayFinishHours;
    const baseWelderHours = Math.max(0, welderHours - finishWelderHours);
    const baseHelperHours = Math.max(0, helperHoursDay1);

    const baseDays = [];
    let remainingWelderHours = baseWelderHours;
    let remainingHelperHours = baseHelperHours;
    while(remainingWelderHours > 0.01 || remainingHelperHours > 0.01){
      let welderCount = 0;
      if(remainingWelderHours > 0.01){
        const welderNeeded = Math.ceil(remainingWelderHours / HOURS_PER_PERSON);
        welderCount = Math.max(1, Math.min(welderNeeded, MAX_WELDERS, MAX_CREW_PER_DAY));
      }
      let helperCount = 0;
      if(remainingHelperHours > 0.01){
        const helperNeeded = Math.ceil(remainingHelperHours / HOURS_PER_PERSON);
        helperCount = Math.min(helperNeeded, Math.max(0, MAX_CREW_PER_DAY - welderCount));
      }
      let crewCount = welderCount + helperCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, welderCount));
      }
      if(crewCount <= 0){
        crewCount = Math.min(MAX_CREW_PER_DAY, MIN_CREW_PER_DAY);
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      helperCount = Math.min(helperCount, Math.max(0, crewCount - welderCount));
      if(welderCount + helperCount < crewCount){
        helperCount = crewCount - welderCount;
      }
      baseDays.push({ crew: crewCount, welderCount, helperCount });
      remainingWelderHours = Math.max(0, remainingWelderHours - welderCount * HOURS_PER_PERSON);
      remainingHelperHours = Math.max(0, remainingHelperHours - helperCount * HOURS_PER_PERSON);
      if(welderCount === 0 && helperCount === 0){
        break;
      }
    }

    const finishDays = [];
    let remainingFinishWelderHours = finishWelderHours;
    let remainingFinishHelperHours = helperHoursDay2;
    while(remainingFinishWelderHours > 0.01 || remainingFinishHelperHours > 0.01){
      let welderCount = 0;
      if(remainingFinishWelderHours > 0.01){
        const welderNeeded = Math.ceil(remainingFinishWelderHours / HOURS_PER_PERSON);
        welderCount = Math.max(1, Math.min(welderNeeded, MAX_WELDERS, MAX_CREW_PER_DAY));
      }
      let helperCount = 0;
      if(remainingFinishHelperHours > 0.01){
        const helperNeeded = Math.ceil(remainingFinishHelperHours / HOURS_PER_PERSON);
        helperCount = Math.min(helperNeeded, Math.max(0, MAX_CREW_PER_DAY - welderCount));
      }
      let crewCount = welderCount + helperCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, welderCount));
      }
      if(crewCount <= 0){
        crewCount = Math.min(MAX_CREW_PER_DAY, MIN_CREW_PER_DAY);
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      helperCount = Math.min(helperCount, Math.max(0, crewCount - welderCount));
      if(welderCount + helperCount < crewCount){
        helperCount = crewCount - welderCount;
      }
      finishDays.push({ crew: crewCount, welderCount, helperCount });
      remainingFinishWelderHours = Math.max(0, remainingFinishWelderHours - welderCount * HOURS_PER_PERSON);
      remainingFinishHelperHours = Math.max(0, remainingFinishHelperHours - helperCount * HOURS_PER_PERSON);
      if(welderCount === 0 && helperCount === 0){
        break;
      }
    }

    const crewSchedule = [];
    baseDays.forEach(day => crewSchedule.push({ ...day, kind: primePaintScheduled ? 'prime' : 'base' }));
    finishDays.forEach(day => crewSchedule.push({ ...day, kind: 'finish' }));

    const crewLabelWithMix = (count, split) => {
      if(count <= 0) return '';
      const word = count === 1 ? 'guy' : 'guys';
      return split ? `${count} ${word} (${split})` : `${count} ${word}`;
    };

    const scheduleEntries = crewSchedule.map((day, idx) => {
      const split = describeCrewSplit(day.welderCount || 0, day.helperCount || 0);
      const crewLabel = crewLabelWithMix(day.crew, split);
      const suffix = day.kind === 'finish'
        ? ' (return for finish coat)'
        : (primePaintScheduled ? ' (prime/repairs)' : '');
      const cost = crewCostForCount(crewDef, day.crew);
      return {
        number: idx + 1,
        crewLabel,
        suffix,
        cost,
      };
    });

    let durationStr = 'TBD';
    if(scheduleEntries.length === 1){
      const entry = scheduleEntries[0];
      durationStr = `1 day of work: ${entry.crewLabel}${entry.suffix}`;
    } else if(scheduleEntries.length > 1){
      const parts = scheduleEntries.map(entry => `Day ${entry.number}: ${entry.crewLabel}${entry.suffix}`);
      durationStr = `${scheduleEntries.length} days of work: ${parts.join(', ')}`;
    }

    lines.push('');
    lines.push('CREW');
    lines.push(`- Lead: ${crewSummary(crewDef)}`);
    if(scheduleEntries.length){
      scheduleEntries.forEach(entry => {
        const dayTitle = entry.suffix ? `Day ${entry.number}${entry.suffix}` : `Day ${entry.number}`;
        const costPart = entry.cost > 0 ? ` ($${money(entry.cost)})` : '';
        lines.push(`- ${dayTitle}: ${entry.crewLabel}${costPart}`);
      });
    } else {
      lines.push('- Schedule: TBD');
    }

    const materialEntries = Object.keys(materials)
      .filter(label => materials[label] > 0)
      .sort((a, b) => a.localeCompare(b))
      .map(label => ({ label, qty: materials[label] }));

    if (materialEntries.length) {
      lines.push('');
      lines.push('MATERIALS');
      materialEntries.forEach(({ label, qty }) => {
        lines.push(`- ${qty}x ${label}`);
      });
    }

    const sub = [];
    sub.push(`CREW: ${crewSummary(crewDef)}`);
    if(scheduleEntries.length){
      scheduleEntries.forEach(entry => {
        const dayTitle = entry.suffix ? `Day ${entry.number}${entry.suffix}` : `Day ${entry.number}`;
        const costPart = entry.cost > 0 ? ` ($${money(entry.cost)})` : '';
        sub.push(`- ${dayTitle}: ${entry.crewLabel}${costPart}`);
      });
    } else {
      sub.push('- Schedule: TBD');
    }
    sub.push('');
    sub.push('JOB DURATION');
    sub.push('- '+durationStr);
    sub.push('');
    sub.push('MATERIALS');
    materialEntries.forEach(({ label, qty }) => {
      sub.push(`- ${qty}x ${label}`);
    });

    sub.push('');
    sub.push('SCOPE (Totals)');
    if (totals.replaceSections > 0) sub.push('- Sections to replace: '+totals.replaceSections);
    if (totals.installSections > 0) sub.push('- New sections to install: '+totals.installSections);
    if (totals.removalLf > 0)       sub.push(`- Removal & haul away: ${totals.removalLf} lf (sub paid $${money(totals.removalCost)})`);
    if (totals.wiPickets > 0)       sub.push('- Pickets to replace: '+totals.wiPickets);
    if (totals.wiPatches > 0)       sub.push('- Rail patches: '+totals.wiPatches);
    if (totals.wiRails > 0)         sub.push('- Full rail replacements: '+totals.wiRails);
    if (totals.wiRailGaps > 0)      sub.push('- Full rail gap fillers: '+totals.wiRailGaps);
    const pushPostLinesSub = (label, counts)=>{
      const parts = [];
      if(counts.posts1p5) parts.push(`${counts.posts1p5} × 1 1/2" x 1 1/2"`);
      if(counts.posts2x2) parts.push(`${counts.posts2x2} × 2x2`);
      if(counts.posts3x3) parts.push(`${counts.posts3x3} × 3x3`);
      if(counts.posts4x4) parts.push(`${counts.posts4x4} × 4x4`);
      if(parts.length) sub.push(`- ${label}: ${parts.join(', ')}`);
    };
    pushPostLinesSub('Posts to replace', totals.postsReplace || zeroPostCounts());
    pushPostLinesSub('Posts to set (new sections)', totals.postsInstall || zeroPostCounts());
    if (totals.postsRealign2x2 > 0) sub.push('- 2x2 posts to realign: '+totals.postsRealign2x2);
    if (totals.postsRealign3x3 > 0) sub.push('- 3x3 posts to realign: '+totals.postsRealign3x3);
    if (totals.postsRealignCutWeld > 0) sub.push('- Posts to realign (cut & weld): '+totals.postsRealignCutWeld);
    if (totals.walkGates > 0)       sub.push('- Walk gates: '+totals.walkGates);
    if (totals.walkRealign > 0)     sub.push('- Walk gates to realign: '+totals.walkRealign);
    if (totals.walkHardware > 0)    sub.push('- Walk gate hardware replacements: '+totals.walkHardware);
    if (totals.walkRebuild > 0)     sub.push('- Walk gates to rebuild: '+totals.walkRebuild);
    if (totals.walkGateAddsSingle > 0) sub.push('- Single swing walk gates to add: '+totals.walkGateAddsSingle);
    if (totals.walkGateAddsDouble > 0) sub.push('- Double swing gates to add: '+totals.walkGateAddsDouble);
    if (totals.finials > 0)         sub.push('- Finials to replace: '+totals.finials);
    if (totals.puppyInserts > 0)    sub.push('- Puppy picket inserts: '+totals.puppyInserts);
    if (totals.caps > 0)            sub.push('- Post caps to replace: '+totals.caps);
    if (installCapsByLabel.size > 0){
      installCapsByLabel.forEach((qty, label)=>{
        const m = label.match(CAP_LABEL_RE);
        if(m){
          const material = m[1];
          const style = m[2];
          const postSize = m[3];
          sub.push(`- Post caps to install: ${qty} × ${material} ${style} (${postSize})`);
        }else{
          sub.push(`- Post caps to install: ${qty}`);
        }
      });
    }
    if (totals.diagonalBraces > 0)  sub.push('- Diagonal braces to add: '+totals.diagonalBraces);
    if (totals.digOut > 0)          sub.push('- Dig out: '+totals.digOut+' lf');
    if (totals.panelsPrefab > 0)    sub.push('- Prefab panels to install: '+totals.panelsPrefab);
    if (totals.panelsCustom > 0)    sub.push('- Panels to custom-build: '+totals.panelsCustom);
    if (totals.panelsInstallPrefab > 0) sub.push('- New prefab panels: '+totals.panelsInstallPrefab);
    if (totals.panelsInstallCustom > 0) sub.push('- New custom panels: '+totals.panelsInstallCustom);
    if (totals.retainingWallSqft > 0) sub.push(`- Retaining wall: ${totals.retainingWallSqft.toFixed(2)} sq ft ($${money(totals.retainingWallCost)})`);
    if (paintLenTotal > 0)          sub.push('- Scrape off loose rust and debris, then hand paint '+paintLenTotal+' ft of fence');
    if (totalLenPrimePaint > 0)     sub.push('- Prime with red oxide primer and schedule a return visit after cure to apply the finish coat');

    if (notesSubEl) { notesSubEl.value = sub.join('\n'); }

    const totalCrewCount = crewSchedule.reduce((acc, day) => acc + (day.crew || 0), 0);
    const crewCost = crewSchedule.reduce((acc, day) => acc + crewCostForCount(crewDef, day.crew), 0);
    const consumablesCost = scheduleEntries.length * 50;
    const removalCost = totals.removalCost || 0;
    const directCosts = crewCost + costMaterials + removalCost + consumablesCost;
    const revenueRes = computeChargeRevenue(directCosts);
    const revenue = revenueRes && isFinite(revenueRes.revenue) ? revenueRes.revenue : NaN;
    const revenueExcludingMcor = revenue * (1 - RATES.mcor);
    const commissionFormula$ = isFinite(revenue)
      ? (RATES.commission * (((1 - RATES.overhead) * revenueExcludingMcor) - directCosts))
      : NaN;

    const cost = [];
    cost.push('ESTIMATED COST');
    const crewScheduleDetail = scheduleEntries.map(entry => {
      const dayTitle = entry.suffix ? `Day ${entry.number}${entry.suffix}` : `Day ${entry.number}`;
      const costPart = entry.cost > 0 ? ` ($${money(entry.cost)})` : '';
      return `${dayTitle}: ${entry.crewLabel}${costPart}`;
    });
    const laborDetailWithDays = crewScheduleDetail.length
      ? `${crewScheduleDetail.join('; ')}; total crew-equivalent: ${totalCrewCount}`
      : 'TBD';
    const laborLabel = crewDef ? `${crewDef.label}` : 'Crew';
    cost.push(`- Labor (${laborLabel}): $${money(crewCost)} (${laborDetailWithDays})`);
    cost.push('- Consumables: $'+money(consumablesCost));
    cost.push('- Materials: $'+money(costMaterials));
    if(removalCost>0){ cost.push('- Removal & disposal (paid to sub): $'+money(removalCost)); }
    matBreak.forEach(line=> cost.push(line));
    cost.push('- Total: $'+money(crewCost + costMaterials + removalCost + consumablesCost));
    if (unpriced) cost.push('  - Note: Some sizes have no price mapping and were counted as $0.');

    cost.push('');
    cost.push('WHAT TO CHARGE');
    if (!isFinite(revenue)){
      cost.push('⚠️ Pricing inputs produce an invalid result. Check RATES (commission, net target, overhead, MCOR, CAC).');
    } else {
      cost.push('- Price to charge: $'+money(revenue));
      cost.push('- Commission (per formula): $'+money(commissionFormula$));
    }

    const idxTotals = lines.indexOf('TOTALS');
    const outLines = (idxTotals >= 0)
      ? [...lines.slice(idxTotals), '', ...lines.slice(0, idxTotals)]
      : lines;
    const fullNotes = [...outLines, '', ...cost];

    const inHouseCrewIds = ['in-house-4', 'in-house-3', 'in-house-3-4'];
    const inHouseScenarioLines = [];
    inHouseScenarioLines.push('IN-HOUSE CREW SCENARIOS (if selected for this scope)');
    inHouseCrewIds.forEach(id => {
      const def = CREWS[id];
      if (!def) return;
      const altCrewCost = crewSchedule.reduce((acc, day) => acc + crewCostForCount(def, day.crew), 0);
      const altDirectCosts = altCrewCost + costMaterials + removalCost + consumablesCost;
      const altRevenueRes = computeChargeRevenue(altDirectCosts);
      const altRevenue = altRevenueRes && isFinite(altRevenueRes.revenue) ? altRevenueRes.revenue : NaN;
      const revenueLabel = isFinite(altRevenue) ? `$${money(altRevenue)}` : 'Invalid pricing inputs';
      inHouseScenarioLines.push(`- ${def.label}: total cost $${money(altDirectCosts)}; total revenue ${revenueLabel}`);
    });

    const fullNotesWithScenarios = [...fullNotes, '', ...inHouseScenarioLines];
    notesEl.value = fullNotesWithScenarios.join('\n');
    outputEl.style.display = 'grid';
    if (window.parentIFrame && typeof window.parentIFrame.size === 'function') {
      try { window.parentIFrame.size(); } catch(e){}
    }
    if(shouldScroll){
      scrollTo(outputEl);
    }
    persist();
    } finally {
      isGeneratingNotes = false;
    }
  }

  function renderServiceLineNotes(items){
    lastServiceLines = Array.isArray(items) ? items.map(item=>({ ...item })) : [];

    if(!serviceListEl || !serviceCardEl){
      return;
    }

    serviceListEl.innerHTML = '';

    if(!lastServiceLines.length){
      serviceCardEl.style.display = 'none';
      if(serviceCopyAllBtn){
        serviceCopyAllBtn.disabled = true;
        serviceCopyAllBtn.textContent = 'Copy All';
      }
      return;
    }

    serviceCardEl.style.display = 'block';
    if(serviceCopyAllBtn){
      serviceCopyAllBtn.disabled = false;
      serviceCopyAllBtn.textContent = 'Copy All';
    }

    lastServiceLines.forEach((item, index)=>{
      const lineEl = document.createElement('div');
      lineEl.className = 'sp-service-line';
      lineEl.dataset.index = String(index);

      const titleField = document.createElement('div');
      titleField.className = 'sp-field';
      const titleLabel = document.createElement('label');
      titleLabel.className = 'sp-label';
      titleLabel.textContent = 'Line Item Title';
      const titleRow = document.createElement('div');
      titleRow.className = 'sp-copy-row';
      const titleInput = document.createElement('input');
      titleInput.className = 'sp-input';
      titleInput.readOnly = true;
      titleInput.value = item.name || '';
      const titleBtn = document.createElement('button');
      titleBtn.className = 'sp-btn ghost sp-copy-service';
      titleBtn.type = 'button';
      titleBtn.textContent = 'Copy';
      titleBtn.dataset.text = item.name || '';
      titleBtn.dataset.kind = 'title';
      titleRow.appendChild(titleInput);
      titleRow.appendChild(titleBtn);
      titleField.appendChild(titleLabel);
      titleField.appendChild(titleRow);

      const descField = document.createElement('div');
      descField.className = 'sp-field';
      const descLabel = document.createElement('label');
      descLabel.className = 'sp-label';
      descLabel.textContent = 'Description';
      const descRow = document.createElement('div');
      descRow.className = 'sp-copy-row';
      const descTextarea = document.createElement('textarea');
      descTextarea.className = 'sp-textarea';
      descTextarea.readOnly = true;
      descTextarea.value = item.desc || '';
      const descBtn = document.createElement('button');
      descBtn.className = 'sp-btn ghost sp-copy-service';
      descBtn.type = 'button';
      descBtn.textContent = 'Copy';
      descBtn.dataset.text = item.desc || '';
      descBtn.dataset.kind = 'description';
      descRow.appendChild(descTextarea);
      descRow.appendChild(descBtn);
      descField.appendChild(descLabel);
      descField.appendChild(descRow);

      lineEl.appendChild(titleField);
      lineEl.appendChild(descField);

      serviceListEl.appendChild(lineEl);
    });
  }

  function copyTextToClipboard(text){
    const value = (typeof text === 'string') ? text : String(text || '');
    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function'){
      return navigator.clipboard.writeText(value);
    }

    return new Promise((resolve, reject)=>{
      const textarea = document.createElement('textarea');
      textarea.value = value;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.top = '-9999px';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        const ok = document.execCommand('copy');
        document.body.removeChild(textarea);
        if(ok) resolve();
        else reject(new Error('Copy command was rejected.'));
      } catch(err){
        document.body.removeChild(textarea);
        reject(err);
      }
    });
  }

  function flashButton(btn, message='Copied!', options){
    if(!btn) return;
    const opts = Object.assign({ revertMs: 1200, disable: true }, options || {});
    const originalText = btn.textContent;
    const originalDisabled = btn.disabled;
    btn.textContent = message;
    if(opts.disable){
      btn.disabled = true;
    }
    window.setTimeout(()=>{
      btn.textContent = originalText;
      if(opts.disable){
        btn.disabled = originalDisabled;
      }
    }, opts.revertMs);
  }

  function copyAllServiceLines(){
    if(!lastServiceLines.length || !serviceCopyAllBtn){
      return;
    }
    const text = lastServiceLines.map(item=>`${item.name}: ${item.desc}`).join('\n');
    copyTextToClipboard(text)
      .then(()=>flashButton(serviceCopyAllBtn))
      .catch(()=>flashButton(serviceCopyAllBtn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function handleServiceListClick(event){
    const btn = event.target.closest('.sp-copy-service');
    if(!btn){
      return;
    }
    const text = btn.dataset && typeof btn.dataset.text !== 'undefined' ? btn.dataset.text : '';
    copyTextToClipboard(text)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function numOrDash(v){ const n = parseInt(v,10); return isNaN(n)?'—':n; }
  function scrollTo(el){ el.scrollIntoView({behavior:'smooth', block:'start'}); }

  function copyNotes(){
    const btn = document.getElementById('sp-copy');
    if(!notesEl || !btn) return;
    notesEl.select();
    copyTextToClipboard(notesEl.value)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copySubNotes(){
    const btn = document.getElementById('sp-copy-sub');
    if(!notesSubEl || !btn) return;
    notesSubEl.select();
    copyTextToClipboard(notesSubEl.value)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  async function pushNotesToHcp(){
    if(!pushHcpBtn || !estimateNumberInput){ return; }

    const rawNumber = (estimateNumberInput.value || '').trim();
    if(!rawNumber){
      alert('Please enter the Housecall Pro estimate number.');
      estimateNumberInput.focus();
      return;
    }

    const estimateNumber = rawNumber.replace(/[^0-9]/g, '');
    if(!estimateNumber){
      alert('The estimate number must contain at least one digit.');
      estimateNumberInput.focus();
      return;
    }

    const notes = (notesEl && notesEl.value || '').trim();
    const notesSub = (notesSubEl && notesSubEl.value || '').trim();
    const serviceLinesPayload = Array.isArray(lastServiceLines)
      ? lastServiceLines
          .map(item=>({
            title: (item && item.name ? String(item.name).trim() : ''),
            description: (item && item.desc ? String(item.desc).trim() : ''),
          }))
          .filter(item=>item.title || item.description)
      : [];
    if(!notes){
      alert('There are no notes to send yet. Generate notes first.');
      return;
    }

    if(typeof fetch !== 'function'){
      alert('This browser does not support automatic note sending. Please copy the notes manually.');
      return;
    }

    const originalText = pushHcpBtn.textContent;
    pushHcpBtn.disabled = true;
    pushHcpBtn.textContent = 'Pushing...';

    try{
      const payload = {
        estimateNumber,
        notes,
        notesSub,
      };

      if(serviceLinesPayload.length){
        payload.serviceLines = serviceLinesPayload;
      }

      const response = await fetch('https://api.strongclicks.io/webhook/add-notes-to-hcp-estimate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if(!response.ok){
        const text = await response.text();
        throw new Error(text || `Request failed with status ${response.status}`);
      }

      alert('Notes sent to Housecall Pro.');
    }catch(err){
      console.error('Failed to push notes to HCP', err);
      alert('Failed to push notes to Housecall Pro. Please try again.');
    }finally{
      pushHcpBtn.disabled = false;
      pushHcpBtn.textContent = originalText;
    }
  }

  const KEY = 'sp_scope_v1';

  function scheduleAutoGenerateNotes(){
    if(isGeneratingNotes){
      return;
    }
    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
    }
    autoGenerateTimer = window.setTimeout(()=>{
      autoGenerateTimer = null;
      if(isGeneratingNotes){
        return;
      }
      try{
        generateNotes({ skipScroll: true });
      }catch(err){
        console.error('Auto note generation failed', err);
      }
    }, 250);
  }

  function persist(){
    if(isGeneratingNotes){
      return;
    }
    scheduleAutoGenerateNotes();
  }

  function restore(){
    try { localStorage.removeItem(KEY); } catch(e){}
    return false;
  }
  function resetAll(){
    if(!confirm('Clear all sections?')) return;
    clearMapDrawing({ skipSections: true });
    state.sections = [];
    state.crew = DEFAULT_CREW_ID;
    localStorage.removeItem(KEY);
    render();
    outputEl.style.display='none';
    renderServiceLineNotes([]);
  }

  window._spInitializeMap = initializeMap;
  if(window._spGoogleMapsReady){
    initializeMap();
  }
  updateMapControlsUI();

  const mapClearBtn = document.getElementById('sp-map-clear');
  if(mapClearBtn){
    mapClearBtn.addEventListener('click', ()=>{
      syncStateFromDOM();
      const hasLinkedSections = state.sections.some(sec=>sec.mapGenerated);
      if(!mapState.polylines.length && !hasLinkedSections) return;
      if(!confirm('Remove all map drawings and linked sections?')) return;
      clearMapDrawing();
    });
  }

  if(crewSelectEl){
    crewSelectEl.addEventListener('change', ()=>{
      state.crew = crewSelectEl.value || DEFAULT_CREW_ID;
      if(!(state.crew in CREWS)){ state.crew = DEFAULT_CREW_ID; }
      updateCrewUI();
      persist();
    });
  }

  document.getElementById('sp-add').addEventListener('click', ()=>{ addSection(); persist(); });
  document.getElementById('sp-complete').addEventListener('click', generateNotes);
  document.getElementById('sp-copy').addEventListener('click', copyNotes);
  document.getElementById('sp-copy-sub').addEventListener('click', copySubNotes);
  if(estimateNumberInput){
    estimateNumberInput.addEventListener('input', ()=>{
      const digits = sanitizeEstimateNumber(estimateNumberInput.value || '');
      if(!digits){
        if(estimateLookupController && typeof estimateLookupController.abort === 'function'){
          estimateLookupController.abort();
          estimateLookupController = null;
        }
        lastEstimateLookupNumber = '';
        lastEstimateAddress = '';
        updateEstimateStatus('', '');
      }
    });
    estimateNumberInput.addEventListener('keydown', evt=>{
      if(evt.key === 'Enter'){
        evt.preventDefault();
        runEstimateLookup();
      }
    });
  }
  if(estimateLookupBtn){
    estimateLookupBtn.addEventListener('click', ()=>runEstimateLookup());
  }
  if(pushHcpBtn){
    pushHcpBtn.addEventListener('click', pushNotesToHcp);
  }
  if(serviceCopyAllBtn){ serviceCopyAllBtn.addEventListener('click', copyAllServiceLines); }
  if(serviceListEl){ serviceListEl.addEventListener('click', handleServiceListClick); }
  document.getElementById('sp-reset').addEventListener('click', resetAll);

  const backTopBtn = document.getElementById('sp-top-btn');
  if (backTopBtn){
    backTopBtn.addEventListener('click', ()=> window.scrollTo({ top: 0, behavior: 'smooth' }));
  }

  if(estimateNumberInput && estimateNumberInput.value){
    runEstimateLookup();
  }

  if(!restore()){ addSection(); }
})();
});
</script>
<script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDW2GCWGKbnbA9lA2wPJSmciyMcghOZlxc&libraries=geometry,places,drawing&callback=initMap&loading=async"></script>
</body>
</html>
