<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scope Generator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="icon" type="image/svg+xml" href="assets/strong-perimeter-favicon.svg" />
  <style>
  :root{
    --sp-green:#004B3D;
    --sp-ink:#1d1d1f;
    --sp-muted:#6b7280;
    --sp-border:#e5e7eb;
    --sp-bg:#f8fafc;
    --sp-card:#ffffff;
    --sp-radius:14px;
    --sp-stage-bg:#EBEBEB;
    --sp-floating-offset:96px;
  }
  #sp-scope{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";color:var(--sp-ink)}
  #sp-scope *{box-sizing:border-box}

  body{margin:0;background:var(--sp-stage-bg);}  
  body,html{min-height:100%;}
  .sp-container{max-width:1320px;margin:0 auto;padding:24px 24px calc(40px + var(--sp-floating-offset, 0px))}
  .sp-header{display:flex;flex-wrap:wrap;align-items:center;gap:12px;justify-content:space-between;margin-bottom:18px}
  .sp-title{font-size:22px;font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px;line-height:1.2}
  .sp-badge{background:var(--sp-green);color:#fff;padding:4px 10px;border-radius:999px;font-size:12px;font-weight:700}

  .sp-actions{display:flex;gap:10px;flex-wrap:wrap}
  .sp-btn{appearance:none;border:1px solid var(--sp-border);background:#fff;color:var(--sp-ink);padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:transform .02s ease,border-color .2s ease,background .2s ease;min-height:44px;font-size:14px;text-decoration:none}
  .sp-btn:active{transform:translateY(1px)}
  .sp-btn.primary{background:var(--sp-green);color:#fff;border-color:var(--sp-green)}
  .sp-btn.ghost{background:#fff}
  .sp-btn.danger{background:#fff;color:#b91c1c;border-color:#fecaca}
  .sp-btn.danger.is-confirm{background:#b91c1c;color:#fff;border-color:#b91c1c}
  .sp-btn.is-hidden{display:none}

  .sp-sections{display:grid;gap:16px}
  .sp-onboard [data-gated]{
    display:none !important;
  }
  .sp-section-locked [data-section-detail]{
    display:none !important;
  }
  .sp-card{background:var(--sp-card);border:1px solid var(--sp-border);border-radius:var(--sp-radius);padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
  #sp-map-card{margin-bottom:16px}
  #sp-crew-card{margin-top:18px}
  .sp-inline-cards{display:grid;gap:16px;margin-bottom:16px}
  .sp-scope-group{border:1px solid var(--sp-border);background:#f8fafc;border-radius:12px;padding:14px;position:relative;overflow:hidden;gap:10px}
  .sp-scope-head{display:flex;gap:10px;align-items:flex-start;margin-bottom:8px}
  .sp-scope-pill{background:var(--accent, var(--sp-green));color:#fff;font-weight:800;font-size:12px;padding:4px 10px;border-radius:999px;letter-spacing:.4px;text-transform:uppercase}
  .sp-scope-title{font-weight:800;font-size:15px}
  .sp-scope-sub{color:var(--sp-muted);font-size:13px}
  .sp-scope-grid{gap:10px}
  .sp-scope-group.is-basics{--accent:#0f766e;background:#ecfdf3}
  .sp-scope-group.is-wood{--accent:#b45309;background:#fff7ed}
  .sp-scope-group.is-style{--accent:#4338ca;background:#eef2ff}
  .sp-scope-group.is-repair{
    --accent:#9f1239;
    background:#fff1f2;
    margin-block:20px;
  }
  .sp-scope-group.is-gates{--accent:#0ea5e9;background:#f0f9ff}
  .sp-card-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .sp-card-title{font-size:16px;font-weight:800}
  .sp-card.is-collapsed .sp-grid{display:none}

  .sp-grid{display:grid;gap:12px}
  @media(min-width:720px){
    .sp-grid{grid-template-columns:repeat(12,1fr)}
    .col-6{grid-column:span 6}
    .col-4{grid-column:span 4}
    .col-3{grid-column:span 3}
    .col-2{grid-column:span 2}
    .col-8{grid-column:span 8}
    .col-12{grid-column:span 12}
    .sp-inline-cards{grid-template-columns:repeat(2,minmax(0,1fr))}
  }
  @media(max-width:719px){
    .sp-container{padding:20px 16px calc(36px + var(--sp-floating-offset, 0px))}
    .sp-header{flex-direction:column;align-items:flex-start;gap:16px}
    .sp-title{font-size:20px}
    .sp-actions{width:100%;flex-direction:column;align-items:stretch}
    .sp-btn{width:100%}
    .sp-sections{gap:12px}
    .sp-card{padding:14px}
    #sp-map-card{margin-bottom:12px}
    #sp-crew-card{margin-top:16px}
    .sp-card-header{flex-direction:column;align-items:flex-start;gap:10px}
    .sp-card-header .sp-row{width:100%;justify-content:flex-start}
    .sp-card-title{font-size:18px}
    .sp-grid{gap:10px}
    .col-6,.col-4,.col-3,.col-2,.col-8,.col-12{grid-column:span 12}
    .sp-copy-row{flex-direction:column}
    .sp-copy-row .sp-btn{width:100%}
    .sp-row{width:100%;justify-content:flex-start}
    .sp-number{width:100%}
  }

  .sp-field{display:flex;flex-direction:column;gap:6px}
  .sp-label{font-size:12px;font-weight:800;color:var(--sp-muted);letter-spacing:.4px;text-transform:uppercase}
  .sp-input,.sp-select,.sp-textarea{border:1px solid var(--sp-border);border-radius:12px;padding:10px 12px;background:#fff;font-size:14px;width:100%}
  #sp-estimate-number{font-size:16px}
  .sp-textarea{min-height:68px;resize:vertical}
  .sp-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .sp-service-option-input{max-width:140px}
  .sp-crew-picker{
    display:grid;
    gap:8px;
    grid-template-columns:repeat(auto-fit,minmax(130px,1fr));
  }
  .sp-crew-option{
    display:flex;
    align-items:center;
    gap:8px;
    padding:8px 10px;
    border:1px solid var(--sp-border);
    border-radius:10px;
    background:#fff;
    font-size:14px;
    font-weight:600;
  }
  .sp-crew-option input{margin:0}

  /* Rail row (Rails count + all rail blocks on one row, top-aligned) */
  .sp-rail-row{
    display:grid;
    gap:12px;
    align-items:start;
  }
  .sp-rail-row > .sp-field{ align-self:start; }

  @media(min-width:720px){
    .sp-rail-row{ grid-template-columns: var(--rail-cols, repeat(3, minmax(200px,1fr))); }
  }
  @media(max-width:719px){
    .sp-rail-row{ grid-template-columns: 1fr; }
  }

  /* Number control */
  .sp-number{display:flex;align-items:stretch;border:1px solid var(--sp-border);border-radius:12px;overflow:hidden}
  .sp-number input{border:0;flex:1;min-width:0;padding:10px 12px;font-size:14px;-moz-appearance:textfield}
  .sp-number input::-webkit-outer-spin-button,.sp-number input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}
  .sp-step{min-width:46px;font-weight:900;display:grid;place-items:center;border:0;background:var(--sp-bg);cursor:pointer}
  .sp-step:active{filter:brightness(.95)}

  .sp-small{font-size:12px;color:var(--sp-muted)}
  .sp-output{margin-top:18px; display:grid; gap:16px}
  .sp-output textarea{width:100%;min-height:200px;border:1px solid var(--sp-border);border-radius:12px;padding:12px;background:#fff;font-size:14px}
  .sp-service-list{display:grid;gap:14px}
  .sp-service-line{display:grid;gap:12px}
  .sp-copy-row{display:flex;gap:8px;align-items:stretch}
  .sp-copy-row .sp-input,
  .sp-copy-row .sp-textarea{flex:1}
  .sp-copy-row .sp-textarea{min-height:80px}
  .sp-service-line .sp-textarea{resize:none;overflow:hidden}
  .sp-copy-row .sp-btn{white-space:nowrap}
  .sp-hint{font-size:12px;color:var(--sp-muted);margin-top:6px}
  .sp-hint[data-state="loading"]{color:#2563eb}
  .sp-hint[data-state="success"]{color:#047857}
  .sp-hint[data-state="warn"]{color:#b45309}
  .sp-hint[data-state="error"]{color:#b91c1c}
  .sp-divider{height:1px;background:var(--sp-border);margin:12px 0}
  .sp-chip{border:1px dashed var(--sp-border);padding:4px 8px;border-radius:999px;font-size:12px;color:var(--sp-muted)}
  .sp-chip.is-success{background:#ecfdf5;color:#047857;border-color:#bbf7d0}
  .sp-chip.is-error{background:#fef2f2;color:#b91c1c;border-color:#fecaca}
  .sp-chip.is-info{background:#eff6ff;color:#1d4ed8;border-color:#bfdbfe}
  .sp-chip.is-warn{background:#fffbeb;color:#b45309;border-color:#fde68a}
  .sp-floating-actions{
    position:fixed;
    left:0;
    right:0;
    bottom:0;
    z-index:9998;
    display:flex;
    gap:8px;
    padding:8px 10px;
    background:var(--sp-card);
    border:1px solid var(--sp-border);
    border-radius:0;
    box-shadow:0 4px 12px rgba(0,0,0,.1);
    align-items:center;
    justify-content:center;
    flex-direction:row;
    flex-wrap:nowrap;
    max-width:none;
    width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }
  .sp-floating-actions .sp-fab{
    appearance:none;
    border:1px solid var(--sp-border);
    background:var(--sp-bg);
    color:var(--sp-ink);
    border-radius:12px;
    padding:10px 12px;
    font-weight:800;
    min-width:48px;
    display:flex;
    align-items:center;
    gap:8px;
    cursor:pointer;
    transition:transform .02s ease, border-color .2s ease, background .2s ease;
    width:auto;
    flex:0 0 auto;
    white-space:nowrap;
  }
  .sp-floating-actions .sp-fab.danger{
    background:#ef4444;
    border-color:#b91c1c;
    color:#fff;
  }
  .sp-floating-actions .sp-fab:active{ transform:translateY(1px); }
  .sp-floating-actions .sp-fab-icon{
    display:grid;
    place-items:center;
    width:22px;
    height:22px;
    border-radius:8px;
    background:var(--sp-green);
    color:#fff;
    font-size:12px;
    font-weight:900;
  }
  .sp-floating-actions .sp-fab.danger .sp-fab-icon{
    background:#b91c1c;
  }
  .sp-floating-actions .sp-fab[disabled]{ opacity:0.5; cursor:not-allowed; }
  @media(max-width:719px){
    .sp-floating-actions{
      inset-inline:0;
      transform:none;
      left:0;
      right:0;
      justify-content:center;
      bottom:0;
      flex-direction:row;
      align-items:center;
      width:100%;
      max-width:none;
    }
    .sp-floating-actions .sp-fab{ flex:0 0 auto; justify-content:center; }
  }

  #sp-map{
    width:100%;
    height:580px;
    border-radius:12px;
    overflow:hidden;
  }
  .sp-map-note{
    margin-top:8px;
    font-size:12px;
    color:var(--sp-muted);
  }
  .sp-map-segment-label{
    position:absolute;
    transform:translate(-50%, -50%);
    padding:4px 8px;
    border-radius:8px;
    border:2px solid rgba(15,23,42,0.95);
    background:rgba(255,255,255,0.96);
    color:#111827;
    font-size:12px;
    font-weight:800;
    line-height:1.1;
    white-space:nowrap;
    box-shadow:0 2px 6px rgba(15,23,42,0.18);
    pointer-events:none;
    z-index:2147483647;
  }
  .sp-number.is-map-linked{
    background:#f5f3ff;
    border-color:rgba(79,70,229,0.35);
  }
  .sp-number.is-map-linked input{
    background:transparent;
  }
  .sp-number.is-map-linked .sp-step{
    opacity:1;
    cursor:pointer;
  }
  .sp-btn[disabled]{
    opacity:0.55;
    cursor:not-allowed;
  }
  /* Fence type visibility */
  .sp-card.is-wood [data-wrought-only]{ display:none !important; }
  .sp-card:not(.is-wood) [data-wood-only]{ display:none !important; }

  .sp-modal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.35);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
    z-index:9999;
  }
  .sp-modal.is-open{ display:flex; }
  .sp-modal-card{
    width:min(680px, 100%);
    max-height:90vh;
    overflow:auto;
    border-radius:var(--sp-radius);
    box-shadow:0 20px 60px rgba(0,0,0,0.16);
  }
  .sp-manual-scenario{
    display:grid;
    gap:12px;
    padding:12px;
    border:1px dashed var(--sp-border);
    border-radius:12px;
    background:#f8fafc;
  }
  @media(min-width:720px){
    .sp-manual-scenario{
      grid-template-columns:160px minmax(0,1fr);
      align-items:center;
    }
  }

  /* === Strong Perimeter redesign (matches mockup) === */
  :root{
    --sp-green:#004B3D;
    --sp-green-dark:#003428;
    --sp-ink:#f4f0e6;
    --sp-muted:#c9d2ca;
    --sp-border:#586F61;
    --sp-bg:#0f3a31;
    --sp-card:#0f3a31;
    --sp-radius:18px;
    --sp-stage-bg:#0b2c25;
    --sp-accent:#C04F23;
    --sp-accent-strong:#A8441D;
    --sp-input-bg:#f4ead8;
    --sp-input-text:#1f2a23;
    --sp-shadow:0 16px 30px rgba(10,18,14,0.35);
    --sp-floating-offset:112px;
  }
  body{
    background:var(--sp-stage-bg);
    background-image:
      radial-gradient(1200px 700px at 10% -20%, rgba(192,79,35,0.18) 0%, rgba(192,79,35,0) 60%),
      radial-gradient(900px 600px at 85% -10%, rgba(88,111,97,0.45) 0%, rgba(88,111,97,0) 55%),
      repeating-linear-gradient(135deg, rgba(255,255,255,0.04) 0px, rgba(255,255,255,0.04) 2px, transparent 2px, transparent 10px);
  }
  #sp-scope{
    font-family:"Work Sans","Segoe UI","Helvetica Neue",sans-serif;
    color:var(--sp-ink);
  }
  .sp-container{
    max-width:1320px;
    padding:28px 24px calc(52px + var(--sp-floating-offset, 0px));
  }
  .sp-header{
    background:var(--sp-green);
    border:1px solid var(--sp-border);
    border-radius:var(--sp-radius);
    padding:18px 20px;
    box-shadow:var(--sp-shadow);
    gap:16px;
    position:relative;
    overflow:hidden;
    width:100%;
  }
  .sp-header::after{
    content:"";
    position:absolute;
    inset:0;
    background:
      radial-gradient(360px 120px at 10% 0%, rgba(192,79,35,0.16), transparent 70%),
      radial-gradient(420px 140px at 90% 10%, rgba(255,255,255,0.06), transparent 75%);
    pointer-events:none;
  }
  .sp-brand{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width:220px;
    position:relative;
    z-index:1;
  }
  .sp-title{
    font-family:"Cinzel","Times New Roman",serif;
    font-size:28px;
    letter-spacing:0.5px;
    display:flex;
    align-items:center;
    gap:12px;
  }
  .sp-title-text{
    font-size:26px;
    letter-spacing:0.5px;
  }
  .sp-logo{
    height:38px;
    width:auto;
    display:block;
  }
  .sp-logo-panel{
    margin-top:12px;
    padding:10px 12px;
    border-radius:12px;
    background:#f4ead8;
    border:1px solid #d6c7ae;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .sp-logo-panel img{
    height:28px;
    width:auto;
  }
  .sp-subtitle{
    font-size:13px;
    color:var(--sp-muted);
    max-width:560px;
    text-transform:uppercase;
    letter-spacing:0.08em;
  }
  .sp-badge{
    background:var(--sp-accent);
    color:#1f1206;
    letter-spacing:0.12em;
    text-transform:uppercase;
  }
  .sp-actions{
    gap:8px;
    position:relative;
    z-index:1;
  }
  .sp-layout{
    display:grid;
    gap:20px;
    align-items:start;
    width:100%;
  }
  .sp-main{
    display:grid;
    gap:16px;
    min-width:0;
  }
  .sp-side{
    display:grid;
    gap:16px;
    min-width:0;
  }
  @media(min-width:980px){
    .sp-layout{ grid-template-columns:minmax(0,1fr) 360px; }
    .sp-side{ position:static; top:auto; }
    .sp-onboard .sp-layout{ grid-template-columns:minmax(0,1fr); }
  }
  @media(max-width:719px){
    .sp-container{ padding:20px 16px calc(44px + var(--sp-floating-offset, 0px)); }
    .sp-header{ padding:16px 14px; }
    .sp-title{ font-size:24px; }
    .sp-title-text{ font-size:22px; }
    .sp-logo{ height:32px; }
    .sp-btn{ text-align:center; }
  }
  .sp-inline-cards{
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
  }
  .sp-card{
    padding:18px;
    border-radius:var(--sp-radius);
    background:linear-gradient(180deg, rgba(0,75,61,0.92) 0%, rgba(0,52,40,0.98) 100%);
    border:1px solid var(--sp-border);
    box-shadow:var(--sp-shadow);
    position:relative;
  }
  .sp-card::before{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    pointer-events:none;
    box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);
  }
  .sp-card-header{
    margin-bottom:12px;
    padding-bottom:10px;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .sp-card-title{
    font-family:"Cinzel","Times New Roman",serif;
    font-size:18px;
    color:#f6f2e8;
  }
  .sp-card.is-collapsed .sp-card-header{ margin-bottom:0; }
  .sp-field{ gap:8px; }
  .sp-label{
    font-size:11px;
    letter-spacing:0.18em;
    color:var(--sp-muted);
    text-transform:uppercase;
  }
  .sp-input,.sp-select,.sp-textarea{
    border:1px solid #c8b79f;
    background:var(--sp-input-bg);
    color:var(--sp-input-text);
    border-radius:10px;
    padding:11px 12px;
    font-size:14px;
    transition:border-color .2s ease, box-shadow .2s ease;
  }
  .sp-output-value{
    border:1px dashed rgba(200,183,159,0.65);
    border-radius:10px;
    padding:11px 12px;
    font-size:14px;
    font-weight:600;
    color:var(--sp-ink);
    background:rgba(244,234,216,0.18);
    min-height:42px;
    display:flex;
    align-items:center;
  }
  .sp-output-value:empty::before{
    content:attr(data-placeholder);
    color:#8a7a66;
    font-weight:500;
  }
  .sp-input::placeholder,.sp-textarea::placeholder{
    color:#8a7a66;
  }
  .sp-input:focus,.sp-select:focus,.sp-textarea:focus{
    outline:none;
    border-color:var(--sp-accent);
    box-shadow:0 0 0 3px rgba(192,79,35,0.25);
  }
  .sp-number{
    border-radius:12px;
    border:1px solid #c8b79f;
    background:var(--sp-input-bg);
  }
  .sp-number input{
    background:transparent;
    color:var(--sp-input-text);
  }
  .sp-step{
    background:#e7dcc7;
    color:#1f2a23;
  }
  .sp-hint{
    color:var(--sp-muted);
  }
  .sp-btn{
    border-radius:999px;
    padding:10px 18px;
    font-weight:700;
    border:1px solid var(--sp-border);
    background:var(--sp-green);
    color:#f5efe6;
    box-shadow:0 6px 12px rgba(10,18,14,0.35);
  }
  .sp-btn.primary{
    background:var(--sp-accent);
    border-color:var(--sp-accent-strong);
    color:#fff;
    box-shadow:0 10px 18px rgba(192,79,35,0.35);
  }
  .sp-btn.ghost{
    background:transparent;
    border-color:var(--sp-border);
  }
  .sp-btn.danger{
    background:#3a2c2c;
    color:#f9d1d1;
    border-color:#6b3a3a;
  }
  .sp-btn.danger.is-confirm{
    background:#b91c1c;
    border-color:#b91c1c;
    color:#fff;
  }
  .sp-chip{
    border:1px solid var(--sp-border);
    background:rgba(88,111,97,0.25);
    color:#f2e7d4;
  }
  .sp-chip.is-info{
    background:#2a3850;
    color:#cfe0ff;
    border-color:#394e6b;
  }
  .sp-chip.is-success{
    background:#2c3f34;
    color:#ccebd9;
    border-color:#3e5b4c;
  }
  .sp-chip.is-warn{
    background:#4a3b25;
    color:#f5d39b;
    border-color:#6a512e;
  }
  .sp-chip.is-error{
    background:#4a2a2a;
    color:#f7c7c7;
    border-color:#6a3939;
  }
  .sp-scope-group{
    border-radius:14px;
    background:rgba(88,111,97,0.18);
    border:1px solid var(--sp-border);
  }
  .sp-scope-pill{
    letter-spacing:0.16em;
  }
  .sp-scope-group.is-basics{ --accent:#6fb28f; background:#2b3b33; }
  .sp-scope-group.is-wood{ --accent:#d0893a; background:#3a2f24; }
  .sp-scope-group.is-style{ --accent:#8aa3ff; background:#2a3344; }
  .sp-scope-group.is-repair{ --accent:#f36a6a; background:#3a2a2a; }
  .sp-scope-group.is-gates{ --accent:#68b7d8; background:#253642; }

  #sp-map{
    border:1px solid var(--sp-border);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,0.06);
  }

  .sp-output{
    margin-top:0;
  }
  .sp-output textarea{
    min-height:180px;
    background:#f7efdf;
    color:#1f2a23;
  }

  .sp-guide{
    display:grid;
    gap:12px;
  }
  .sp-guide-item{
    display:grid;
    grid-template-columns:32px 1fr;
    gap:12px;
    align-items:start;
  }
  .sp-guide-step{
    width:32px;
    height:32px;
    border-radius:10px;
    background:var(--sp-accent);
    color:#1f1206;
    font-weight:800;
    display:grid;
    place-items:center;
  }
  .sp-guide-title{
    font-weight:700;
  }
  .sp-guide-sub{
    color:var(--sp-muted);
    font-size:13px;
  }
  .sp-jump{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
  }
  .sp-jump-link{
    text-decoration:none;
    color:#f4f0e6;
    background:var(--sp-green);
    border:1px solid var(--sp-border);
    border-radius:999px;
    padding:6px 10px;
    font-size:12px;
    font-weight:700;
  }
  .sp-jump-link:hover{
    border-color:var(--sp-accent);
  }

  .sp-floating-actions{
    background:rgba(0,75,61,0.92);
    backdrop-filter:blur(6px);
    border-top:1px solid var(--sp-border);
    box-shadow:0 -10px 20px rgba(8,14,11,0.45);
  }
  .sp-floating-actions .sp-fab{
    border-radius:999px;
    background:var(--sp-green);
    border-color:var(--sp-border);
    color:#f4f0e6;
  }
  .sp-floating-actions .sp-fab-icon{
    background:var(--sp-accent);
    color:#1f1206;
  }
  .sp-floating-actions .sp-fab.danger{
    background:#3a2c2c;
    color:#f7c7c7;
    border-color:#6a3939;
  }
  .sp-floating-actions .sp-fab.danger .sp-fab-icon{
    background:#b91c1c;
    color:#fff;
  }

  .sp-modal{
    background:rgba(10,16,12,0.7);
  }
  .sp-modal-card{
    background:linear-gradient(180deg, rgba(0,75,61,0.95) 0%, rgba(0,52,40,0.98) 100%);
    border:1px solid var(--sp-border);
  }

  @keyframes sp-fade-up{
    from{ opacity:0; transform:translateY(10px); }
    to{ opacity:1; transform:translateY(0); }
  }
  .sp-card,
  .sp-scope-group{
    animation:sp-fade-up .45s ease both;
  }
  @media (prefers-reduced-motion: reduce){
    .sp-card,
    .sp-scope-group{
      animation:none;
    }
    *{
      transition:none !important;
    }
  }

  /* === Brand palette refresh (clear separation) === */
  :root{
    --sp-green:#004B3D;
    --sp-green-dark:#003328;
    --sp-ink:#1b2a23;
    --sp-muted:#586F61;
    --sp-border:#cfdad3;
    --sp-bg:#f5f7f5;
    --sp-card:#ffffff;
    --sp-radius:16px;
    --sp-stage-bg:#f4f7f5;
    --sp-accent:#C04F23;
    --sp-accent-strong:#A8441D;
    --sp-input-bg:#ffffff;
    --sp-input-text:#1b2a23;
    --sp-shadow:0 10px 22px rgba(0,0,0,0.08);
    --sp-floating-offset:112px;
  }
  body{
    background:var(--sp-stage-bg);
    background-image:
      radial-gradient(900px 480px at 10% -10%, rgba(0,75,61,0.08) 0%, rgba(0,75,61,0) 60%),
      radial-gradient(820px 520px at 90% -20%, rgba(88,111,97,0.18) 0%, rgba(88,111,97,0) 55%),
      repeating-linear-gradient(135deg, rgba(0,0,0,0.02) 0px, rgba(0,0,0,0.02) 2px, transparent 2px, transparent 10px);
  }
  #sp-scope{
    font-family:"Open Sans","Segoe UI","Helvetica Neue",sans-serif;
    color:var(--sp-ink);
  }
  .sp-header{
    background:var(--sp-green);
    border-color:var(--sp-green-dark);
    color:#f4f7f5;
  }
  .sp-title,
  .sp-card-title{
    font-family:"Open Sans","Segoe UI","Helvetica Neue",sans-serif;
    letter-spacing:0.2px;
    color:inherit;
  }
  .sp-title-text{
    font-size:24px;
    font-weight:700;
    color:#ffffff;
  }
  .sp-subtitle{
    color:#d8e5df;
    text-transform:none;
    letter-spacing:0.02em;
  }
  .sp-header .sp-btn{
    background:rgba(255,255,255,0.12);
    border-color:rgba(255,255,255,0.35);
    color:#ffffff;
  }
  .sp-header .sp-btn.primary{
    background:var(--sp-accent);
    border-color:var(--sp-accent-strong);
    color:#1f1206;
  }
  .sp-card{
    background:var(--sp-card);
    border-color:var(--sp-border);
    box-shadow:var(--sp-shadow);
  }
  .sp-card::before{
    box-shadow:none;
  }
  .sp-card-header{
    background:#f1f5f3;
    border:1px solid var(--sp-border);
    border-radius:12px;
    padding:12px 14px;
    margin-bottom:14px;
  }
  .sp-card-title{
    color:var(--sp-ink);
    font-weight:700;
  }
  .sp-label{
    color:var(--sp-muted);
    letter-spacing:0.12em;
  }
  .sp-input,.sp-select,.sp-textarea{
    border:1px solid #c3d0c9;
    background:var(--sp-input-bg);
    color:var(--sp-input-text);
  }
  .sp-input::placeholder,.sp-textarea::placeholder{
    color:#7b8a82;
  }
  .sp-input:focus,.sp-select:focus,.sp-textarea:focus{
    border-color:var(--sp-accent);
    box-shadow:0 0 0 3px rgba(192,79,35,0.18);
  }
  .sp-number{
    background:#fff;
    border-color:#c3d0c9;
  }
  .sp-step{
    background:#eef3f1;
    color:#1b2a23;
  }
  .sp-hint{
    color:var(--sp-muted);
  }
  .sp-btn{
    background:#ffffff;
    color:var(--sp-green);
    border-color:var(--sp-green);
    box-shadow:0 6px 12px rgba(0,0,0,0.08);
  }
  .sp-btn.primary{
    background:var(--sp-accent);
    border-color:var(--sp-accent-strong);
    color:#1f1206;
  }
  .sp-btn.ghost{
    background:transparent;
    border-color:#c3d0c9;
    color:var(--sp-green);
  }
  .sp-header .sp-btn.ghost{
    background:rgba(255,255,255,0.18);
    border-color:rgba(255,255,255,0.55);
    color:#ffffff;
  }
  .sp-card-header .sp-row .sp-btn,
  .sp-copy-row .sp-btn{
    padding:8px 12px;
    font-size:13px;
    min-height:36px;
  }
  @media(min-width:720px){
    .sp-card-header .sp-row{
      flex-wrap:nowrap;
    }
    .sp-card-header .sp-row .sp-btn{
      white-space:nowrap;
    }
  }
  .sp-chip{
    background:#f1f5f3;
    border-color:#d6dfd8;
    color:var(--sp-green);
  }
  .sp-chip.is-info{
    background:#edf4ff;
    color:#1d4ed8;
    border-color:#cfe0ff;
  }
  .sp-chip.is-success{
    background:#e9f6ef;
    color:#0f7b4d;
    border-color:#cbe9d8;
  }
  .sp-chip.is-warn{
    background:#fff3e8;
    color:#a3541c;
    border-color:#f5d4be;
  }
  .sp-chip.is-error{
    background:#ffecec;
    color:#b91c1c;
    border-color:#fecaca;
  }
  .sp-scope-group{
    background:#f6f9f7;
    border-color:#d6dfd8;
  }
  .sp-scope-group.is-basics{ --accent:#0f766e; background:#eef6f3; }
  .sp-scope-group.is-wood{ --accent:#c27b2f; background:#fbf2ea; }
  .sp-scope-group.is-style{ --accent:#1d4ed8; background:#eef2ff; }
  .sp-scope-group.is-repair{ --accent:#b91c1c; background:#fff1f2; }
  .sp-scope-group.is-gates{ --accent:#0284c7; background:#e6f4fb; }
  #sp-map{
    border-color:#c3d0c9;
    box-shadow:inset 0 0 0 1px rgba(0,0,0,0.04);
  }
  .sp-output textarea{
    background:#ffffff;
    color:var(--sp-ink);
  }
  .sp-guide-step{
    background:var(--sp-accent);
    color:#1f1206;
  }
  .sp-jump-link{
    background:#ffffff;
    border-color:#d6dfd8;
    color:var(--sp-green);
  }
  .sp-floating-actions{
    background:rgba(255,255,255,0.95);
    border-top:1px solid #d6dfd8;
    box-shadow:0 -8px 18px rgba(0,0,0,0.08);
  }
  .sp-floating-actions .sp-fab{
    background:#ffffff;
    border-color:#d6dfd8;
    color:var(--sp-green);
  }
  .sp-floating-actions .sp-fab-icon{
    background:var(--sp-green);
    color:#ffffff;
  }
  .sp-floating-actions .sp-fab.danger{
    background:#ffecec;
    border-color:#fecaca;
    color:#b91c1c;
  }
  .sp-floating-actions .sp-fab.danger .sp-fab-icon{
    background:#b91c1c;
    color:#ffffff;
  }
  .sp-card.is-unconfirmed{
    border-color:var(--sp-accent);
    box-shadow:0 0 0 2px rgba(192,79,35,0.28), var(--sp-shadow);
  }
  .sp-modal{
    background:rgba(0,0,0,0.45);
  }
  .sp-modal-card{
    background:#ffffff;
    border:1px solid #d6dfd8;
    color:var(--sp-ink);
  }
  .sp-logo-panel{
    background:#ffffff;
    border-color:#d6dfd8;
  }

  /* Tap-target hardening: keep the full visual button box clickable on touch devices. */
  .sp-btn,
  .sp-floating-actions .sp-fab{
    position:relative;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    touch-action:manipulation;
    -webkit-tap-highlight-color:transparent;
    pointer-events:auto;
    z-index:2;
  }
  .sp-btn > *,
  .sp-floating-actions .sp-fab > *{
    pointer-events:none;
  }
  @media(max-width:719px){
    .sp-btn{
      display:flex;
    }
  }
  </style>
</head>
<body>
<div id="sp-scope" class="sp-onboard">
    <div class="sp-container">
      <div class="sp-header">
        <div class="sp-brand">
          <div class="sp-title">
            <img class="sp-logo" src="assets/strong-perimeter-logo-white.svg" alt="Strong Perimeter" />
          </div>
          <div class="sp-subtitle">Internal Scope Generator</div>
        </div>
        <div class="sp-actions">
          <a class="sp-btn ghost" href="crew-policies.html" target="_blank" rel="noopener noreferrer">Crew Policies</a>
          <a class="sp-btn ghost" href="changelog.html" target="_blank" rel="noopener noreferrer">Changelog</a>
          <button class="sp-btn ghost" id="sp-open-manual" type="button">Manual Quote</button>
          <button class="sp-btn ghost" id="sp-open-import" type="button">Reload from Notes</button>
          <button class="sp-btn is-hidden" id="sp-refresh-materials" type="button" data-gated>Update Material Costs</button>
        </div>
      </div>

    <div class="sp-modal" id="sp-manual-modal" aria-hidden="true" role="dialog" aria-labelledby="sp-manual-title">
      <div class="sp-card sp-modal-card" id="sp-manual-quote-card">
        <div class="sp-card-header">
          <div class="sp-card-title" id="sp-manual-title">Manual Quote</div>
          <div class="sp-row">
            <button class="sp-btn ghost" id="sp-manual-close" type="button">Close</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-cost">Total Material &amp; Equipment Costs</label>
            <div class="sp-row">
              <input class="sp-input" id="sp-manual-cost" type="number" inputmode="decimal" step="0.01" min="0" placeholder="Enter materials &amp; equipment (e.g., 4500)" />
            </div>
            <div class="sp-hint" id="sp-manual-status"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-hours">Total hours (onsite)</label>
            <input class="sp-input" id="sp-manual-hours" type="number" inputmode="decimal" step="0.1" min="0" placeholder="e.g., 6.5" />
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-charge">Recommended Charge</label>
            <div class="sp-row">
              <div class="sp-output-value" id="sp-manual-charge" data-placeholder="$0.00" role="status" aria-live="polite"></div>
              <span class="sp-chip is-info" id="sp-manual-mode" style="display:none">Pricing</span>
            </div>
          </div>
        </div>
        <div class="sp-divider"></div>
        <div class="sp-grid">
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-gross">Total gross</label>
            <div class="sp-output-value" id="sp-manual-gross" data-placeholder="$0.00"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-gross-hour">Gross per hour</label>
            <div class="sp-output-value" id="sp-manual-gross-hour" data-placeholder="$0.00"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-commission">Commission</label>
            <div class="sp-output-value" id="sp-manual-commission" data-placeholder="$0.00"></div>
          </div>
          <div class="sp-field col-6">
            <label class="sp-label" for="sp-manual-net">Net $</label>
            <div class="sp-output-value" id="sp-manual-net" data-placeholder="$0.00"></div>
          </div>
        </div>
        
      </div>
    </div>

    <div class="sp-modal" id="sp-import-modal" aria-hidden="true" role="dialog" aria-labelledby="sp-import-title">
      <div class="sp-card sp-modal-card" id="sp-import-modal-card">
        <div class="sp-card-header">
          <div class="sp-card-title" id="sp-import-title">Reload from Notes</div>
          <div class="sp-row">
            <button class="sp-btn ghost" id="sp-import-close" type="button">Close</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <div class="sp-row">
              <button class="sp-btn" id="sp-import-btn" type="button">Load Notes</button>
              <button class="sp-btn ghost" id="sp-import-clear" type="button">Clear</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-import-text">Paste saved notes</label>
            <textarea class="sp-textarea" id="sp-import-text" placeholder="Paste previously generated notes to restore sections and map info..."></textarea>
            <div class="sp-hint" id="sp-import-status">Paste notes that include the embedded reload key added by this generator.</div>
          </div>
        </div>
      </div>
    </div>

    <div class="sp-layout">
      <div class="sp-main">
        <div class="sp-inline-cards">
      <div class="sp-card" id="sp-hcp-card">
        <div class="sp-card-header">
          <div class="sp-card-title">Housecall Pro Estimate</div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-estimate-number">Estimate Number from Housecall Pro</label>
            <input class="sp-input" id="sp-estimate-number" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="123456" />
            <div class="sp-row" style="margin-top:8px">
              <button class="sp-btn ghost" id="sp-estimate-lookup" type="button">Fetch Estimate Address</button>
              <button class="sp-btn" id="sp-proceed-no-estimate" type="button">Proceed Without Estimate</button>
            </div>
            <div class="sp-hint">Enter the estimate number and click “Fetch Estimate Address” to load the service address from Housecall Pro.</div>
            <div class="sp-hint" id="sp-estimate-status" aria-live="polite"></div>
          </div>
        </div>
      </div>

      <div class="sp-card is-unconfirmed" id="sp-customer-card" data-gated>
        <div class="sp-card-header">
          <div class="sp-card-title">Customer Type</div>
          <div class="sp-row">
            <button class="sp-btn ghost" id="sp-customer-confirm" type="button">Confirm</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-customer-type">Customer Type</label>
            <select class="sp-select" id="sp-customer-type">
              <option value="Residential">Residential</option>
              <option value="Commercial">Commercial</option>
              <option value="City">City</option>
            </select>
            <div class="sp-hint" id="sp-customer-min-hint">Minimum charge: $350</div>
          </div>
        </div>
      </div>
    </div>

    <div class="sp-card is-collapsed" id="sp-map-card" data-gated>
      <div class="sp-card-header">
        <div class="sp-card-title">Map Measurements</div>
        <div class="sp-row">
          <button class="sp-btn ghost" id="sp-map-toggle" type="button" aria-expanded="false">Expand Map</button>
          <button class="sp-btn ghost" id="sp-map-clear" type="button" disabled>Clear Map Sections</button>
        </div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-12">
          <label class="sp-label" for="sp-map-address">Search Address</label>
          <input class="sp-input" id="sp-map-address" type="text" placeholder="Search for a property" autocomplete="off" />
        </div>
        <div class="col-12">
          <div id="sp-map"></div>
          <div class="sp-map-note">Draw polylines to trace each fence run. Segments automatically create scope sections, stay in sync as you edit, and can be cleared with the button above. Right-click a line to remove vertices or delete the entire run.</div>
        </div>
      </div>
    </div>

    <div id="sp-sections" class="sp-sections" data-gated></div>

    <div class="sp-card" id="sp-crew-card" data-gated>
      <div class="sp-card-header">
        <div class="sp-card-title">Labor</div>
      </div>
      <div class="sp-grid">
        <div class="sp-field col-6">
          <label class="sp-label">Labor Rate</label>
          <input class="sp-input" id="sp-labor-rate" type="text" readonly />
          <div class="sp-hint">Applies to total time on site and travel time.</div>
        </div>
        <div class="sp-field col-12">
          <label class="sp-label">Assigned Crew Members</label>
          <div class="sp-crew-picker" id="sp-crew-members">
            <label class="sp-crew-option"><input type="checkbox" data-crew-member="Jesus" checked /> Jesus</label>
            <label class="sp-crew-option"><input type="checkbox" data-crew-member="JR" checked /> JR</label>
            <label class="sp-crew-option"><input type="checkbox" data-crew-member="Clay" checked /> Clay</label>
            <label class="sp-crew-option"><input type="checkbox" data-crew-member="Joel" checked /> Joel</label>
          </div>
          <div class="sp-hint" id="sp-crew-members-hint">Select who is assigned to this job. Labor time and schedule update automatically.</div>
        </div>
      </div>
    </div>

      </div>
      <aside class="sp-side" data-gated>
    <div class="sp-output" id="sp-output" style="display:none">
      <div class="sp-card">
        <div class="sp-card-header">
          <div class="sp-card-title">Notes</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy" type="button">Copy Notes</button>
            <button class="sp-btn" id="sp-copy-reload" type="button">Copy Reload Key</button>
            <button class="sp-btn primary" id="sp-push-hcp" type="button">Push Notes to HCP</button>
          </div>
        </div>
        <textarea id="sp-notes" readonly></textarea>
        <div class="sp-hint">These notes are formatted for easy paste into your CRM or internal documentation.</div>
      </div>

      <div class="sp-card" id="sp-quick-costs-card" style="display:none">
        <div class="sp-card-header">
          <div class="sp-card-title">Quick Costs</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-costs-all" type="button" disabled>Copy All 7</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-charge">Price to Charge</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-charge" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-charge" type="button" disabled>Copy</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-travel">Travel</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-travel" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-travel" type="button" disabled>Copy</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-materials">Materials</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-materials" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-materials" type="button" disabled>Copy</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-consumables">Consumables</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-consumables" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-consumables" type="button" disabled>Copy</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-labor">Labor</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-labor" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-labor" type="button" disabled>Copy</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-overhead">Overhead</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-overhead" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-overhead" type="button" disabled>Copy</button>
            </div>
          </div>
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-cost-commission">Commission</label>
            <div class="sp-copy-row">
              <input class="sp-input" id="sp-cost-commission" type="text" readonly value="—" />
              <button class="sp-btn ghost" id="sp-copy-cost-commission" type="button" disabled>Copy</button>
            </div>
          </div>
        </div>
        <div class="sp-hint">Fast copy values for HCP: Price to Charge, Travel, Materials, Consumables, Labor, Overhead, and Commission.</div>
      </div>

      <div class="sp-card" id="sp-sub">
        <div class="sp-card-header">
          <div class="sp-card-title">Notes for Crew</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-sub" type="button">Copy Notes</button>
          </div>
        </div>
        <textarea id="sp-notes-sub" readonly></textarea>
        <div class="sp-hint">Crew-facing summary: duration, materials, and total repairs.</div>
      </div>

      <div class="sp-card" id="sp-service-card" style="display:none">
        <div class="sp-card-header">
          <div class="sp-card-title">Service Line Items</div>
          <div class="sp-row">
            <button class="sp-btn" id="sp-copy-service" type="button" disabled>Copy All</button>
          </div>
        </div>
        <div class="sp-grid">
          <div class="sp-field col-12">
            <label class="sp-label" for="sp-service-option-number">Estimate Option Number</label>
            <div class="sp-row">
              <input class="sp-input sp-service-option-input" id="sp-service-option-number" type="number" inputmode="numeric" min="1" step="1" value="1" placeholder="1" />
              <button class="sp-btn primary" id="sp-push-service-hcp" type="button" disabled>Push Line Items to HCP</button>
            </div>
            <div class="sp-hint">Choose which estimate option should receive these line items (Option 1, 2, 3...).</div>
          </div>
        </div>
        <div class="sp-service-list" id="sp-service-lines"></div>
        <div class="sp-hint">Use the copy buttons to grab titles or descriptions individually.</div>
      </div>
    </div>
      </aside>
    </div>
  </div>
</div>

<div class="sp-floating-actions" id="sp-quick-actions" aria-label="Quick actions" data-gated>
  <button class="sp-fab" id="sp-quick-add" type="button">
    <span class="sp-fab-icon">＋</span>
    <span>Add</span>
  </button>
  <button class="sp-fab" id="sp-quick-dup-first" type="button" aria-label="Copy 1st Style">
    <span class="sp-fab-icon">⧉</span>
    <span>1st</span>
  </button>
  <button class="sp-fab" id="sp-quick-dup-last" type="button" aria-label="Copy Latest Style">
    <span class="sp-fab-icon">⧉</span>
    <span>Latest</span>
  </button>
  <button class="sp-fab danger" id="sp-reset" type="button" aria-label="Reset">
    <span class="sp-fab-icon">⟳</span>
  </button>
  <button class="sp-fab" id="sp-top-btn" type="button" aria-label="Back to top">
    <span class="sp-fab-icon">↑</span>
  </button>
  <button class="sp-fab" id="sp-bottom-btn" type="button" aria-label="Jump to bottom">
    <span class="sp-fab-icon">↓</span>
  </button>
</div>
<script src="https://cdn.jsdelivr.net/npm/iframe-resizer/js/iframeResizer.contentWindow.min.js"></script>
<script>
window._spGoogleMapsReady = window._spGoogleMapsReady || false;
window._spInitializeMap = window._spInitializeMap || null;
window.initMap = function(){
  window._spGoogleMapsReady = true;
  if (typeof window._spInitializeMap === 'function') {
    window._spInitializeMap();
  }
};
document.addEventListener('DOMContentLoaded', function(){
  document.title = 'Scope Generator';
  (function initMaterialsRefresh(){
    var btn = document.getElementById('sp-refresh-materials');
    if(!btn || typeof fetch !== 'function') return;

    var defaultText = 'Update Material Costs';
    var successText = 'Materials Updated';

    function setState(state){
      btn.dataset.state = state;
      btn.disabled = state === 'loading';
      btn.classList.toggle('primary', state === 'success');

      if(state === 'loading'){
        btn.textContent = 'Updating materials...';
      } else if(state === 'success'){
        btn.textContent = successText;
      } else {
        btn.textContent = defaultText;
      }
    }

    btn.addEventListener('click', function(){
      setState('loading');
      fetch('https://api.strongclicks.io/webhook/scopegenerator-get-materials', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
      }).then(function(res){
        if(!res.ok){
          throw new Error('Material refresh failed with status ' + res.status);
        }
        return res.json();
      }).then(function(payload){
        setState('success');
        if(payload){
          console.info('Material catalog refreshed from Housecall Pro.');
        }
      }).catch(function(err){
        setState('idle');
        console.warn('Unable to refresh material catalog', err);
      });
    });
  })();
  (function setBackground(){
    var root = document.documentElement;
    if(!root) return;
    var href = window.location.href || '';
    if(href.indexOf('https://stagescope.strongperimeter.com/') !== -1){
      root.style.setProperty('--sp-stage-bg', '#fdf5c2');
    } else {
      root.style.setProperty('--sp-stage-bg', '#EBEBEB');
    }
  })();
  // Set favicon
  (function setFavicon(){
    var href = 'assets/strong-perimeter-favicon.svg';
    var head = document.head || document.getElementsByTagName('head')[0];
    if (!head) return;
    var olds = head.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
    olds.forEach(function(el){ el.parentNode.removeChild(el); });
    var link = document.createElement('link');
    link.rel = 'icon';
    link.type = 'image/svg+xml';
    link.href = href;
    head.appendChild(link);
  })();
(function(){
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  const SEED = {
    style:["Flat Top","Flat Top w/ Puppy Pickets","Extended Picket","Extended Picket w/ Finials"],
    height:["3ft","4ft","5ft","6ft","8ft"],
    railSize:["1\u201D","3/4\u201D","1/2\u201D","1 \u00BC\u201D","1 \u00BD\u201D","1 \u00BE\u201D","1x2\u201D","2\u201D","3\u201D","Flat Bar 1/4\" x 1\""],
    picketSize:["1/2\u201D","5/8\u201D","3/4\u201D","1\u201D"],
    postSize:["1 1/2\" x 1 1/2\"","2x2","3x3","4x4"],
    postRealignSize:["2x2","3x3"],
    puppy:["None","Puppy Pickets","Puppy Pickets w/ Finials","Puppy Pickets Full Height","Puppy Pickets Full Height w/ Finials"],
    // NEW: finials
    finialStyles:["Quad Star","Banana Split","Boy Scout","Ball"],
    finialMaterials:["Cast Iron","Aluminum","Plastic"],
    // NEW: post caps
    capStyles:["Pyramid","Pressed","Ball"],
    capMaterials:["Cast Iron","Plastic","Metal"],
    capPostSizes:["1 1/2\" x 1 1/2\"","2x2","3x3","4x4"],
  };

  const WOOD_PICKET_WIDTHS = ['3.5"','4"','5.5"','6"'];
  const WOOD_RAIL_SIZES = ['2x3','2x4'];
  const WOOD_TRIM_TYPES = ['1x2','1x4','1x4 & 1x2'];
  const POST_INSTALL_METHODS = [
    { value: 'dig-set-concrete', label: 'Dig and Set in Concrete' },
    { value: 'anchored', label: 'Anchor to Concrete' }
  ];
  const POST_ANCHOR_PLATE_LABEL = '4x4 anchor plate';
  const POST_ANCHOR_HARDWARE_LABEL = 'concrete anchor';
  const WROUGHT_PANEL_FABRICATION_ON_SITE = 'On Site';
  const WROUGHT_PANEL_FABRICATION_ORDER_TMI = 'Order Custom Panels (TMI)';
  const WROUGHT_PANEL_FABRICATION_OPTIONS = [
    WROUGHT_PANEL_FABRICATION_ON_SITE,
    WROUGHT_PANEL_FABRICATION_ORDER_TMI
  ];
  const WROUGHT_TMI_CUSTOM_PANEL_COST = 300;
  const WOOD_STAIN_BRANDS = ['HueMiller','Ready Seal','Wood Defender'];
  const DEFAULT_WOOD_STAIN_BRAND = WOOD_STAIN_BRANDS[0];
  const WOOD_STAIN_BUCKET_COSTS = {
    'HueMiller': 124.49,
    'Ready Seal': 160,
    'Wood Defender': 185
  };
  const NO_TIES_OPTION = 'No ties';
  const SIMPSON_TIE_OPTIONS = ['1 piece ties','2 piece ties', NO_TIES_OPTION];
  const WOOD_POST_CAP_TYPES = ['Dome cap','Flat cap'];
  const WOOD_POST_METHODS = [
    { value: 'cut-weld', label: 'Cut & Weld' },
    { value: 'dig-straighten', label: 'Dig, straighten, add concrete' }
  ];
  const WOOD_POST_INSTALL_METHODS = [
    { value: 'drive-posts', label: 'Drive the posts' },
    { value: 'dig-set-concrete', label: 'Dig, set, add concrete' }
  ];

  const POST_REALIGN_METHODS = [
    { value: 'concrete', label: 'Dig, straighten, add concrete' },
    { value: 'cut-weld', label: 'Cut & Weld' }
  ];

  const PUPPY_INSERT_SIZES = ['1/2"','5/8"'];
  const PANEL_REPLACEMENT_STYLES = [...SEED.style, 'Flat Top w/ Puppy Picket Insert'];
  const CUSTOMER_TYPES = ['Residential','Commercial','City'];
  const WROUGHT_CURRENT_COLOR_OPTIONS = [
    'Black',
    'Gray',
    'White',
    'Brown',
    'Blue',
    'Yellow',
    'Red',
    'Orange'
  ];
  const WROUGHT_PAINT_COLOR_OPTIONS = [
    'Black Gloss',
    'Black Flat',
    'White Gloss',
    'Aluminum Gloss',
    'Smoke Gray Gloss',
    'Hunter Green Gloss',
    'Yellow Gloss',
    'Safety Red Gloss',
    'Regal Red Gloss',
    'Blue Gloss',
    'Leather Brown Gloss',
    'Dark Brown Gloss'
  ];

  const GATE = {
    latchTypes: [
      'Gravity Latch',
      'Short Pool Latch',
      'Tall Pool Latch',
      'Single Lock Box',
      'Double Lock Box'
    ],
    hingeTypes: [
      'Door Hinges',
      'Bat Wing Hinges',
      'Auto Close Hinges'
    ]
  };
  const WALK_GATE_TYPES = ['Single Swing Walk Gate','Double Swing Gate'];
  const WOOD_GATE_POST_TYPES = ['Wood 4x4','Round Steel','Postmaster'];
  const DRIVE_GATE_OPERATOR_TYPES = ['Single Swing','Double Swing','Sliding'];
  const DRIVE_GATE_POWER_TYPES = ['Existing Wiring','New Wiring','Solar'];
  const DRIVE_GATE_POWER_TYPES_INSTALL = DRIVE_GATE_POWER_TYPES.filter(t=> t !== 'Existing Wiring');
  const DRIVE_GATE_OPERATOR_DETAILS = {
    'Single Swing': {
      label: 'LiftMaster LA400PKGUL Swing Gate Operator',
      unitCost: 1866.23
    },
    'Double Swing': {
      label: 'LiftMaster LA400PKGUL Dual Swing Gate Operator',
      unitCost: 2601.25
    },
    'Sliding': {
      label: 'LiftMaster CSL24UL 24VDC High Traffic Commercial Slide Gate Operator',
      unitCost: 2596.92
    }
  };
  const DRIVE_GATE_OPERATOR_FALLBACK_LABEL = 'LiftMaster drive gate operator';
  function getDriveGateOperatorLabel(typeLabel){
    const key = String(typeLabel || '').trim();
    const detail = DRIVE_GATE_OPERATOR_DETAILS[key];
    return detail ? detail.label : DRIVE_GATE_OPERATOR_FALLBACK_LABEL;
  }

  const CREW_MEMBER_BASE_RATES = {
    Jesus: 25,
    Clay: 19,
    Joel: 18,
    JR: 18,
  };
  const CREW_LABOR_ASSUMPTIONS = {
    regularHours: 40,
    overtimeHours: 20,
    overtimeMultiplier: 1.5,
    payrollBurdenRate: 0.12,
  };
  const CREW_SETTINGS = {
    minCrew: 1,
    maxCrew: 4,
    maxWelders: 2,
    maxDayHours: 9,
  };
  const DEFAULT_CREW_MEMBERS = ['Jesus', 'JR', 'Clay', 'Joel'];
  const ONSITE_CREW_SIZE_DEFAULT = DEFAULT_CREW_MEMBERS.length;
  let ONSITE_CREW_SIZE = ONSITE_CREW_SIZE_DEFAULT;
  const CREW_ROSTER = {
    lead: 'Jesus',
    welders: ['Jesus', 'JR'],
    crew: DEFAULT_CREW_MEMBERS.slice(),
  };
  const JOB_SETUP_HOURS = 20 / 60;
  const JOB_TEARDOWN_HOURS = 20 / 60;
  const JOB_SETUP_TEARDOWN_HOURS = JOB_SETUP_HOURS + JOB_TEARDOWN_HOURS;
  const WOOD_INSTALL_PRODUCTION = {
    // Field production rates for wood install/replacement scope.
    postSpacingFt: 8,
    railsPerPost: 3,
    layoutCrewHoursPerJob: 1,
    digCrewHoursPerPostHand: 0.25,
    digCrewHoursPerPostSkid: (5 / 60),
    setCrewHoursPerPost: 0.125,
    tallDigExtraCrewHoursPerPost: (10 / 60),
    tallSetExtraCrewHoursPerPost: (5 / 60),
    sameDayCureWaitCrewHours: 2,
    buildLfPerCrewDay: 200,
    removalPanelWidthFt: 8,
    removalCrewCountSixFt: 1,
    removalMinutesPerPanelSixFt: 10,
    removalCrewCountEightFt: 2,
    removalMinutesPerPanelEightFt: 7,
    removalHaulCostPerLf: 3.9,
    removalHaulMinimum: 100,
    skidSteerRentalPerDay: 500
  };
  const WROUGHT_INSTALL_PRODUCTION = {
    // Field production rates for wrought install/replacement post-setting scope.
    layoutCrewHoursPerJob: 1,
    digCrewHoursPerPostHand: 0.25,
    digCrewHoursPerPostSkid: (5 / 60),
    setCrewHoursPerPost: 0.125,
    removalCrewCountPerPanel: 1,
    removalMinutesPerPanel: 10,
    panelInstallLfPerCrewDay: 250,
    shopFabricationCrewHoursPerPanel: 1,
    skidSteerRentalPerDay: 500
  };

  const NOTES_DATA_VERSION = 1;
  const NOTES_DATA_START = '[[SP_SCOPE_DATA_START]]';
  const NOTES_DATA_END = '[[SP_SCOPE_DATA_END]]';

  const HQ_ADDRESS = '2233 Franklin Dr Mesquite TX';
  const TRAVEL_SETTINGS = {
    dieselPrice: 3,
    mpg: 13,
    minutesPerMile: 1,
  };
  const ROUTE_CACHE_TTL_MS = 5 * 60 * 1000;
  const ROUTE_DEPARTURE_LEAD_MS = 10 * 60 * 1000;
  const ROUTE_TARGET_TIME_ZONE = 'America/Chicago';
  const ROUTE_TARGET_ARRIVAL_HOUR = 8;
  const ROUTE_TARGET_ARRIVAL_MINUTE = 0;
  const ROUTE_REFINE_MAX_PASSES = 1;

  const state = { sections: [], customerType: 'Residential', crewMembers: DEFAULT_CREW_MEMBERS.slice() };
  const mapState = {
    map: null,
    drawingManager: null,
    polylines: [],
    geocoder: null,
    routesApiUnsupported: false,
    routeInfoCache: null,
    routeInfoPromise: null,
    routesClassPromise: null,
    autocomplete: null,
    marker: null,
    addressLocation: null,
    baseLocation: null,
    baseLocationPromise: null,
    maxZoomService: null,
    nextPolylineId: 1,
    pendingAddress: '',
  };
  const MAP_POLYLINE_COLORS = {
    wood: '#d97706',
    wroughtIron: '#dc2626',
  };
  const MAP_BASE_POLYLINE_COLOR = '#111827';
  const MAP_BASE_POLYLINE_OPACITY = 0.01;
  const MAP_BASE_POLYLINE_WEIGHT = 10;
  const MAP_SEGMENT_STROKE_WEIGHT = 4;
  let pendingMapRestore = null;
  let mapUpdateScheduled = false;

  const sectionsEl = $('#sp-sections');
  const outputEl   = $('#sp-output');
  const notesEl    = $('#sp-notes');
  const notesSubEl = $('#sp-notes-sub');
  const importTextEl = document.getElementById('sp-import-text');
  const importBtn = document.getElementById('sp-import-btn');
  const importClearBtn = document.getElementById('sp-import-clear');
  const importStatusEl = document.getElementById('sp-import-status');
  const estimateNumberInput = document.getElementById('sp-estimate-number');
  const estimateLookupBtn = document.getElementById('sp-estimate-lookup');
  const proceedWithoutEstimateBtn = document.getElementById('sp-proceed-no-estimate');
  const mapAddressInput = document.getElementById('sp-map-address');
  const mapCardEl = document.getElementById('sp-map-card');
  const mapToggleBtn = document.getElementById('sp-map-toggle');
  const estimateStatusEl = document.getElementById('sp-estimate-status');
  const defaultEstimateStatus = estimateStatusEl ? estimateStatusEl.textContent : '';
  const manualCostInput = document.getElementById('sp-manual-cost');
  const manualCalcBtn = document.getElementById('sp-manual-calc');
  const manualChargeOutput = document.getElementById('sp-manual-charge');
  const manualModeChip = document.getElementById('sp-manual-mode');
  const manualStatusEl = document.getElementById('sp-manual-status');
  const manualHoursInput = document.getElementById('sp-manual-hours');
  const manualGrossOutput = document.getElementById('sp-manual-gross');
  const manualGrossHourOutput = document.getElementById('sp-manual-gross-hour');
  const manualCommissionOutput = document.getElementById('sp-manual-commission');
  const manualNetOutput = document.getElementById('sp-manual-net');
  
  const customerTypeSelect = document.getElementById('sp-customer-type');
  const customerMinHint = document.getElementById('sp-customer-min-hint');
  const customerCardEl = document.getElementById('sp-customer-card');
  const customerConfirmBtn = document.getElementById('sp-customer-confirm');
  const manualModal = document.getElementById('sp-manual-modal');
  const manualOpenBtn = document.getElementById('sp-open-manual');
  const manualCloseBtn = document.getElementById('sp-manual-close');
  const importModal = document.getElementById('sp-import-modal');
  const importOpenBtn = document.getElementById('sp-open-import');
  const importCloseBtn = document.getElementById('sp-import-close');
  const pushHcpBtn = document.getElementById('sp-push-hcp');
  const serviceCardEl = $('#sp-service-card');
  const serviceListEl = $('#sp-service-lines');
  const serviceCopyAllBtn = $('#sp-copy-service');
  const serviceOptionInput = document.getElementById('sp-service-option-number');
  const pushServiceHcpBtn = document.getElementById('sp-push-service-hcp');
  const quickCostsCardEl = document.getElementById('sp-quick-costs-card');
  const quickCostsCopyAllBtn = document.getElementById('sp-copy-costs-all');
  const quickCostChargeInput = document.getElementById('sp-cost-charge');
  const quickCostTravelInput = document.getElementById('sp-cost-travel');
  const quickCostMaterialsInput = document.getElementById('sp-cost-materials');
  const quickCostConsumablesInput = document.getElementById('sp-cost-consumables');
  const quickCostLaborInput = document.getElementById('sp-cost-labor');
  const quickCostOverheadInput = document.getElementById('sp-cost-overhead');
  const quickCostCommissionInput = document.getElementById('sp-cost-commission');
  const quickCostChargeBtn = document.getElementById('sp-copy-cost-charge');
  const quickCostTravelBtn = document.getElementById('sp-copy-cost-travel');
  const quickCostMaterialsBtn = document.getElementById('sp-copy-cost-materials');
  const quickCostConsumablesBtn = document.getElementById('sp-copy-cost-consumables');
  const quickCostLaborBtn = document.getElementById('sp-copy-cost-labor');
  const quickCostOverheadBtn = document.getElementById('sp-copy-cost-overhead');
  const quickCostCommissionBtn = document.getElementById('sp-copy-cost-commission');
  const laborRateInput = document.getElementById('sp-labor-rate');
  const crewMemberInputs = Array.from(document.querySelectorAll('input[data-crew-member]'));
  const crewMembersHint = document.getElementById('sp-crew-members-hint');
  const estimateLookupBtnLabel = estimateLookupBtn ? estimateLookupBtn.textContent : '';
  const scopeEl = document.getElementById('sp-scope');
  let gateUnlocked = false;
  let lastServiceLines = [];
  let isPushingServiceLineItems = false;
  let lastQuickCosts = null;
  let autoGenerateTimer = null;
  let isGeneratingNotes = false;
  let pendingNotesRegeneration = false;
  let estimateLookupController = null;
  let lastEstimateLookupNumber = '';
  let lastEstimateAddress = '';
  let lastEstimateId = '';
  let lastEstimateExists = false;
  let customerTypeConfirmed = false;

  function setGateUnlocked(unlocked){
    gateUnlocked = !!unlocked;
    if(!scopeEl){
      return;
    }
    scopeEl.classList.toggle('sp-onboard', !gateUnlocked);
  }

  function setCustomerTypeConfirmed(confirmed){
    customerTypeConfirmed = !!confirmed;
    if(customerCardEl){
      customerCardEl.classList.toggle('is-unconfirmed', !customerTypeConfirmed);
    }
    if(customerConfirmBtn){
      customerConfirmBtn.textContent = customerTypeConfirmed ? 'Confirmed' : 'Confirm';
      customerConfirmBtn.classList.toggle('primary', !customerTypeConfirmed);
      customerConfirmBtn.disabled = customerTypeConfirmed;
    }
  }

  function normalizeCrewMembers(list){
    const selected = Array.isArray(list)
      ? list.map(name=> String(name || '').trim()).filter(Boolean)
      : [];
    const selectedSet = new Set(selected);
    return DEFAULT_CREW_MEMBERS.filter(name=> selectedSet.has(name));
  }

  function computeCrewLaborRate(members){
    const crewMembers = normalizeCrewMembers(members);
    const regularHours = Math.max(0, Number(CREW_LABOR_ASSUMPTIONS.regularHours || 0) || 0);
    const overtimeHours = Math.max(0, Number(CREW_LABOR_ASSUMPTIONS.overtimeHours || 0) || 0);
    const overtimeMultiplier = Math.max(0, Number(CREW_LABOR_ASSUMPTIONS.overtimeMultiplier || 0) || 0);
    const payrollBurdenRate = Math.max(0, Number(CREW_LABOR_ASSUMPTIONS.payrollBurdenRate || 0) || 0);
    const weeklyCrewHours = regularHours + overtimeHours;
    if(!crewMembers.length || weeklyCrewHours <= 0){
      return 0;
    }
    const weeklyWages = crewMembers.reduce((sum, name)=>{
      const baseRate = Number(CREW_MEMBER_BASE_RATES[name]);
      if(!isFinite(baseRate) || baseRate <= 0){
        return sum;
      }
      const regularPay = regularHours * baseRate;
      const overtimePay = overtimeHours * baseRate * overtimeMultiplier;
      return sum + regularPay + overtimePay;
    }, 0);
    if(!isFinite(weeklyWages) || weeklyWages <= 0){
      return 0;
    }
    const weeklyCostWithPayroll = weeklyWages * (1 + payrollBurdenRate);
    return weeklyCostWithPayroll / weeklyCrewHours;
  }

  function getActiveCrewMembers(){
    const selected = normalizeCrewMembers(state.crewMembers);
    return selected.length ? selected : DEFAULT_CREW_MEMBERS.slice();
  }

  function getActiveLaborRate(){
    const rate = computeCrewLaborRate(getActiveCrewMembers());
    return (isFinite(rate) && rate > 0) ? rate : 0;
  }

  function updateLaborRateDisplay(){
    if(!laborRateInput) return;
    laborRateInput.value = `$${money(getActiveLaborRate())}/hr (crew rate)`;
  }

  function applyCrewMembersSelection(nextMembers, options = {}){
    const selected = normalizeCrewMembers(nextMembers);
    const fallback = getActiveCrewMembers();
    const appliedMembers = selected.length ? selected : fallback;
    const memberSet = new Set(appliedMembers);

    if(!options.skipDomSync && crewMemberInputs.length){
      crewMemberInputs.forEach(input=>{
        const name = String(input.dataset.crewMember || '').trim();
        input.checked = memberSet.has(name);
      });
    }

    state.crewMembers = appliedMembers.slice();
    CREW_ROSTER.crew = appliedMembers.slice();
    ONSITE_CREW_SIZE = Math.max(1, appliedMembers.length);
    updateLaborRateDisplay();

    if(crewMembersHint){
      const peopleLabel = ONSITE_CREW_SIZE === 1 ? 'person' : 'people';
      crewMembersHint.textContent = `${ONSITE_CREW_SIZE} ${peopleLabel} assigned: ${appliedMembers.join(', ')}.`;
    }
  }

  setGateUnlocked(false);
  setCustomerTypeConfirmed(false);

  applyCrewMembersSelection(state.crewMembers);

  function uid(){ return 'sec_' + Math.random().toString(36).slice(2,9); }

  function sanitizeEstimateNumber(value){
    return (value || '').replace(/[^0-9]/g, '');
  }

  function parsePositiveInt(value){
    const parsed = parseInt(value, 10);
    return (isFinite(parsed) && parsed > 0) ? parsed : 0;
  }

  function encodePayloadForNotes(payload){
    try{
      const json = JSON.stringify(payload);
      return btoa(unescape(encodeURIComponent(json)));
    }catch(err){
      console.error('Failed to encode notes payload', err);
      return '';
    }
  }

  function decodePayloadFromNotes(encoded){
    try{
      const json = decodeURIComponent(escape(atob(encoded)));
      return JSON.parse(json);
    }catch(err){
      console.error('Failed to decode notes payload', err);
      return null;
    }
  }

  function extractEmbeddedNotesData(text){
    if(!text) return '';
    const start = text.indexOf(NOTES_DATA_START);
    const end = text.indexOf(NOTES_DATA_END);
    if(start === -1 || end === -1 || end <= start) return '';
    return text.slice(start + NOTES_DATA_START.length, end).trim();
  }

  function parseLegacyNotesSnapshot(text){
    if(!text) return null;

    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const sections = [];
    let current = null;

    const parseNumber = (value)=>{
      const match = String(value||'').replace(/,/g,'').match(/-?\d+(?:\.\d+)?/);
      return match ? parseFloat(match[0]) : NaN;
    };

    const pushCurrent = ()=>{
      if(current){
        sections.push(current);
        current = null;
      }
    };

    lines.forEach(rawLine => {
      const line = normalizeLabelText(rawLine);
      if(!line) return;

      const sectionMatch = line.match(/^Section\s+\d+\s*-\s*(.+)$/i);
      if(sectionMatch){
        pushCurrent();
        const labelText = sectionMatch[1].trim();
        current = createSectionBase({});
        current.label = labelText;
        if(/map run/i.test(labelText)){
          current.mapGeneratedLabel = labelText;
        }
        return;
      }

      if(!current) return;

      const scopeMatch = line.match(/^-\s*Scope:\s*(.+)$/i);
      if(scopeMatch){
        const rawScope = scopeMatch[1].toLowerCase();
        if(/replace/.test(rawScope)) current.scopeType = 'replace';
        else if(/install/.test(rawScope)) current.scopeType = 'install';
        else current.scopeType = 'repair';
        return;
      }

      const styleMatch = line.match(/^-\s*Style:\s*(.+)$/i);
      if(styleMatch){
        current.style = styleMatch[1].trim();
        return;
      }

      const heightMatch = line.match(/^-\s*Height:\s*(.+)$/i);
      if(heightMatch){
        current.height = heightMatch[1].trim();
        return;
      }

      const railsMatch = line.match(/^-\s*Rails:\s*Top\s*Rail:\s*([^;]+);\s*Bottom\s*Rail:\s*(.+)$/i);
      if(railsMatch){
        const topRaw = railsMatch[1].trim();
        const bottomRaw = railsMatch[2].trim();
        const topStacked = /stacked/i.test(topRaw);
        const topSizes = topRaw.replace(/\(stacked\)/i,'').split('+').map(part => normalizeSize(part));
        const topSize = topSizes[0] || SEED.railSize[0];
        const topSize2 = topStacked ? (topSizes[1] || topSizes[0] || SEED.railSize[0]) : (topSizes[1] || topSizes[0]);
        const bottomSize = normalizeSize(bottomRaw || SEED.railSize[0]);
        current.rails = [
          { size: topSize, stacked: topStacked || (!!topSizes[1]), size2: topSize2 || topSize, patches:0, replacements:0 },
          { size: bottomSize || SEED.railSize[0], stacked:false, size2: bottomSize || SEED.railSize[0], patches:0, replacements:0 },
        ];
        current.railsCount = current.rails.length;
        return;
      }

      const picketMatch = line.match(/^-\s*Picket:\s*(.+)$/i);
      if(picketMatch){
        const clean = normalizeSize(picketMatch[1]);
        current.picketSize = clean || current.picketSize;
        return;
      }

      const puppyMatch = line.match(/^-\s*Puppy\s*Pickets:\s*(.+)$/i);
      if(puppyMatch){
        const val = puppyMatch[1].trim();
        current.puppy = val && !/none/i.test(val) ? 'Puppy Pickets' : 'None';
        return;
      }

      const paintingMatch = line.match(/^-\s*Painting:\s*(.+)$/i);
      if(paintingMatch){
        current.painting = paintingMatch[1].trim();
        return;
      }

      const paintMethodMatch = line.match(/^-\s*Paint\s*application:\s*(.+)$/i);
      if(paintMethodMatch){
        current.paintingApplication = paintMethodMatch[1].trim();
        return;
      }

      const prepMatch = line.match(/^-\s*Prep\s*needs:\s*(.+)$/i);
      if(prepMatch){
        current.paintingPrepExtra = /more|extra|yes|true/i.test(prepMatch[1]);
        return;
      }

      const currentColorMatch = line.match(/^-\s*Current\s*(?:fence\s*)?color:\s*(.+)$/i);
      if(currentColorMatch){
        current.paintingCurrentColor = currentColorMatch[1].trim();
        return;
      }

      const paintColorMatch = line.match(/^-\s*(?:Paint|Painting)\s*color:\s*(.+)$/i);
      if(paintColorMatch){
        current.paintingTargetColor = paintColorMatch[1].trim();
        return;
      }

      const lengthMatch = line.match(/^-\s*Length:\s*(.+)$/i);
      if(lengthMatch){
        const num = parseNumber(lengthMatch[1]);
        if(isFinite(num)) current.length = num;
        return;
      }

      const hardscapeMatch = line.match(/^-\s*Over\s*hardscape:\s*(.+)$/i);
      if(hardscapeMatch){
        const num = parseNumber(hardscapeMatch[1]);
        if(isFinite(num)) current.hardscape = num;
        return;
      }

      const trimMatch = line.match(/^-\s*Trim:\s*(.+)$/i);
      if(trimMatch){
        const num = parseNumber(trimMatch[1]);
        if(isFinite(num)) current.trim = num;
        return;
      }

      const digMatch = line.match(/^-\s*Dig\s*out:\s*(.+)$/i);
      if(digMatch){
        const num = parseNumber(digMatch[1]);
        if(isFinite(num)) current.digOut = num;
        return;
      }

      const repairPicketsMatch = line.match(/^-\s*Pickets\s*to\s*replace:\s*(.+)$/i);
      if(repairPicketsMatch){
        const num = parseNumber(repairPicketsMatch[1]);
        if(isFinite(num)) current.wiPickets = num;
        return;
      }
    });

    pushCurrent();

    if(!sections.length){
      return null;
    }

    return {
      version: NOTES_DATA_VERSION,
      generatedAt: new Date().toISOString(),
      state: { sections, customerType: getCustomerType() },
      map: { address: '', polylines: [], nextPolylineId: 1 },
      estimate: { number: '', address: '', id: '' }
    };
  }

  function updateEstimateStatus(message, state){
    if(!estimateStatusEl){
      return;
    }
    const nextState = state || (message ? 'info' : '');
    if(message){
      estimateStatusEl.textContent = message;
    }else{
      estimateStatusEl.textContent = defaultEstimateStatus || '';
    }
    if(nextState){
      estimateStatusEl.setAttribute('data-state', nextState);
    }else{
      estimateStatusEl.removeAttribute('data-state');
    }
  }

  function updateImportStatus(message, state){
    if(!importStatusEl){
      return;
    }
    importStatusEl.textContent = message || 'Paste notes that include the embedded reload key added by this generator.';
    if(state){
      importStatusEl.setAttribute('data-state', state);
    } else {
      importStatusEl.removeAttribute('data-state');
    }
  }

  function formatEstimateAddress(address){
    if(!address || typeof address !== 'object'){
      return '';
    }
    const segments = [];
    if(address.street){
      segments.push(address.street);
    }
    if(address.street_line_2){
      segments.push(address.street_line_2);
    }
    const cityState = [address.city, address.state].filter(Boolean).join(', ');
    if(cityState){
      segments.push(cityState);
    }
    if(address.zip){
      segments.push(address.zip);
    }
    if(address.country && address.country.toLowerCase() !== 'usa' && address.country.toLowerCase() !== 'us'){
      segments.push(address.country);
    }
    return segments.join(', ');
  }

  function extractEstimateAddressPayload(payload){
    if(!payload){
      return { formatted: '', hasAddress: false };
    }

    if(typeof payload === 'string'){
      const formatted = payload.trim();
      return { formatted, hasAddress: !!formatted };
    }

    if(Array.isArray(payload)){
      for(const item of payload){
        const result = extractEstimateAddressPayload(item);
        if(result.hasAddress){
          return result;
        }
      }
      return { formatted: '', hasAddress: false };
    }

    const candidates = [payload];
    ['data', 'result', 'estimate'].forEach(key=>{
      if(payload && payload[key]){
        candidates.push(payload[key]);
      }
    });

    for(const candidate of candidates){
      if(!candidate || typeof candidate !== 'object'){
        continue;
      }
      if(typeof candidate.address === 'string'){
        const formatted = candidate.address.trim();
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      if(candidate.formatted_address){
        const formatted = String(candidate.formatted_address).trim();
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      if(candidate.address && typeof candidate.address === 'object'){
        const formatted = formatEstimateAddress(candidate.address);
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
      const streetLike = candidate.street || candidate.address_line_1 || candidate.address1 || candidate.line1;
      const cityLike = candidate.city;
      const stateLike = candidate.state || candidate.region;
      const zipLike = candidate.zip || candidate.postal_code || candidate.zipcode;
      if(streetLike || candidate.street_line_2 || cityLike || stateLike || zipLike){
        const formatted = formatEstimateAddress({
          street: streetLike,
          street_line_2: candidate.street_line_2 || candidate.address_line_2 || candidate.address2 || candidate.line2,
          city: cityLike,
          state: stateLike,
          zip: zipLike,
          country: candidate.country,
        });
        if(formatted){
          return { formatted, hasAddress: true };
        }
      }
    }

    return { formatted: '', hasAddress: false };
  }

  function isEstimateNotFound(payload){
    if(!payload || typeof payload !== 'object'){
      return !payload;
    }
    if(payload.found === false || payload.notFound === true){
      return true;
    }
    if(payload.success === false && typeof payload.error === 'string' && payload.error.toLowerCase().includes('not found')){
      return true;
    }
    const nestedKeys = ['data', 'result', 'estimate'];
    return nestedKeys.some(key=>{
      const value = payload[key];
      return value && typeof value === 'object' ? isEstimateNotFound(value) : false;
    });
  }

  function normalizeEstimateId(value){
    if(value == null){
      return '';
    }
    if(typeof value !== 'string' && typeof value !== 'number'){
      return '';
    }
    const text = String(value).trim();
    if(!text){
      return '';
    }
    return text;
  }

  function extractEstimateId(payload){
    if(!payload){
      return '';
    }
    if(typeof payload === 'string' || typeof payload === 'number'){
      return '';
    }
    if(Array.isArray(payload)){
      for(const item of payload){
        const candidate = extractEstimateId(item);
        if(candidate){
          return candidate;
        }
      }
      return '';
    }

    const candidates = [payload];
    ['data', 'result', 'estimate'].forEach(key=>{
      if(payload && payload[key]){
        candidates.push(payload[key]);
      }
    });

    const pending = [...candidates];
    const seen = new Set();

    while(pending.length){
      const candidate = pending.shift();
      if(!candidate || typeof candidate !== 'object' || seen.has(candidate)){
        continue;
      }
      seen.add(candidate);

      const idCandidate = candidate.id
        || candidate.estimateId
        || candidate.estimate_id
        || candidate.estimateID;
      const normalized = normalizeEstimateId(idCandidate);
      if(normalized){
        return normalized;
      }

      for(const value of Object.values(candidate)){
        if(value && typeof value === 'object'){
          pending.push(value);
        }
      }
    }

    return '';
  }

  function zoomMapToMax(location){
    if(!mapState.map || !location){
      return;
    }
    const fallbackZoom = 21;
    const hasGoogle = typeof google !== 'undefined' && google && google.maps;
    const service = mapState.maxZoomService;
    if(hasGoogle && service && typeof service.getMaxZoomAtLatLng === 'function' && google.maps.MaxZoomStatus){
      service.getMaxZoomAtLatLng(location, result=>{
        if(result && result.status === google.maps.MaxZoomStatus.OK && typeof result.zoom === 'number'){
          mapState.map.setZoom(result.zoom);
        }else{
          mapState.map.setZoom(fallbackZoom);
        }
      });
    }else{
      mapState.map.setZoom(fallbackZoom);
    }
  }

  function focusMapOnAddress(address){
    const value = (address || '').trim();
    if(!value){
      mapState.pendingAddress = '';
      updateMapAddressMarker(null);
      return;
    }
    if(!addressesMatch(mapState.pendingAddress, value)){
      mapState.addressLocation = null;
    }
    mapState.pendingAddress = value;
    if(!mapState.map || !mapState.geocoder){
      return;
    }
    mapState.geocoder.geocode({ address: value }, (results, status)=>{
      if(status === 'OK' && results && results[0]){
        const geometry = results[0].geometry || {};
        const viewport = geometry.viewport;
        let loc = geometry.location;
        if(!loc && viewport && typeof viewport.getCenter === 'function'){
          loc = viewport.getCenter();
        }
        if(viewport){
          mapState.map.fitBounds(viewport);
        }
        if(loc){
          mapState.map.setCenter(loc);
          zoomMapToMax(loc);
        }
        if(loc){
          updateMapAddressMarker(loc);
        }
      }else{
        console.warn('Geocode failed for address', value, status);
      }
    });
  }

  function setMapAddressFromEstimate(address){
    if(!address){
      return;
    }
    if(mapAddressInput){
      mapAddressInput.value = address;
    }
    setMapCollapsed(false);
    focusMapOnAddress(address);
    persist();
  }

  function normalizeAddressText(addr){
    return (addr || '').trim();
  }

  function geocodeAddress(address){
    return new Promise(resolve => {
      const value = normalizeAddressText(address);
      if(!value){
        resolve(null);
        return;
      }
      if(!mapState.geocoder && typeof google !== 'undefined' && google.maps && typeof google.maps.Geocoder === 'function'){
        mapState.geocoder = new google.maps.Geocoder();
      }
      if(!mapState.geocoder){
        resolve(null);
        return;
      }
      mapState.geocoder.geocode({ address: value }, (results, status)=>{
        if(status === 'OK' && results && results[0] && results[0].geometry && results[0].geometry.location){
          resolve(results[0].geometry.location);
        }else{
          resolve(null);
        }
      });
    });
  }

  function addressesMatch(a, b){
    return normalizeAddressText(a).toLowerCase() === normalizeAddressText(b).toLowerCase();
  }

  async function getBaseLocation(){
    if(mapState.baseLocation){
      return mapState.baseLocation;
    }
    if(mapState.baseLocationPromise){
      return mapState.baseLocationPromise;
    }
    mapState.baseLocationPromise = geocodeAddress(HQ_ADDRESS)
      .then(location => {
        mapState.baseLocation = location || null;
        return mapState.baseLocation;
      })
      .catch(() => null)
      .finally(()=>{
        mapState.baseLocationPromise = null;
      });
    return mapState.baseLocationPromise;
  }

  async function resolveJobLocation(jobAddress){
    const normalized = normalizeAddressText(jobAddress);
    if(!normalized){
      return null;
    }
    if(mapState.addressLocation && addressesMatch(mapState.pendingAddress, normalized)){
      return mapState.addressLocation;
    }
    const location = await geocodeAddress(normalized);
    if(location && mapAddressInput && addressesMatch(mapAddressInput.value, normalized)){
      mapState.pendingAddress = normalized;
      mapState.addressLocation = location;
    }
    return location;
  }

  function readLatLngValue(point, key){
    if(!point){
      return NaN;
    }
    const raw = point[key];
    if(typeof raw === 'function'){
      return Number(raw.call(point));
    }
    return Number(raw);
  }

  function milesBetween(a, b){
    const latA = readLatLngValue(a, 'lat');
    const lngA = readLatLngValue(a, 'lng');
    const latB = readLatLngValue(b, 'lat');
    const lngB = readLatLngValue(b, 'lng');
    if(!isFinite(latA) || !isFinite(lngA) || !isFinite(latB) || !isFinite(lngB)){
      return 0;
    }
    const toRadians = value => (value * Math.PI) / 180;
    const dLat = toRadians(latB - latA);
    const dLng = toRadians(lngB - lngA);
    const lat1 = toRadians(latA);
    const lat2 = toRadians(latB);
    const sinDLat = Math.sin(dLat / 2);
    const sinDLng = Math.sin(dLng / 2);
    const h = (sinDLat * sinDLat) + Math.cos(lat1) * Math.cos(lat2) * (sinDLng * sinDLng);
    const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
    const earthRadiusMiles = 3958.7613;
    return earthRadiusMiles * c;
  }

  async function computeFallbackTravelInfo(jobAddress){
    const baseLocation = await getBaseLocation();
    if(!baseLocation){
      return { included: false, reason: 'geocode' };
    }
    const jobLocation = await resolveJobLocation(jobAddress);
    if(!jobLocation){
      return { included: false, reason: 'geocode' };
    }
    const milesOneWay = milesBetween(baseLocation, jobLocation);
    if(!isFinite(milesOneWay) || milesOneWay < 0){
      return { included: false, reason: 'distance' };
    }
    const minutesPerMile = Number(TRAVEL_SETTINGS.minutesPerMile);
    const hoursOneWay = (milesOneWay * minutesPerMile) / 60;
    if(!isFinite(hoursOneWay) || hoursOneWay < 0){
      return { included: false, reason: 'distance' };
    }
    return {
      included: true,
      milesOneWay,
      hoursOneWay,
    };
  }

  async function getRoutesClass(){
    if(mapState.routesClassPromise){
      return mapState.routesClassPromise;
    }
    if(typeof google === 'undefined' || !google.maps || typeof google.maps.importLibrary !== 'function'){
      return null;
    }
    mapState.routesClassPromise = google.maps.importLibrary('routes')
      .then(library => {
        const Route = library && library.Route ? library.Route : null;
        return Route && typeof Route.computeRoutes === 'function' ? Route : null;
      })
      .catch(()=>{
        mapState.routesClassPromise = null;
        return null;
      });
    return mapState.routesClassPromise;
  }

  const WEEKDAY_BY_SHORT_NAME = {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6,
  };

  function getZonedDateParts(date, timeZone){
    try{
      const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        weekday: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
      });
      const bag = {};
      formatter.formatToParts(date).forEach(part=>{
        if(part.type !== 'literal'){
          bag[part.type] = part.value;
        }
      });
      const weekdayShort = String(bag.weekday || '').slice(0, 3).toLowerCase();
      return {
        year: Number(bag.year),
        month: Number(bag.month),
        day: Number(bag.day),
        hour: Number(bag.hour),
        minute: Number(bag.minute),
        second: Number(bag.second),
        weekday: WEEKDAY_BY_SHORT_NAME[weekdayShort],
      };
    }catch(_err){
      return null;
    }
  }

  function zonedLocalToUtcDate(parts, timeZone){
    let guess = new Date(Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour || 0, parts.minute || 0, parts.second || 0));
    for(let i = 0; i < 4; i += 1){
      const observed = getZonedDateParts(guess, timeZone);
      if(!observed){
        break;
      }
      const desiredAsUtcMs = Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour || 0, parts.minute || 0, parts.second || 0);
      const observedAsUtcMs = Date.UTC(observed.year, observed.month - 1, observed.day, observed.hour || 0, observed.minute || 0, observed.second || 0);
      const diff = desiredAsUtcMs - observedAsUtcMs;
      if(Math.abs(diff) < 1000){
        break;
      }
      guess = new Date(guess.getTime() + diff);
    }
    return guess;
  }

  function getNextTexasWeekdayArrivalDate(){
    const now = new Date();
    const nowParts = getZonedDateParts(now, ROUTE_TARGET_TIME_ZONE);
    if(!nowParts || !isFinite(nowParts.year) || !isFinite(nowParts.month) || !isFinite(nowParts.day)){
      return new Date(Date.now() + ROUTE_DEPARTURE_LEAD_MS);
    }

    // "Next weekday" means the next Mon-Fri after today in Texas time.
    const startUtcNoon = Date.UTC(nowParts.year, nowParts.month - 1, nowParts.day, 12, 0, 0);
    for(let offset = 1; offset <= 14; offset += 1){
      const probe = new Date(startUtcNoon + (offset * 24 * 60 * 60 * 1000));
      const probeParts = getZonedDateParts(probe, ROUTE_TARGET_TIME_ZONE);
      if(!probeParts) continue;
      if(probeParts.weekday < 1 || probeParts.weekday > 5) continue;
      return zonedLocalToUtcDate({
        year: probeParts.year,
        month: probeParts.month,
        day: probeParts.day,
        hour: ROUTE_TARGET_ARRIVAL_HOUR,
        minute: ROUTE_TARGET_ARRIVAL_MINUTE,
        second: 0,
      }, ROUTE_TARGET_TIME_ZONE);
    }

    return new Date(Date.now() + ROUTE_DEPARTURE_LEAD_MS);
  }

  function getFirstRouteMetrics(response){
    const route = response && Array.isArray(response.routes) ? response.routes[0] : null;
    if(!route){
      return null;
    }
    const distanceMeters = Number(route.distanceMeters);
    const durationMillis = Number(route.durationMillis);
    if(!isFinite(distanceMeters) || !isFinite(durationMillis) || distanceMeters < 0 || durationMillis < 0){
      return null;
    }
    return { distanceMeters, durationMillis };
  }

  function isRoutesPermissionError(message){
    const text = String(message || '').toLowerCase();
    if(!text){
      return false;
    }
    return text.includes('permission_denied')
      || text.includes('not enabled')
      || text.includes('request denied')
      || text.includes('not authorized')
      || text.includes('apiprojectmaperror')
      || text.includes('apinotactivatedmaperror')
      || text.includes('legacyapinotactivatedmaperror');
  }

  async function requestDrivingRouteInfo(originAddress, destinationAddress){
    if(mapState.routesApiUnsupported){
      return { included: false, reason: 'route_unavailable' };
    }
    const Route = await getRoutesClass();
    if(!Route){
      return { included: false, reason: 'route_unavailable' };
    }

    const request = {
      origin: originAddress,
      destination: destinationAddress,
      travelMode: 'DRIVING',
      routingPreference: 'TRAFFIC_AWARE_OPTIMAL',
      fields: ['distanceMeters', 'durationMillis'],
    };

    let response = null;
    const targetArrival = getNextTexasWeekdayArrivalDate();
    let departureTime = new Date(targetArrival.getTime() - (60 * 60 * 1000));
    if(!isFinite(departureTime.getTime()) || departureTime.getTime() <= Date.now()){
      departureTime = new Date(Date.now() + ROUTE_DEPARTURE_LEAD_MS);
    }

    try{
      const firstRequest = { ...request, departureTime };
      response = await Route.computeRoutes(firstRequest);

      let metrics = getFirstRouteMetrics(response);
      if(metrics){
        for(let pass = 0; pass < ROUTE_REFINE_MAX_PASSES; pass += 1){
          const refinedDeparture = new Date(targetArrival.getTime() - metrics.durationMillis);
          if(!isFinite(refinedDeparture.getTime()) || refinedDeparture.getTime() <= Date.now()){
            break;
          }
          if(Math.abs(refinedDeparture.getTime() - departureTime.getTime()) < (5 * 60 * 1000)){
            break;
          }
          departureTime = refinedDeparture;
          const refineRequest = { ...request, departureTime };
          const refinedResponse = await Route.computeRoutes(refineRequest);
          const refinedMetrics = getFirstRouteMetrics(refinedResponse);
          if(!refinedMetrics){
            break;
          }
          response = refinedResponse;
          metrics = refinedMetrics;
        }
      }
    }catch(err){
      const message = err && err.message ? err.message : String(err || '');
      const lowerMessage = message.toLowerCase();

      // Some environments reject timestamps; retry without explicit departureTime.
      if(lowerMessage.includes('timestamp must be set to a future time')){
        try{
          const retryRequest = {
            ...request,
            routingPreference: 'TRAFFIC_AWARE',
          };
          response = await Route.computeRoutes(retryRequest);
        }catch(retryErr){
          const retryMessage = retryErr && retryErr.message ? retryErr.message : String(retryErr || '');
          console.warn('Routes library computeRoutes failed', retryMessage);
          if(isRoutesPermissionError(retryMessage)){
            mapState.routesApiUnsupported = true;
            return { included: false, reason: 'route_unavailable' };
          }
          return { included: false, reason: 'route' };
        }
      }else{
        console.warn('Routes library computeRoutes failed', message);
        if(isRoutesPermissionError(message)){
          mapState.routesApiUnsupported = true;
          return { included: false, reason: 'route_unavailable' };
        }
        return { included: false, reason: 'route' };
      }
    }

    try{
      const metrics = getFirstRouteMetrics(response);
      if(!metrics){
        return { included: false, reason: 'route' };
      }
      return {
        included: true,
        milesOneWay: metrics.distanceMeters / 1609.34,
        hoursOneWay: metrics.durationMillis / 3600000,
      };
    }catch(_err){
      return { included: false, reason: 'route' };
    }
  }

  async function getDrivingRouteInfo(originAddress, destinationAddress){
    const origin = normalizeAddressText(originAddress).toLowerCase();
    const destination = normalizeAddressText(destinationAddress).toLowerCase();
    const cacheKey = `${origin}=>${destination}`;
    const now = Date.now();

    if(mapState.routeInfoCache
      && mapState.routeInfoCache.key === cacheKey
      && (now - mapState.routeInfoCache.timestamp) <= ROUTE_CACHE_TTL_MS){
      return mapState.routeInfoCache.value;
    }

    if(mapState.routeInfoPromise && mapState.routeInfoPromise.key === cacheKey){
      return mapState.routeInfoPromise.promise;
    }

    const promise = requestDrivingRouteInfo(originAddress, destinationAddress)
      .then(result => {
        if(result && (result.included || result.reason === 'route_unavailable')){
          mapState.routeInfoCache = {
            key: cacheKey,
            timestamp: Date.now(),
            value: result,
          };
        }else{
          mapState.routeInfoCache = null;
        }
        return result;
      })
      .finally(()=>{
        if(mapState.routeInfoPromise && mapState.routeInfoPromise.key === cacheKey){
          mapState.routeInfoPromise = null;
        }
      });

    mapState.routeInfoPromise = { key: cacheKey, promise };
    return promise;
  }

  async function computeTravelDayInfo(jobAddress){
    const result = { roundTripMiles: 0, hoursPerDay: 0, included: false, reason: '' };

    const normalizedAddress = normalizeAddressText(jobAddress);
    if(!normalizedAddress){
      result.reason = 'address';
      return result;
    }

    let drivingInfo = await getDrivingRouteInfo(HQ_ADDRESS, normalizedAddress);
    if(!drivingInfo.included){
      const fallbackInfo = await computeFallbackTravelInfo(normalizedAddress);
      if(!fallbackInfo.included){
        result.reason = fallbackInfo.reason || drivingInfo.reason || 'route';
        return result;
      }
      drivingInfo = fallbackInfo;
    }

    const milesOneWay = drivingInfo.milesOneWay;
    const roundTripMiles = milesOneWay * 2;
    const travelHoursPerDay = drivingInfo.hoursOneWay * 2;
    result.roundTripMiles = roundTripMiles;
    result.hoursPerDay = travelHoursPerDay;
    result.included = true;
    return result;
  }

  async function computeTravelCost({ crewSchedule, jobAddress, travelDayInfo }){
    const result = { cost: 0, breakdown: [], hours: 0, included: false };
    const travelInfo = travelDayInfo || await computeTravelDayInfo(jobAddress);

    if(!travelInfo.included){
      if(travelInfo.reason === 'address'){
        result.breakdown.push('- Travel: Address required to calculate fuel and drive time.');
      }else if(travelInfo.reason === 'route_unavailable'){
        result.breakdown.push('- Travel: Routes API ETA is unavailable for this API key/project; travel cost not included.');
      }else if(travelInfo.reason === 'route'){
        result.breakdown.push('- Travel: Unable to calculate route ETA; travel cost not included.');
      }else if(travelInfo.reason === 'geocode'){
        result.breakdown.push('- Travel: Unable to locate job address; travel cost not included.');
      }else if(travelInfo.reason === 'distance'){
        result.breakdown.push('- Travel: Unable to calculate distance; travel cost not included.');
      }
      return result;
    }

    const travelDays = crewSchedule.filter(day => (day.crew||0) > 0).length;
    if(travelDays <= 0){
      return result;
    }

    const roundTripMiles = travelInfo.roundTripMiles;
    const fuelPerDay = (roundTripMiles / TRAVEL_SETTINGS.mpg) * TRAVEL_SETTINGS.dieselPrice;
    const totalFuelCost = fuelPerDay * travelDays;
    const travelHours = travelInfo.hoursPerDay * travelDays;
    const laborRate = getActiveLaborRate();
    const travelLaborCost = travelHours * laborRate;

    const cost = totalFuelCost + travelLaborCost;
    result.cost = cost;
    result.hours = travelHours;
    result.included = true;
    result.breakdown.push(`- Travel: ${roundTripMiles.toFixed(1)} miles round trip x ${travelDays} day(s) = $${money(cost)} (fuel $${money(totalFuelCost)}, travel labor $${money(travelLaborCost)} @ $${money(laborRate)}/hr)`);
    return result;
  }

  async function fetchEstimateByNumber(estimateNumber, options){
    const opts = options || {};
    const signal = opts.signal;
    const response = await fetch('https://api.strongclicks.io/webhook/get-estimate-address', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ estimateNumber, includeEstimateId: true }),
      signal,
    });

    if(signal && signal.aborted){
      throw new DOMException('Aborted', 'AbortError');
    }

    if(!response.ok){
      const text = await response.text();
      throw new Error(text || `Estimate lookup failed with status ${response.status}`);
    }

    try{
      return await response.json();
    }catch(err){
      console.error('Failed to parse estimate lookup response', err);
      throw new Error('Received an invalid response while fetching the estimate address.');
    }
  }

  async function lookupEstimateAddress(estimateNumber){
    if(!estimateNumber){
      return;
    }
    if(estimateLookupController && typeof estimateLookupController.abort === 'function'){
      estimateLookupController.abort();
    }
    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
    estimateLookupController = controller;

    updateEstimateStatus('Looking up estimate address…', 'loading');
    if(estimateLookupBtn){
      estimateLookupBtn.disabled = true;
      estimateLookupBtn.textContent = 'Fetching…';
    }

    try{
      const estimate = await fetchEstimateByNumber(estimateNumber, controller ? { signal: controller.signal } : {});
      if(controller && controller.signal && controller.signal.aborted){
        return;
      }
      const estimateId = extractEstimateId(estimate);
      const addressResult = extractEstimateAddressPayload(estimate);
      if(addressResult.hasAddress){
        const formatted = addressResult.formatted;
        lastEstimateLookupNumber = estimateNumber;
        lastEstimateAddress = formatted;
        lastEstimateId = estimateId;
        lastEstimateExists = true;
        if(formatted){
          setMapAddressFromEstimate(formatted);
          updateEstimateStatus('Address loaded from Housecall Pro.', 'success');
        }else{
          updateEstimateStatus('Estimate found but no address was provided.', 'warn');
        }
      }else if(estimate){
        const notFound = isEstimateNotFound(estimate);
        if(notFound){
          lastEstimateLookupNumber = estimateNumber;
          lastEstimateAddress = '';
          lastEstimateId = '';
          lastEstimateExists = false;
          updateEstimateStatus('No matching estimate found in Housecall Pro.', 'warn');
        }else{
          lastEstimateLookupNumber = estimateNumber;
          lastEstimateAddress = '';
          lastEstimateId = estimateId;
          lastEstimateExists = true;
          updateEstimateStatus('Estimate found but no address was provided.', 'warn');
        }
      }else{
        lastEstimateLookupNumber = estimateNumber;
        lastEstimateAddress = '';
        lastEstimateId = '';
        lastEstimateExists = false;
        updateEstimateStatus('No matching estimate found in Housecall Pro.', 'warn');
      }
      setGateUnlocked(true);
    }catch(err){
      if(controller && controller.signal && controller.signal.aborted){
        return;
      }
      console.error('Estimate lookup failed', err);
      lastEstimateLookupNumber = '';
      lastEstimateAddress = '';
      lastEstimateId = '';
      lastEstimateExists = false;
      updateEstimateStatus('Unable to load estimate address. Please try again.', 'error');
    }finally{
      if(estimateLookupController === controller){
        estimateLookupController = null;
      }
      if(estimateLookupBtn){
        estimateLookupBtn.disabled = false;
        estimateLookupBtn.textContent = estimateLookupBtnLabel || 'Fetch Estimate Address';
      }
    }
  }

  function runEstimateLookup(){
    if(!estimateNumberInput){
      return;
    }
    const digits = sanitizeEstimateNumber(estimateNumberInput.value || '');
    if(!digits){
      lastEstimateLookupNumber = '';
      lastEstimateAddress = '';
      lastEstimateId = '';
      lastEstimateExists = false;
      updateEstimateStatus('', '');
      return;
    }
    if(digits === lastEstimateLookupNumber){
      if(lastEstimateAddress && mapAddressInput && !mapAddressInput.value.trim()){
        setMapAddressFromEstimate(lastEstimateAddress);
        updateEstimateStatus('Address loaded from Housecall Pro.', 'success');
      }
      return;
    }
    lookupEstimateAddress(digits);
  }

  function createSectionBase(data={}){
    const scope = data.scopeType || 'repair';
    const initialFenceType = data.fenceType || 'Wrought Iron';
    const normalizedType = initialFenceType.toLowerCase();
    const defaultPainting = normalizedType === 'wood'
      ? 'None'
      : ((scope === 'install' || scope === 'replace') ? 'Spot Paint Welds' : 'Paint Section');
    const base = {
      id: uid(),
      collapsed:false,
      fenceType: initialFenceType,
      railsCount:2,
      rails:[
        {size:SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0},
        {size:SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0},
      ],
      puppyPicketSize: SEED.picketSize[0],
      puppyPicketHeight: '',
      puppyPicketReplace: 0,
      postSize: '2x2',
      postReplacements: [],
      postRealignments: [],
      weldRedos: 0,
      gapAdditions: [],
      diagonalBraces: [],
      walkGates: 0,
      walkGatesRealign: 0,
      walkGatesHardware: 0,
      walkGatesRebuild: 0,
      walkLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkRebuildFrame: SEED.railSize[0],
      walkRebuildPicket: SEED.picketSize[0],
      walkRebuildLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkRebuildHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkGatesAdd: 0,
      walkAddType: WALK_GATE_TYPES[0],
      walkAddPostSize: '2x2',
      walkAddFrameSize: SEED.railSize[0],
      walkAddPicketSize: SEED.picketSize[0],
      walkAddLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkAddHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      woodWalkGatesAdd: 0,
      woodWalkAddType: WALK_GATE_TYPES[0],
      woodWalkAddPostType: WOOD_GATE_POST_TYPES[1],
      woodWalkAddFrameSize: WOOD_RAIL_SIZES[1],
      woodWalkAddPicketWidth: WOOD_PICKET_WIDTHS[2],
      driveGateChainReplace: 0,
      driveGateOperatorReplace: 0,
      driveGateOperatorType: DRIVE_GATE_OPERATOR_TYPES[0],
      driveGateOperatorPower: DRIVE_GATE_POWER_TYPES[0],
      driveGateOperatorInstall: 0,
      driveGateOperatorInstallType: DRIVE_GATE_OPERATOR_TYPES[0],
      driveGateOperatorInstallPower: DRIVE_GATE_POWER_TYPES_INSTALL[0],
      driveGateOperatorInstallPlatform: false,
      useExistingPostsForReplacement: 'no',
      postInstallMethod: POST_INSTALL_METHODS[0].value,
      woodInstallPostSpacing: '8',
      woodReplacementPostSpacing: '8',
      scopeType: 'repair',
      postSpacing: '8',
      panelAttachment: 'Welding',
      wroughtCustomStickLength: '12',
      wroughtPanelFabrication: WROUGHT_PANEL_FABRICATION_ON_SITE,
      wroughtPowderCoatPanels: false,
      wroughtPowderCoatPosts: false,
      installFinialStyle: SEED.finialStyles[0],
      finials: [],
      caps: [],
      panels: [],
      puppyInserts: [],
      mapGenerated: false,
      mapSegmentId: '',
      mapGeneratedLabel: '',
      mapMeasuredLength: 0,
      mapLengthOverride: '',
      notes: '',
      painting: defaultPainting,
      paintingApplication: 'By Hand',
      paintingPrepExtra: false,
      paintingCurrentColor: WROUGHT_CURRENT_COLOR_OPTIONS[0],
      paintingTargetColor: WROUGHT_PAINT_COLOR_OPTIONS[0],
      woodHeight: '6ft',
      woodStyle: 'Side by Side',
      woodPicketWidth: '5.5"',
      woodRailSize: '2x4',
      woodPost: 'Round Steel',
      woodType: 'Cedar',
      woodFinish: 'Oil Based Stain',
      woodKickBoardSize: '2x6',
      woodKickBoardStack: '1',
      woodTopCapSize: '2x6',
      woodTrimType: '1x4',
      woodPostRealignments: [],
      woodRepairPicketReplace: 0,
      woodRepairPicketInstall: 0,
      woodRepairRailReplace: 0,
      woodRepairRailInstall: 0,
      woodRepairPostReplace: 0,
      woodRepairPostReplaceTie: SIMPSON_TIE_OPTIONS[0],
      woodRepairPostReplaceCap: '',
      woodRepairPostInstall: 0,
      woodRepairPostInstallMethod: WOOD_POST_INSTALL_METHODS[1].value,
      woodRepairPostInstallTie: SIMPSON_TIE_OPTIONS[0],
      woodRepairPanelReplace: 0,
      woodRepairPanelWidth: 8,
      woodRepairWalkGateCount: 0,
      woodRepairWalkGateHinges: false,
      woodRepairWalkGateLatch: false,
      woodRepairWalkGateWood: false,
      woodRepairGateStrengthen: 0,
      woodRepairGateReplace: 0,
      woodRepairTopCapReplaceLf: 0,
      woodRepairTopCapReplaceSize: '2x6',
      woodRepairTrimReplaceLf: 0,
      woodRepairTrimReplaceSize: '1x4',
      woodRepairKickReplaceLf: 0,
      woodRepairKickReplaceSize: '2x6',
      woodRepairKickReplaceStack: '1',
      woodRepairStain: 'none',
      woodRepairStainBrand: DEFAULT_WOOD_STAIN_BRAND,
      woodAddKickBoard: false,
      woodAddTopCap: false,
      woodAddTrim: false,
      retainingWallLength: 0,
      retainingWallHeight: 0,
    };
    const merged = { ...base, ...data };
    if(!Object.prototype.hasOwnProperty.call(data, 'woodRepairPostReplaceTie')){
      merged.woodRepairPostReplaceTie = defaultTieForWoodPost(merged.woodPost);
    }
    if(!Object.prototype.hasOwnProperty.call(data, 'woodRepairPostInstallTie')){
      merged.woodRepairPostInstallTie = defaultTieForWoodPost(merged.woodPost);
    }
    if(!Object.prototype.hasOwnProperty.call(data, 'woodRepairPostReplaceCap')){
      merged.woodRepairPostReplaceCap = defaultCapForWoodPost(merged.woodPost);
    }
    merged.postInstallMethod = normalizePostInstallMethod(merged.postInstallMethod);
    merged.useExistingPostsForReplacement = normalizeUseExistingPostsForReplacement(merged.useExistingPostsForReplacement);
    merged.woodInstallPostSpacing = normalizeWoodInstallPostSpacing(merged.woodInstallPostSpacing);
    merged.woodReplacementPostSpacing = normalizeWoodReplacementPostSpacing(merged.woodReplacementPostSpacing);
    merged.wroughtCustomStickLength = normalizeWroughtCustomStickLength(merged.wroughtCustomStickLength);
    merged.wroughtPanelFabrication = normalizeWroughtPanelFabrication(merged.wroughtPanelFabrication);
    merged.wroughtPowderCoatPanels = false;
    merged.wroughtPowderCoatPosts = false;
    merged.woodRepairStainBrand = normalizeWoodStainBrand(merged.woodRepairStainBrand);
    return merged;
  }

  function sanitizeWroughtFieldsForFenceType(section){
    if(!section) return section;
    if(String(section.fenceType || '').toLowerCase() !== 'wood'){
      return section;
    }
    return {
      ...section,
      wiPickets: 0,
      weldRedos: 0,
      walkGates: 0,
      walkGatesRealign: 0,
      walkGatesHardware: 0,
      walkGatesRebuild: 0,
      walkLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkRebuildFrame: SEED.railSize[0],
      walkRebuildPicket: SEED.picketSize[0],
      walkRebuildLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkRebuildHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      walkGatesAdd: 0,
      walkAddType: WALK_GATE_TYPES[0],
      walkAddPostSize: section.postSize || '2x2',
      walkAddFrameSize: SEED.railSize[0],
      walkAddPicketSize: SEED.picketSize[0],
      walkAddLatch: (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch',
      walkAddHinges: (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges',
      driveGateChainReplace: 0,
      driveGateOperatorReplace: 0,
      driveGateOperatorType: DRIVE_GATE_OPERATOR_TYPES[0],
      driveGateOperatorPower: DRIVE_GATE_POWER_TYPES[0],
      driveGateOperatorInstall: 0,
      driveGateOperatorInstallType: DRIVE_GATE_OPERATOR_TYPES[0],
      driveGateOperatorInstallPower: DRIVE_GATE_POWER_TYPES_INSTALL[0],
      driveGateOperatorInstallPlatform: false,
      postReplacements: [],
      postRealignments: [],
      finials: [],
      puppyInserts: [],
      caps: [],
      panels: [],
      gapAdditions: [],
      diagonalBraces: []
    };
  }

  function isSectionPristine(section){
    if(!section) return false;
    const clean = v => String(v||'').trim();
    return !section.mapGenerated &&
      !clean(section.label) &&
      Number(section.length||0) === 0 &&
      Number(section.hardscape||0) === 0 &&
      Number(section.trim||0) === 0 &&
      Number(section.digOut||0) === 0 &&
      Number(section.puppyPicketReplace||0) === 0 &&
      Number(section.walkGates||0) === 0 &&
      Number(section.driveGateChainReplace||0) === 0 &&
      Number(section.driveGateOperatorReplace||0) === 0 &&
      Number(section.driveGateOperatorInstall||0) === 0 &&
      clean(section.notes) === '' &&
      (!section.postReplacements || section.postReplacements.length === 0) &&
      (!section.postRealignments || section.postRealignments.length === 0) &&
      (!section.gapAdditions || section.gapAdditions.length === 0) &&
      (!section.diagonalBraces || section.diagonalBraces.length === 0) &&
      (!section.panels || section.panels.length === 0) &&
      (!section.puppyInserts || section.puppyInserts.length === 0) &&
      (!section.finials || section.finials.length === 0) &&
      (!section.caps || section.caps.length === 0);
  }

  function sectionBasicsComplete(card){
    return true;
  }

  function updateSectionBasicsGate(card){
    if(!card) return;
    card.classList.remove('sp-section-locked');
  }

  function updateMapControlsUI(){
    const clearBtn = document.getElementById('sp-map-clear');
    if(clearBtn){
      const hasLinkedSections = state.sections.some(sec=>sec.mapGenerated);
      clearBtn.disabled = mapState.polylines.length === 0 && !hasLinkedSections;
    }
  }

  function setMapCollapsed(collapsed){
    if(!mapCardEl) return;
    mapCardEl.classList.toggle('is-collapsed', collapsed);
    if(mapToggleBtn){
      mapToggleBtn.textContent = collapsed ? 'Expand Map' : 'Collapse Map';
      mapToggleBtn.setAttribute('aria-expanded', (!collapsed).toString());
    }
    if(!collapsed && mapState.map && typeof google !== 'undefined' && google.maps && google.maps.event){
      google.maps.event.trigger(mapState.map, 'resize');
    }
  }

  function clearMapDrawing(options={}){
    mapState.polylines.forEach(poly=>{
      clearPolylineLabels(poly);
      clearPolylineSegmentStrokes(poly);
      poly.setMap(null);
    });
    mapState.polylines = [];
    updateMapControlsUI();
    if(!options.skipSections){
      applySegmentsToSections([]);
    }
  }

  function updateMapAddressMarker(location){
    if(typeof google === 'undefined' || !google.maps || !mapState.map){
      return;
    }
    mapState.addressLocation = location || null;
    if(!location){
      if(mapState.marker){
        mapState.marker.setMap(null);
      }
      return;
    }
    if(!mapState.marker){
      mapState.marker = new google.maps.Marker({
        map: mapState.map,
        clickable: false,
      });
    }
    mapState.marker.setMap(mapState.map);
    mapState.marker.setPosition(location);
  }

  function scheduleMapSectionsUpdate(){
    if(mapUpdateScheduled) return;
    mapUpdateScheduled = true;
    const run = ()=>{
      mapUpdateScheduled = false;
      refreshSectionsFromMap();
    };
    if(typeof requestAnimationFrame === 'function'){
      requestAnimationFrame(run);
    }else{
      setTimeout(run, 80);
    }
  }

  function mapPolylineBaseOptions(strokeColor = MAP_BASE_POLYLINE_COLOR){
    return {
      editable: true,
      draggable: true,
      strokeColor,
      strokeOpacity: MAP_BASE_POLYLINE_OPACITY,
      strokeWeight: MAP_BASE_POLYLINE_WEIGHT,
      zIndex: 100
    };
  }

  function mapPolylineDrawOptions(strokeColor){
    return {
      editable: true,
      draggable: true,
      strokeColor,
      strokeOpacity: 1,
      strokeWeight: 3,
      zIndex: 100
    };
  }

  function mapStrokeColorForFenceType(fenceType){
    return String(fenceType || '').toLowerCase() === 'wood'
      ? MAP_POLYLINE_COLORS.wood
      : MAP_POLYLINE_COLORS.wroughtIron;
  }

  function clearPolylineSegmentStrokes(polyline){
    if(!polyline || !Array.isArray(polyline.__spSegmentStrokes)) return;
    polyline.__spSegmentStrokes.forEach(segmentStroke=>{
      if(segmentStroke && typeof segmentStroke.setMap === 'function'){
        segmentStroke.setMap(null);
      }
    });
    polyline.__spSegmentStrokes = [];
  }

  function mapStrokeColorForSegmentId(segmentId){
    const linkedSection = state.sections.find(sec=>{
      return sec && sec.mapGenerated && sec.mapSegmentId === segmentId;
    });
    return mapStrokeColorForFenceType(linkedSection && linkedSection.fenceType);
  }

  function refreshPolylineSegmentStrokes(polyline){
    if(!polyline || typeof polyline.getPath !== 'function'){
      return;
    }
    if(!mapState.map || typeof google === 'undefined' || !google.maps || typeof google.maps.Polyline !== 'function'){
      return;
    }
    clearPolylineSegmentStrokes(polyline);
    const path = polyline.getPath();
    if(!path || typeof path.getLength !== 'function') return;
    const len = path.getLength();
    if(len < 2) return;
    const strokes = [];
    for(let i=0; i<len-1; i++){
      const start = path.getAt(i);
      const end = path.getAt(i+1);
      if(!start || !end) continue;
      const segmentId = `${polyline.__spPolylineId}:${i}`;
      const segmentStroke = new google.maps.Polyline({
        map: mapState.map,
        path: [start, end],
        clickable: false,
        strokeColor: mapStrokeColorForSegmentId(segmentId),
        strokeOpacity: 1,
        strokeWeight: MAP_SEGMENT_STROKE_WEIGHT,
        zIndex: 120
      });
      strokes.push(segmentStroke);
    }
    polyline.__spSegmentStrokes = strokes;
  }

  function refreshMapPolylineColors(){
    if(!Array.isArray(mapState.polylines) || !mapState.polylines.length){
      return;
    }
    mapState.polylines.forEach(polyline=>{
      if(!polyline){
        return;
      }
      if(typeof polyline.setOptions === 'function'){
        polyline.setOptions(mapPolylineBaseOptions());
      }
      refreshPolylineSegmentStrokes(polyline);
    });
  }

  function clearPolylineLabels(polyline){
    if(!polyline || !Array.isArray(polyline.__spSegmentLabels)) return;
    polyline.__spSegmentLabels.forEach(marker=>{
      if(marker && typeof marker.setMap === 'function'){
        marker.setMap(null);
      }
    });
    polyline.__spSegmentLabels = [];
  }

  function segmentMidpoint(start, end){
    if(typeof google !== 'undefined'
      && google.maps
      && google.maps.geometry
      && google.maps.geometry.spherical
      && typeof google.maps.geometry.spherical.interpolate === 'function'){
      return google.maps.geometry.spherical.interpolate(start, end, 0.5);
    }
    const lat = (start.lat() + end.lat()) / 2;
    const lng = (start.lng() + end.lng()) / 2;
    return new google.maps.LatLng(lat, lng);
  }

  function createSegmentLabelOverlay(position, text){
    if(!mapState.map || typeof google === 'undefined' || !google.maps || typeof google.maps.OverlayView !== 'function'){
      return null;
    }

    const overlay = new google.maps.OverlayView();
    overlay.__spPosition = position;
    overlay.__spText = String(text || '').trim();
    overlay.__spDiv = null;

    overlay.onAdd = function(){
      const div = document.createElement('div');
      div.className = 'sp-map-segment-label';
      div.textContent = this.__spText;
      this.__spDiv = div;
      const panes = this.getPanes();
      if(panes && panes.floatPane){
        panes.floatPane.appendChild(div);
      }
    };

    overlay.draw = function(){
      if(!this.__spDiv || !this.__spPosition){
        return;
      }
      const projection = this.getProjection();
      if(!projection){
        return;
      }
      const point = projection.fromLatLngToDivPixel(this.__spPosition);
      if(!point){
        return;
      }
      this.__spDiv.style.left = `${point.x}px`;
      this.__spDiv.style.top = `${point.y}px`;
    };

    overlay.onRemove = function(){
      if(this.__spDiv && this.__spDiv.parentNode){
        this.__spDiv.parentNode.removeChild(this.__spDiv);
      }
      this.__spDiv = null;
    };

    overlay.setMap(mapState.map);
    return overlay;
  }

  function addSegmentLabel(polyline, position, text){
    if(!polyline || !position) return;
    const marker = createSegmentLabelOverlay(position, text);
    if(!marker) return;
    if(!Array.isArray(polyline.__spSegmentLabels)){
      polyline.__spSegmentLabels = [];
    }
    polyline.__spSegmentLabels.push(marker);
  }

  function refreshSectionsFromMap(){
    if(!mapState.polylines.length){
      updateMapControlsUI();
      applySegmentsToSections([]);
      return;
    }
    if(typeof google === 'undefined' || !google.maps || !google.maps.geometry){
      return;
    }
    syncStateFromDOM();
    const mapSectionsBySegmentId = new Map();
    state.sections.forEach(sec=>{
      if(sec && sec.mapGenerated && sec.mapSegmentId){
        mapSectionsBySegmentId.set(sec.mapSegmentId, sec);
      }
    });
    mapState.polylines = mapState.polylines.filter(poly=>!!poly.getMap());
    updateMapControlsUI();
    const segments = [];
    mapState.polylines.forEach((polyline, runIndex)=>{
      clearPolylineLabels(polyline);
      const path = polyline.getPath();
      if(!path) return;
      const length = path.getLength();
      for(let i=0;i<length-1;i++){
        const start = path.getAt(i);
        const end = path.getAt(i+1);
        if(!start || !end) continue;
        const meters = google.maps.geometry.spherical.computeDistanceBetween(start, end);
        const feet = meters * 3.28084;
        if(!isFinite(feet) || feet <= 0.1) continue;
        const segId = `${polyline.__spPolylineId}:${i}`;
        const measuredFeet = Math.round(feet);
        const linkedSection = mapSectionsBySegmentId.get(segId);
        const overrideFeet = parsePositiveInt(linkedSection && linkedSection.mapLengthOverride);
        const displayFeet = overrideFeet || measuredFeet;
        const labelText = `${displayFeet} lf`;
        const midpoint = segmentMidpoint(start, end);
        if(midpoint){
          addSegmentLabel(polyline, midpoint, labelText);
        }
        segments.push({
          id: segId,
          label: `Fence ${runIndex+1} - Section ${i+1}`,
          lengthFeet: feet,
          measuredFeet,
          displayFeet
        });
      }
    });
    applySegmentsToSections(segments);
    refreshMapPolylineColors();
  }

  function applySegmentsToSections(segments){
    syncStateFromDOM();
    let needsRender = false;
    let manualSections = [];
    const existingMapSections = new Map();
    state.sections.forEach(sec=>{
      if(sec.mapGenerated){
        existingMapSections.set(sec.mapSegmentId, sec);
      }else{
        manualSections.push(sec);
      }
    });

    if(segments.length>0 && manualSections.length===1 && isSectionPristine(manualSections[0])){
      manualSections = [];
      needsRender = true;
    }

    const updatedMapSections = [];
    segments.forEach(segment=>{
      const measuredLengthFeet = parsePositiveInt(segment.measuredFeet || Math.round(segment.lengthFeet));
      if(!measuredLengthFeet) return;
      const existing = existingMapSections.get(segment.id);
      if(existing){
        const prevLength = parsePositiveInt(existing.length);
        const prevMeasuredLength = parsePositiveInt(existing.mapMeasuredLength);
        const overrideLength = parsePositiveInt(existing.mapLengthOverride);
        const nextLength = overrideLength || measuredLengthFeet;
        const prevLabel = existing.label||'';
        const prevGeneratedLabel = existing.mapGeneratedLabel||'';
        if(prevLength !== nextLength) needsRender = true;
        if(prevMeasuredLength !== measuredLengthFeet) needsRender = true;
        existing.length = nextLength;
        existing.mapGenerated = true;
        existing.mapSegmentId = segment.id;
        existing.mapGeneratedLabel = segment.label;
        existing.mapMeasuredLength = measuredLengthFeet;
        existing.mapLengthOverride = overrideLength || '';
        if(!prevLabel.trim() || prevLabel === prevGeneratedLabel || prevLabel.startsWith('Map Run ')){
          if(prevLabel !== segment.label) needsRender = true;
          existing.label = segment.label;
        }
        updatedMapSections.push(existing);
        existingMapSections.delete(segment.id);
      }else{
        const displayLength = parsePositiveInt(segment.displayFeet) || measuredLengthFeet;
        const newSection = createSectionBase({
          label: segment.label,
          length: displayLength,
          scopeType: 'repair',
          mapGenerated: true,
          mapSegmentId: segment.id,
          mapGeneratedLabel: segment.label,
          mapMeasuredLength: measuredLengthFeet,
          mapLengthOverride: '',
        });
        updatedMapSections.push(newSection);
        needsRender = true;
      }
    });

    if(existingMapSections.size>0){
      needsRender = true;
    }

    const nextSections = manualSections.concat(updatedMapSections);
    if(needsRender || nextSections.length !== state.sections.length){
      state.sections = nextSections;
      render();
      persist();
    }
  }

  function attachMapPolyline(polyline){
    polyline.__spPolylineId = polyline.__spPolylineId || `poly-${mapState.nextPolylineId++}`;
    if(polyline && typeof polyline.setOptions === 'function'){
      polyline.setOptions(mapPolylineBaseOptions());
    }
    mapState.polylines.push(polyline);
    updateMapControlsUI();
    const path = polyline.getPath();
    ['insert_at','set_at','remove_at'].forEach(evt=>{
      google.maps.event.addListener(path, evt, scheduleMapSectionsUpdate);
    });
    google.maps.event.addListener(polyline, 'rightclick', evt=>{
      if(typeof evt.vertex === 'number'){
        path.removeAt(evt.vertex);
        return;
      }
      if(confirm('Remove this fence run?')){
        clearPolylineLabels(polyline);
        clearPolylineSegmentStrokes(polyline);
        polyline.setMap(null);
        mapState.polylines = mapState.polylines.filter(p=>p!==polyline);
        scheduleMapSectionsUpdate();
      }
    });
    scheduleMapSectionsUpdate();
  }

  function serializePolylinePath(polyline){
    if(!polyline || typeof polyline.getPath !== 'function'){
      return [];
    }
    const path = polyline.getPath();
    if(!path || typeof path.getLength !== 'function') return [];
    const coords = [];
    const len = path.getLength();
    for(let i=0;i<len;i++){
      const pt = path.getAt(i);
      if(pt && typeof pt.lat === 'function' && typeof pt.lng === 'function'){
        coords.push({ lat: pt.lat(), lng: pt.lng() });
      }
    }
    return coords;
  }

  function serializeMapDrawing(){
    const polylines = [];
    if(mapState.polylines && mapState.polylines.length && typeof google !== 'undefined' && google.maps){
      mapState.polylines.forEach(poly=>{
        const coords = serializePolylinePath(poly);
        if(coords.length >= 2){
          polylines.push({ id: poly.__spPolylineId || '', path: coords });
        }
      });
    }
    const address = mapAddressInput ? (mapAddressInput.value || '').trim() : '';
    return {
      address,
      polylines,
      nextPolylineId: mapState.nextPolylineId || 1,
    };
  }

  function applyPendingMapRestore(){
    if(!pendingMapRestore || !mapState.map || typeof google === 'undefined' || !google.maps || !google.maps.Polyline){
      return;
    }

    const restore = pendingMapRestore;
    pendingMapRestore = null;
    clearMapDrawing({ skipSections: true });

    const baseOpts = mapPolylineBaseOptions();
    let maxId = restore.nextPolylineId || mapState.nextPolylineId || 1;
    (restore.polylines || []).forEach(data=>{
      if(!data || !Array.isArray(data.path) || data.path.length < 2) return;
      const path = data.path.map(pt => ({ lat: pt.lat, lng: pt.lng })).filter(pt=>isFinite(pt.lat) && isFinite(pt.lng));
      if(path.length < 2) return;
      const polyline = new google.maps.Polyline({ ...baseOpts, map: mapState.map, path });
      polyline.__spPolylineId = data.id || `poly-${mapState.nextPolylineId++}`;
      const numericId = parseInt(String(polyline.__spPolylineId).replace(/[^0-9]/g,''),10);
      if(isFinite(numericId)){
        maxId = Math.max(maxId, numericId + 1);
      }
      attachMapPolyline(polyline);
    });
    mapState.nextPolylineId = Math.max(mapState.nextPolylineId || 1, maxId);
    scheduleMapSectionsUpdate();
  }

  function restoreMapFromSnapshot(mapData){
    clearMapDrawing({ skipSections: true });
    if(!mapData || !mapData.polylines || !mapData.polylines.length){
      pendingMapRestore = null;
      updateMapControlsUI();
      return;
    }
    pendingMapRestore = mapData;
    applyPendingMapRestore();
  }

  function enforceOverheadMapView(){
    if(!mapState.map){
      return;
    }
    if(typeof mapState.map.getTilt === 'function' && typeof mapState.map.setTilt === 'function'){
      const tilt = mapState.map.getTilt();
      if(tilt && tilt !== 0){
        mapState.map.setTilt(0);
      }
    }
    if(typeof mapState.map.getHeading === 'function' && typeof mapState.map.setHeading === 'function'){
      const heading = mapState.map.getHeading();
      if(heading && heading !== 0){
        mapState.map.setHeading(0);
      }
    }
  }

  function initializeMap(){
    if(mapState.map) return;
    if(typeof google === 'undefined' || !google.maps || !google.maps.drawing) return;
    const mapEl = document.getElementById('sp-map');
    if(!mapEl) return;
    mapState.map = new google.maps.Map(mapEl, {
      zoom: 11,
      mapTypeId: 'hybrid',
      center: { lat: 32.922, lng: -96.549 },
      zoomControl: true,
      streetViewControl: false,
      mapTypeControl: false,
      rotateControl: false,
      tilt: 0,
      heading: 0,
    });
    enforceOverheadMapView();
    google.maps.event.addListenerOnce(mapState.map, 'idle', enforceOverheadMapView);
    google.maps.event.addListener(mapState.map, 'tilt_changed', enforceOverheadMapView);
    google.maps.event.addListener(mapState.map, 'heading_changed', enforceOverheadMapView);
    google.maps.event.addListener(mapState.map, 'maptypeid_changed', enforceOverheadMapView);
    mapState.maxZoomService = (typeof google.maps.MaxZoomService === 'function') ? new google.maps.MaxZoomService() : null;
    mapState.drawingManager = new google.maps.drawing.DrawingManager({
      drawingMode: null,
      drawingControl: true,
      drawingControlOptions: {
        position: google.maps.ControlPosition.TOP_CENTER,
        drawingModes: [google.maps.drawing.OverlayType.POLYLINE]
      },
      polylineOptions: {
        ...mapPolylineDrawOptions(MAP_POLYLINE_COLORS.wroughtIron)
      }
    });
    mapState.drawingManager.setMap(mapState.map);
    google.maps.event.addListener(mapState.drawingManager, 'polylinecomplete', polyline=>{
      attachMapPolyline(polyline);
      mapState.drawingManager.setDrawingMode(null);
    });

    mapState.geocoder = new google.maps.Geocoder();
    if(mapState.pendingAddress){
      focusMapOnAddress(mapState.pendingAddress);
    }
    if(mapAddressInput){
      mapState.autocomplete = new google.maps.places.Autocomplete(mapAddressInput);
      mapState.autocomplete.addListener('place_changed', ()=>{
        const place = mapState.autocomplete.getPlace();
        if(place && place.geometry){
          const viewport = place.geometry.viewport;
          let loc = place.geometry.location;
          if(!loc && viewport && typeof viewport.getCenter === 'function'){
            loc = viewport.getCenter();
          }
          if(viewport){
            mapState.map.fitBounds(viewport);
          }
          if(loc){
            mapState.map.setCenter(loc);
            zoomMapToMax(loc);
            updateMapAddressMarker(loc);
          }
          mapState.pendingAddress = mapAddressInput.value.trim();
          persist();
        }
      });
      mapAddressInput.addEventListener('keydown', evt=>{
        if(evt.key === 'Enter'){
          evt.preventDefault();
          const value = mapAddressInput.value.trim();
          if(!value || !mapState.geocoder) return;
          mapState.geocoder.geocode({ address: value }, (results, status)=>{
            let hasLocation = false;
            if(status === 'OK' && results && results[0]){
              const geometry = results[0].geometry || {};
              const viewport = geometry.viewport;
              let loc = geometry.location;
              if(!loc && viewport && typeof viewport.getCenter === 'function'){
                loc = viewport.getCenter();
              }
              if(loc){
                mapState.map.setCenter(loc);
              }
              if(viewport){
                mapState.map.fitBounds(viewport);
              }
              if(loc){
                zoomMapToMax(loc);
                updateMapAddressMarker(loc);
                hasLocation = true;
              }else if(viewport && typeof viewport.getCenter === 'function'){
                const center = viewport.getCenter();
                if(center){
                  zoomMapToMax(center);
                  updateMapAddressMarker(center);
                  hasLocation = true;
                }
              }
            }
            mapState.pendingAddress = value;
            if(!hasLocation){
              mapState.addressLocation = null;
            }
            persist();
          });
        }
      });
      mapAddressInput.addEventListener('input', ()=>{
        if(!mapAddressInput.value.trim()){
          updateMapAddressMarker(null);
          mapState.pendingAddress = '';
          persist();
        }
      });
    }
    applyPendingMapRestore();
    updateMapControlsUI();
  }

  function escapeHtml(t){ return String(t).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function escapeAttr(t){ return escapeHtml(t).replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

  function createSelect(options){
    return options.map(v=>`<option value="${escapeAttr(v)}">${escapeHtml(v)}</option>`).join('');
  }

  function numberControl(name, placeholder='', min=0){
    return (
      '<div class="sp-number" data-field="'+name+'">'+
        '<button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>'+
        '<input type="number" inputmode="numeric" step="1" min="'+min+'" value="" placeholder="'+placeholder+'" />'+
        '<button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>'+
      '</div>'
    );
  }

  function sectionTemplate(id, index){
    return `
    <div class="sp-card" data-id="${id}">
      <div class="sp-card-header">
        <div class="sp-card-title">Section ${index+1}</div>
        <div class="sp-row">
          <button class="sp-btn ghost sp-toggle" type="button" aria-expanded="true">Collapse</button>
          <button class="sp-btn ghost sp-apply-basics-all" type="button">Apply Basics to All</button>
          <button class="sp-btn ghost sp-dup" type="button">Duplicate</button>
          <button class="sp-btn danger sp-del" type="button">Remove</button>
        </div>
      </div>
      <div class="sp-grid">
        <div class="sp-scope-group col-12 is-basics">
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Basics</div>
            <div>
              <div class="sp-scope-title">Section Layout</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-field col-6">
              <label class="sp-label">Section Label (e.g., Front Right, Right Side, Back Right, etc)</label>
              <input class="sp-input" data-field="label" placeholder="Enter a label" />
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Fence Type</label>
              <select class="sp-select" data-field="fenceType">
                <option value="Wrought Iron">Wrought Iron</option>
                <option value="Wood">Wood</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Section Scope</label>
              <select class="sp-select" data-field="scopeType">
                <option value="repair">Repair Existing</option>
                <option value="replace">Replace Section</option>
                <option value="install">Install New Section</option>
              </select>
            </div>
            <div class="sp-field col-3" data-replace-only style="display:none">
              <label class="sp-label">Use Existing Posts</label>
              <select class="sp-select" data-field="useExistingPostsForReplacement">
                <option value="no">No</option>
                <option value="yes">Yes</option>
              </select>
              <div class="sp-hint">When yes, this section excludes new post labor/materials.</div>
            </div>
            <div class="sp-field col-2" data-replace-only data-wood-only data-existing-post-spacing-wrap style="display:none">
              <label class="sp-label">Existing Post Spacing</label>
              <select class="sp-select" data-field="woodReplacementPostSpacing">
                <option value="8">8ft</option>
                <option value="6">6ft</option>
              </select>
              <div class="sp-hint">For wood replacements using existing posts.</div>
            </div>
            <div class="sp-field col-3" data-install-only data-post-install-method-wrap style="display:none">
              <label class="sp-label">Post Setting Method</label>
              <select class="sp-select" data-field="postInstallMethod">${POST_INSTALL_METHODS.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}</select>
              <div class="sp-hint">Anchored posts use 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Section Length (ft)</label>
              ${numberControl('length','e.g., 48')}
            </div>
          </div>
        </div>
        <div class="sp-scope-group col-12 is-wood" data-section-detail data-wood-only>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Wood</div>
            <div>
              <div class="sp-scope-title">Wood Build & Finish</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-field col-2">
              <label class="sp-label">Fence Height</label>
              <select class="sp-select" data-field="woodHeight">
                <option value="6ft">6ft</option>
                <option value="8ft">8ft</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Construction</label>
              <select class="sp-select" data-field="woodStyle">
                <option value="Board on Board">Board on Board</option>
                <option value="Side by Side">Side by Side</option>
                <option value="Shadowbox">Shadowbox</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Picket Width</label>
              <select class="sp-select" data-field="woodPicketWidth">${createSelect(WOOD_PICKET_WIDTHS)}</select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Rail Size</label>
              <select class="sp-select" data-field="woodRailSize">${createSelect(WOOD_RAIL_SIZES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Posts</label>
              <select class="sp-select" data-field="woodPost">
                <option value="Wood 4x4">Wood 4x4</option>
                <option value="Round Steel">Round Steel</option>
                <option value="Postmaster">Postmaster</option>
              </select>
            </div>
            <div class="sp-field col-2" data-install-only data-wood-install-post-spacing-wrap style="display:none">
              <label class="sp-label">Post Spacing (ft)</label>
              <select class="sp-select" data-field="woodInstallPostSpacing">
                <option value="8">8ft</option>
                <option value="6">6ft</option>
              </select>
              <div class="sp-hint">Used when setting new wood posts for install/replace sections.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Wood Type</label>
              <select class="sp-select" data-field="woodType">
                <option value="Cedar">Cedar</option>
                <option value="Pressure Treated">Pressure Treated</option>
              </select>
            </div>
            <div class="sp-field col-2">
              <label class="sp-label">Finish Type</label>
              <select class="sp-select" data-field="woodFinish">
                <option value="Oil Based Stain">Oil Based Stain</option>
                <option value="Water Based Stain">Water Based Stain</option>
                <option value="Painted">Painted</option>
                <option value="Unfinished">Unfinished</option>
              </select>
            </div>
            <div class="sp-field col-12">
              <label class="sp-label">Add-ons</label>
              <div class="sp-row">
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddKickBoard" /> Kick Board</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddTopCap" /> Top Cap</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodAddTrim" /> Trim</label>
              </div>
            </div>

            <div class="sp-grid col-12" data-wood-only data-kickboard-settings style="display:none">
              <div class="sp-field col-2">
                <label class="sp-label">Kick Board Size</label>
                <select class="sp-select" data-field="woodKickBoardSize">
                  <option value="2x6">2x6</option>
                  <option value="2x8">2x8</option>
                  <option value="2x10">2x10</option>
                  <option value="2x12">2x12</option>
                </select>
              </div>
              <div class="sp-field col-2">
                <label class="sp-label">Kick Board Stack Height</label>
                <select class="sp-select" data-field="woodKickBoardStack">
                  <option value="1">1 Board</option>
                  <option value="2">2 Board Stack</option>
                  <option value="3">3 Board Stack</option>
                  <option value="4">4 Board Stack</option>
                </select>
              </div>
            </div>

            <div class="sp-grid col-12" data-wood-only data-topcap-settings style="display:none">
              <div class="sp-field col-2">
                <label class="sp-label">Top Cap Size</label>
                <select class="sp-select" data-field="woodTopCapSize">
                  <option value="2x6">2x6</option>
                  <option value="2x8">2x8</option>
                  <option value="2x10">2x10</option>
                </select>
              </div>
            </div>

            <div class="sp-grid col-12" data-wood-only data-trim-settings style="display:none">
              <div class="sp-field col-3">
                <label class="sp-label">Trim Type</label>
                <select class="sp-select" data-field="woodTrimType">${createSelect(WOOD_TRIM_TYPES)}</select>
              </div>
            </div>
          </div>
        </div>

        <div class="sp-scope-group col-12 is-repair" data-section-detail data-wood-only data-repair-only>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Wood Repairs</div>
            <div>
              <div class="sp-scope-title">Touch-ups, replacements, and rebuilds</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Picket Replacement</label>
              ${numberControl('woodRepairPicketReplace','0')}
              <div class="sp-hint">Remove damaged pickets and install new ones.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Picket Installation</label>
              ${numberControl('woodRepairPicketInstall','0')}
              <div class="sp-hint">Install missing pickets to close gaps.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Rail Replacement</label>
              ${numberControl('woodRepairRailReplace','0')}
              <div class="sp-hint">Replace broken rails (${WOOD_RAIL_SIZES.join(' / ')}).</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Rail Installation</label>
              ${numberControl('woodRepairRailInstall','0')}
              <div class="sp-hint">Add rails where missing (${WOOD_RAIL_SIZES.join(' / ')}).</div>
            </div>

            <div class="sp-field col-3">
              <label class="sp-label">Post Replacement</label>
              ${numberControl('woodRepairPostReplace','0')}
              <div class="sp-row">
                <select class="sp-select" data-field="woodRepairPostReplaceTie">${createSelect(SIMPSON_TIE_OPTIONS)}</select>
                <select class="sp-select" data-field="woodRepairPostReplaceCap">
                  <option value="">No cap</option>
                  ${createSelect(WOOD_POST_CAP_TYPES)}
                </select>
              </div>
            </div>
            <div class="sp-field col-12">
              <label class="sp-label">Post Realignments</label>
              <div data-wood-post-realign></div>
              <div class="sp-row" style="margin-top:6px">
                <button class="sp-btn ghost" type="button" data-wood-post-realign-add>+ Add Post Realignment</button>
                <span class="sp-hint">Add leaning posts and choose the realignment method.</span>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Post Installation</label>
              ${numberControl('woodRepairPostInstall','0')}
              <div class="sp-row">
                <select class="sp-select" data-field="woodRepairPostInstallMethod">${WOOD_POST_INSTALL_METHODS.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}</select>
                <select class="sp-select" data-field="woodRepairPostInstallTie">${createSelect(SIMPSON_TIE_OPTIONS)}</select>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Panel Replacement</label>
              ${numberControl('woodRepairPanelReplace','0')}
              <input class="sp-input" data-field="woodRepairPanelWidth" type="number" min="1" step="0.1" placeholder="Panel width (ft)" />
              <div class="sp-hint">Most panels are 8 ft wide.</div>
            </div>

            <div class="sp-field col-3">
              <label class="sp-label">Walk Gate Repair</label>
              ${numberControl('woodRepairWalkGateCount','0')}
              <div class="sp-row" style="gap:10px; margin-top:6px">
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateHinges" /> Replace hinges</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateLatch" /> Replace latch</label>
                <label class="sp-row" style="gap:6px"><input type="checkbox" data-field="woodRepairWalkGateWood" /> Replace wood</label>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Walk Gate Strengthen</label>
              ${numberControl('woodRepairGateStrengthen','0')}
              <div class="sp-hint">Add framing (2x4) to beef up the gate.</div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Walk Gate Replace</label>
              ${numberControl('woodRepairGateReplace','0')}
              <div class="sp-hint">Remove and rebuild with new hardware.</div>
            </div>

            <div class="sp-field col-3">
              <label class="sp-label">Top Cap Replacement (lf)</label>
              ${numberControl('woodRepairTopCapReplaceLf','0')}
              <select class="sp-select" data-field="woodRepairTopCapReplaceSize">
                <option value="2x6">2x6</option>
                <option value="2x8">2x8</option>
                <option value="2x10">2x10</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Trim Replacement (lf)</label>
              ${numberControl('woodRepairTrimReplaceLf','0')}
              <select class="sp-select" data-field="woodRepairTrimReplaceSize">${createSelect(WOOD_TRIM_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Kick Board Replacement (lf)</label>
              ${numberControl('woodRepairKickReplaceLf','0')}
              <div class="sp-row">
                <select class="sp-select" data-field="woodRepairKickReplaceSize">
                  <option value="2x6">2x6</option>
                  <option value="2x8">2x8</option>
                  <option value="2x10">2x10</option>
                  <option value="2x12">2x12</option>
                </select>
                <select class="sp-select" data-field="woodRepairKickReplaceStack">
                  <option value="1">1 Board</option>
                  <option value="2">2 Board Stack</option>
                  <option value="3">3 Board Stack</option>
                  <option value="4">4 Board Stack</option>
                </select>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Staining</label>
              <select class="sp-select" data-field="woodRepairStain">
                <option value="none">No staining</option>
                <option value="outside">Stain outside</option>
                <option value="inside">Stain inside</option>
                <option value="both">Stain both sides</option>
                <option value="wash-outside">Wash &amp; Stain outside</option>
                <option value="wash-inside">Wash &amp; Stain inside</option>
                <option value="wash-both">Wash &amp; Stain both sides</option>
                <option value="wash-hail-outside">Wash Hail &amp; Stain outside</option>
                <option value="wash-hail-inside">Wash Hail &amp; Stain inside</option>
                <option value="wash-hail-both">Wash Hail &amp; Stain both sides</option>
              </select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Stain Brand</label>
              <select class="sp-select" data-field="woodRepairStainBrand">${createSelect(WOOD_STAIN_BRANDS)}</select>
            </div>
          </div>
        </div>

        <div class="sp-scope-group col-12" data-section-detail data-install-only data-retaining-wall-group style="display:none">
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Retaining Wall</div>
            <div>
              <div class="sp-scope-title">Wall length & height for fence install</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
            <div class="sp-grid col-12" data-retaining-wall style="display:none">
              <div class="sp-field col-3">
                <label class="sp-label">Retaining Wall Length (ft)</label>
                ${numberControl('retainingWallLength','0')}
              </div>
              <div class="sp-field col-3">
                <label class="sp-label">Retaining Wall Height (ft)</label>
                <input class="sp-input" data-field="retainingWallHeight" type="number" inputmode="decimal" step="0.1" min="0" placeholder="e.g., 2.5" />
                <div class="sp-hint">In-House 4 pours the wall only at $35/sq ft ($1,500 min) including wall materials & labor; Jesus' crew installs the fence. Posts in the wall are set during the pour (no extra concrete bags).</div>
              </div>
            </div>
          </div>
        </div>

        <div class="sp-scope-group col-12 is-style" data-section-detail data-style-group>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Style, Finish & Patches</div>
            <div>
              <div class="sp-scope-title">Fence style, layout & finishing touches</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
        <div class="sp-grid col-12" data-wrought-only>
          <div class="sp-field col-2">
            <label class="sp-label">Style</label>
            <select class="sp-select" data-field="style">${createSelect(SEED.style)}</select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Height</label>
            <select class="sp-select" data-field="height">${createSelect(SEED.height)}</select>
          </div>
          <div class="sp-field col-2">
            <label class="sp-label">Post Size</label>
            <select class="sp-select" data-field="postSize">${createSelect(SEED.postSize)}</select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Post Spacing (ft)</label>
            <select class="sp-select" data-field="postSpacing">
              <option value="4">4 ft</option>
              <option value="5">5 ft</option>
              <option value="6">6 ft</option>
              <option value="8">8 ft</option>
              <option value="10">10 ft</option>
              <option value="12">12 ft</option>
            </select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Panel Attachment</label>
            <select class="sp-select" data-field="panelAttachment">
              <option value="Welding">Welding</option>
              <option value="Brackets">Brackets</option>
            </select>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Custom Stick Length</label>
            <select class="sp-select" data-field="wroughtCustomStickLength">
              <option value="12">12 ft</option>
              <option value="24">24 ft</option>
            </select>
            <div class="sp-hint">Used only for on-site custom panel builds (not prefab or TMI-ordered panels).</div>
          </div>
          <div class="sp-field col-2" data-install-only>
            <label class="sp-label">Panel Fabrication</label>
            <select class="sp-select" data-field="wroughtPanelFabrication">${createSelect(WROUGHT_PANEL_FABRICATION_OPTIONS)}</select>
            <div class="sp-hint">TMI custom panels include powder coating and use $${WROUGHT_TMI_CUSTOM_PANEL_COST} each.</div>
          </div>
          <div class="sp-field col-2" data-install-only data-shop-fabrication-only style="display:none">
            <label class="sp-label">Powder Coat Panels</label>
            <label class="sp-row" style="gap:6px">
              <input type="checkbox" data-field="wroughtPowderCoatPanels" />
              Add powder coating
            </label>
          </div>
          <div class="sp-field col-2" data-install-only data-shop-fabrication-only style="display:none">
            <label class="sp-label">Powder Coat Posts</label>
            <label class="sp-row" style="gap:6px">
              <input type="checkbox" data-field="wroughtPowderCoatPosts" />
              Add powder coating
            </label>
          </div>
          <div class="sp-field col-2" data-install-finials style="display:none">
            <label class="sp-label">Finial Style</label>
            <select class="sp-select" data-field="installFinialStyle">${createSelect(SEED.finialStyles)}</select>
          </div>

          <div class="sp-field col-3">
            <label class="sp-label">LF Over Hardscape</label>
            ${numberControl('hardscape','e.g., 12')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">LF to Trim</label>
            ${numberControl('trim','e.g., 6')}
          </div>
          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label">LF to Dig Out</label>
            ${numberControl('digOut','e.g., 10')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Painting</label>
            <select class="sp-select" data-field="painting">
              <option value="Paint Section">Paint Section</option>
              <option value="Prime and Paint">Prime and Paint</option>
              <option value="Spot Paint Welds">Spot Paint Welds</option>
              <option value="None">None</option>
            </select>
          </div>
          <div class="sp-field col-3" data-painting-application style="display:none">
            <label class="sp-label">Paint Application</label>
            <select class="sp-select" data-field="paintingApplication">
              <option value="By Hand">By Hand</option>
              <option value="Spray">Spray</option>
            </select>
          </div>
          <div class="sp-field col-3" data-painting-colors style="display:none">
            <label class="sp-label">Current Fence Color</label>
            <select class="sp-select" data-field="paintingCurrentColor">${createSelect(WROUGHT_CURRENT_COLOR_OPTIONS)}</select>
          </div>
          <div class="sp-field col-3" data-painting-colors style="display:none">
            <label class="sp-label">Paint Color</label>
            <select class="sp-select" data-field="paintingTargetColor">${createSelect(WROUGHT_PAINT_COLOR_OPTIONS)}</select>
          </div>
          <div class="sp-field col-3" data-painting-prep style="display:none">
            <label class="sp-label">Prep Needs</label>
            <label class="sp-row" style="gap:6px">
              <input type="checkbox" data-field="paintingPrepExtra" />
              More than usual prep
            </label>
          </div>

          <div class="col-12 sp-divider"></div>

          <!-- ========== GROUP: Rails ========== -->
          <div class="sp-field col-12" data-rails-wrap>
            <div class="sp-rail-row" data-rails-row>
              <div class="sp-field" data-rail-count>
                <label class="sp-label">Rails</label>
                <select class="sp-select" data-field="railsCount">
                  <option value="2">2 Rail</option>
                  <option value="3">3 Rail</option>
                  <option value="4">4 Rail</option>
                </select>
              </div>
            </div>
          </div>

          <!-- ========== GROUP: Pickets & Finials ========== -->
          <div class="sp-field col-3">
            <label class="sp-label">Picket Size</label>
            <select class="sp-select" data-field="picketSize">${createSelect(SEED.picketSize)}</select>
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Picket Height (inches)</label>
            ${numberControl('picketHeight','e.g., 54')}
          </div>
          <div class="sp-field col-3">
            <label class="sp-label">Puppy Pickets</label>
            <select class="sp-select" data-field="puppy">${createSelect(SEED.puppy)}</select>
          </div>
        </div>
        </div>
        </div>
        <div class="sp-scope-group col-12 is-repair" data-section-detail data-repair-only data-wrought-only>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Repairs</div>
            <div>
              <div class="sp-scope-title">Posts, caps, panels & patch work</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
          <div class="sp-field col-12" data-repair-only>
            <label class="sp-label">Rail Repairs</label>
            <div class="sp-rail-row" data-rail-repair-row></div>
          </div>

          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label"># Pickets to Replace</label>
            ${numberControl('wiPickets','0')}
          </div>
          <div class="sp-field col-3" data-repair-only data-wrought-only data-puppy-repair>
            <label class="sp-label">Puppy Picket Size</label>
            <select class="sp-select" data-field="puppyPicketSize">${createSelect(SEED.picketSize)}</select>
          </div>
          <div class="sp-field col-3" data-repair-only data-wrought-only data-puppy-repair>
            <label class="sp-label">Puppy Picket Height (inches)</label>
            ${numberControl('puppyPicketHeight','e.g., 24')}
          </div>
          <div class="sp-field col-3" data-repair-only data-wrought-only data-puppy-repair>
            <label class="sp-label"># Puppy Pickets to Replace</label>
            ${numberControl('puppyPicketReplace','0')}
          </div>
          <div class="sp-field col-3" data-repair-only>
            <label class="sp-label">Weld Redos</label>
            ${numberControl('weldRedos','0')}
            <div class="sp-hint">Redo broken welds (no new material). ~5 minutes each for a welder.</div>
          </div>

        <!-- Finial replacements (kept as a block) -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Finial Replacements</label>
          <div data-finials></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-finial-add>+ Add Finial Replacement</button>
            <span class="sp-hint">Each replacement adds ~30 seconds of labor. Unit cost: $1.25.</span>
          </div>
        </div>

        <!-- ========== GROUP: Posts & Caps ========== -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Replacements</label>
          <div data-post-replacements></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-post-replacement-add>+ Add Post Replacement</button>
            <span class="sp-hint">List each post size and quantity to replace.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Realignments</label>
          <div data-post-realign></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-post-realign-add>+ Add Post Realignment</button>
            <span class="sp-hint">Track leaning posts and choose the realignment method.</span>
          </div>
        </div>

        <!-- Post Cap replacements (kept as a block) -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Post Cap Replacements</label>
          <div data-caps></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-cap-add>+ Add Cap Replacement</button>
            <span class="sp-hint">Each cap adds ~20 seconds of labor. Pricing varies by size & style.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Diagonal Braces</label>
          <div data-diagonal-braces></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-diagonal-brace-add>+ Add Diagonal Brace</button>
            <span class="sp-hint">Each brace uses 4 ft of picket steel.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Full Rail Gap Fillers</label>
          <div data-gap-additions></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-gap-addition-add>+ Add Full Rail Gap Filler</button>
            <span class="sp-hint">Record each rail size and quantity to close open spans.</span>
          </div>
        </div>

        <div class="col-12 sp-divider"></div>

        <!-- ========== GROUP: Panel Replacements ========== -->
        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Panel Replacements</label>
          <div data-panels></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-panel-add>+ Add Panel Replacement</button>
            <span class="sp-hint">Prefab panel eligible if width ≤ 96&quot; (8 ft), 1&quot; rails, and 1/2&quot; or 5/8&quot; pickets. Install = 30 min per panel; custom build+paint = 1.5 hr per panel.</span>
          </div>
        </div>

        <div class="sp-field col-12" data-repair-only>
          <label class="sp-label">Puppy Picket Inserts</label>
          <div data-puppy-inserts></div>
          <div class="sp-row" style="margin-top:6px">
            <button class="sp-btn ghost" type="button" data-puppy-insert-add>+ Add Puppy Picket Insert</button>
            <span class="sp-hint">Each insert takes a welder + helper about 30 minutes. Unit cost: $62.59 plus picket plugs.</span>
          </div>
        </div>

        <div class="col-12 sp-divider"></div>

          </div>
        </div>
        <div class="sp-scope-group col-12 is-gates" data-section-detail>
          <div class="sp-scope-head">
            <div class="sp-scope-pill">Gates</div>
            <div>
              <div class="sp-scope-title">Gate repairs & new openings</div>
              <div class="sp-scope-sub"></div>
            </div>
          </div>
          <div class="sp-grid sp-scope-grid">
        <!-- ========== GROUP: Gates (unchanged, follows after above groups) ========== -->
        <div class="sp-field col-3" data-repair-only data-wrought-only>
          <label class="sp-label"># Walk Gates</label>
          ${numberControl('walkGates','0')}
        </div>
        <div class="sp-field col-12" data-wg-wrap data-repair-only data-wrought-only style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gates to Realign</label>
              ${numberControl('walkGatesRealign','0')}
            </div>
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gate Hardware Replacements</label>
              ${numberControl('walkGatesHardware','0')}
            </div>
            <div class="sp-field col-6" data-wg-hw-wrap style="display:none">
              <div class="sp-grid">
                <div class="sp-field col-6">
                  <label class="sp-label">Latch Type</label>
                  <select class="sp-select" data-field="walkLatch">${createSelect(GATE.latchTypes)}</select>
                </div>
                <div class="sp-field col-6">
                  <label class="sp-label">Hinges</label>
                  <select class="sp-select" data-field="walkHinges">${createSelect(GATE.hingeTypes)}</select>
                </div>
              </div>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label"># Walk Gates to Rebuild</label>
              ${numberControl('walkGatesRebuild','0')}
            </div>
            <div class="sp-field col-12" data-wg-rebuild-wrap style="display:none">
              <div class="sp-grid">
                <div class="sp-field col-3">
                  <label class="sp-label">Gate Frame Size</label>
                  <select class="sp-select" data-field="walkRebuildFrame">${createSelect(SEED.railSize)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Gate Picket Size</label>
                  <select class="sp-select" data-field="walkRebuildPicket">${createSelect(SEED.picketSize)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Latch Type</label>
                  <select class="sp-select" data-field="walkRebuildLatch">${createSelect(GATE.latchTypes)}</select>
                </div>
                <div class="sp-field col-3">
                  <label class="sp-label">Hinges</label>
                  <select class="sp-select" data-field="walkRebuildHinges">${createSelect(GATE.hingeTypes)}</select>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Add a Wrought Iron Walk Gate (into existing fence) -->
        <div class="sp-field col-3" data-wrought-only>
          <label class="sp-label"># Walk Gates to Add</label>
          ${numberControl('walkGatesAdd','0')}
        </div>
        <div class="sp-field col-12" data-wrought-only data-wg-add-wrap style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Gate Type</label>
              <select class="sp-select" data-field="walkAddType">${createSelect(WALK_GATE_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Post Size</label>
              <select class="sp-select" data-field="walkAddPostSize">${createSelect(SEED.postSize)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Frame Size</label>
              <select class="sp-select" data-field="walkAddFrameSize">${createSelect(SEED.railSize)}</select>
            </div>
            <div class="sp-field col-3" data-wg-add-pickets>
              <label class="sp-label">Gate Picket Size</label>
              <select class="sp-select" data-field="walkAddPicketSize">${createSelect(SEED.picketSize)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Latch Type</label>
              <select class="sp-select" data-field="walkAddLatch">${createSelect(GATE.latchTypes)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Hinges</label>
              <select class="sp-select" data-field="walkAddHinges">${createSelect(GATE.hingeTypes)}</select>
            </div>
          </div>
          <div class="sp-hint">Single swing: adds 2 labor hours, 1 post, and 2× 12ft rails per rail size. Double swing: adds 3 labor hours, 1 post, and 4× 12ft rails per rail size. For install/replace sections set to Anchored, use 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per gate post; otherwise use 1 bag concrete per gate post.</div>
        </div>

        <!-- Add a Wood Walk Gate -->
        <div class="sp-field col-3" data-wood-only>
          <label class="sp-label"># Walk Gates to Add</label>
          ${numberControl('woodWalkGatesAdd','0')}
        </div>
        <div class="sp-field col-12" data-wood-only data-wood-wg-add-wrap style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Gate Type</label>
              <select class="sp-select" data-field="woodWalkAddType">${createSelect(WALK_GATE_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Post Type</label>
              <select class="sp-select" data-field="woodWalkAddPostType">${createSelect(WOOD_GATE_POST_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Frame Size</label>
              <select class="sp-select" data-field="woodWalkAddFrameSize">${createSelect(WOOD_RAIL_SIZES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Gate Picket Width</label>
              <select class="sp-select" data-field="woodWalkAddPicketWidth">${createSelect(WOOD_PICKET_WIDTHS)}</select>
            </div>
          </div>
          <div class="sp-hint">Includes latch and hinge hardware. Uses wood-specific materials for posts, frame, and pickets.</div>
        </div>

        <!-- NEW: Replace Sliding Drive Gate Chain -->
        <div class="sp-field col-3" data-repair-only data-wrought-only>
          <label class="sp-label"># Sliding Drive Gate Chains to Replace</label>
          ${numberControl('driveGateChainReplace','0')}
          <div class="sp-hint">Adds $150 materials and 1 crew hour per chain.</div>
        </div>

        <!-- NEW: Replace Drive Gate Operator -->
        <div class="sp-field col-3" data-wrought-only>
          <label class="sp-label"># Drive Gate Operators to Replace</label>
          ${numberControl('driveGateOperatorReplace','0')}
        </div>
        <div class="sp-field col-12" data-drive-operator-wrap data-wrought-only style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Drive Gate Type</label>
              <select class="sp-select" data-field="driveGateOperatorType">${createSelect(DRIVE_GATE_OPERATOR_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Power Type</label>
              <select class="sp-select" data-field="driveGateOperatorPower">${createSelect(DRIVE_GATE_POWER_TYPES)}</select>
            </div>
          </div>
          <div class="sp-hint">Includes removal, haul away, and disposal of the old operator. LiftMaster only.</div>
        </div>

        <!-- NEW: Install Drive Gate Operator -->
        <div class="sp-field col-3" data-wrought-only>
          <label class="sp-label"># Drive Gate Operators to Install</label>
          ${numberControl('driveGateOperatorInstall','0')}
        </div>
        <div class="sp-field col-12" data-drive-operator-install-wrap data-wrought-only style="display:none">
          <div class="sp-grid">
            <div class="sp-field col-3">
              <label class="sp-label">Drive Gate Type</label>
              <select class="sp-select" data-field="driveGateOperatorInstallType">${createSelect(DRIVE_GATE_OPERATOR_TYPES)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Power Type</label>
              <select class="sp-select" data-field="driveGateOperatorInstallPower">${createSelect(DRIVE_GATE_POWER_TYPES_INSTALL)}</select>
            </div>
            <div class="sp-field col-3">
              <label class="sp-label">Platform Needed</label>
              <label class="sp-row" style="gap:6px">
                <input type="checkbox" data-field="driveGateOperatorInstallPlatform" />
                Build operator platform
              </label>
            </div>
          </div>
          <div class="sp-hint">LiftMaster only. No existing wiring option for installs.</div>
        </div>

        </div>

          </div>
        </div>
        <!-- Notes (section-specific) - LAST -->
        <div class="sp-field col-12">
          <label class="sp-label">Notes (section-specific)</label>
          <textarea class="sp-textarea" data-field="notes" placeholder="Any custom notes for this section..."></textarea>
        </div>
      </div>
    </div>`;
  }

  function addSection(data={}){
    syncStateFromDOM();
    state.sections.push(createSectionBase(data));
    render();
  }
  function duplicateSection(id){
    syncStateFromDOM();
    const src = state.sections.find(s=>s.id===id);
    if(!src) return;
    const copy = JSON.parse(JSON.stringify(src));
    copy.id = uid();
    copy.collapsed = false;
    copy.mapGenerated = false;
    delete copy.mapSegmentId;
    delete copy.mapGeneratedLabel;
    state.sections.push(copy);
    render();
  }

  const STYLE_FIELDS = [
    'fenceType','scopeType','style','height','postSize','postSpacing','panelAttachment','wroughtCustomStickLength','wroughtPanelFabrication','wroughtPowderCoatPanels','wroughtPowderCoatPosts','installFinialStyle','railsCount','rails',
    'picketSize','picketHeight','puppy','puppyPicketSize','puppyPicketHeight','puppyPicketReplace','painting','paintingApplication','paintingPrepExtra','paintingCurrentColor','paintingTargetColor','woodHeight','woodStyle','woodPicketWidth','woodRailSize',
    'woodPost','woodType','woodFinish','woodKickBoardSize','woodKickBoardStack','woodTopCapSize','woodTrimType','woodAddKickBoard',
    'woodAddTopCap','woodAddTrim','woodRepairStain','woodRepairStainBrand','walkLatch','walkHinges','walkRebuildFrame',
    'walkRebuildPicket','walkRebuildLatch','walkRebuildHinges','walkAddType','walkAddPostSize','walkAddFrameSize',
    'walkAddPicketSize','walkAddLatch','walkAddHinges','woodWalkAddType','woodWalkAddPostType','woodWalkAddFrameSize',
    'woodWalkAddPicketWidth','driveGateChainReplace','driveGateOperatorReplace','driveGateOperatorType',
    'driveGateOperatorPower','driveGateOperatorInstall','driveGateOperatorInstallType','driveGateOperatorInstallPower',
    'driveGateOperatorInstallPlatform','woodRepairPostReplaceTie','woodRepairPostReplaceCap','woodWalkGatesAdd',
    'woodPostRealignments','woodRepairPostInstallMethod','woodRepairPostInstallTie','useExistingPostsForReplacement','postInstallMethod','woodInstallPostSpacing','woodReplacementPostSpacing'
  ];

  const BULK_WROUGHT_FIELDS = [
    'fenceType','scopeType','style','height','postSize','panelAttachment','wroughtCustomStickLength','wroughtPanelFabrication','wroughtPowderCoatPanels','wroughtPowderCoatPosts',
    'railsCount','rails','picketSize','picketHeight','puppy','useExistingPostsForReplacement','postInstallMethod'
  ];

  const BULK_WOOD_FIELDS = [
    'fenceType','scopeType','woodHeight','woodStyle','woodPicketWidth','woodRailSize',
    'woodPost','woodType','woodFinish','woodAddKickBoard','woodAddTopCap','woodAddTrim',
    'woodKickBoardSize','woodKickBoardStack','woodTopCapSize','woodTrimType','woodRepairStainBrand','useExistingPostsForReplacement','postInstallMethod','woodInstallPostSpacing','woodReplacementPostSpacing'
  ];

  function normalizeBulkFenceType(value){
    return String(value || '').toLowerCase() === 'wood' ? 'wood' : 'wrought iron';
  }

  function cloneRailsForBulk(rails, railsCount){
    const count = Math.max(1, parseInt(railsCount, 10) || 2);
    const sourceRails = Array.isArray(rails) ? rails : [];
    const fallbackRail = sourceRails[0] || {};
    const fallbackSize = String(fallbackRail.size || SEED.railSize[0] || '').trim() || SEED.railSize[0];
    const next = [];
    for(let i=0;i<count;i++){
      const sourceRail = sourceRails[i] || fallbackRail || {};
      const size = String(sourceRail.size || fallbackSize || '').trim() || fallbackSize;
      const stacked = !!sourceRail.stacked;
      const rawSize2 = String(sourceRail.size2 || sourceRail.size || size || '').trim();
      const size2 = stacked ? (rawSize2 || size) : size;
      next.push({
        size,
        stacked,
        size2,
        patches: 0,
        replacements: 0,
      });
    }
    return next;
  }

  function buildBulkBasicsTemplate(source){
    if(!source){
      return null;
    }
    const normalizedFenceType = normalizeBulkFenceType(source.fenceType);
    const isWood = normalizedFenceType === 'wood';
    const fenceType = isWood ? 'Wood' : 'Wrought Iron';
    const fields = isWood ? BULK_WOOD_FIELDS : BULK_WROUGHT_FIELDS;
    const values = {};

    fields.forEach(field=>{
      if(field === 'fenceType'){
        values.fenceType = fenceType;
        return;
      }
      if(field === 'railsCount' || field === 'rails'){
        return;
      }
      values[field] = source[field];
    });

    values.scopeType = values.scopeType || source.scopeType || 'repair';
    values.postInstallMethod = normalizePostInstallMethod(source.postInstallMethod);

    if(isWood){
      values.woodHeight = source.woodHeight || '6ft';
      values.woodStyle = source.woodStyle || 'Side by Side';
      values.woodPicketWidth = source.woodPicketWidth || '5.5"';
      values.woodRailSize = source.woodRailSize || '2x4';
      values.woodPost = source.woodPost || 'Round Steel';
      values.woodType = source.woodType || 'Cedar';
      values.woodFinish = source.woodFinish || 'Oil Based Stain';
      values.woodAddKickBoard = !!source.woodAddKickBoard;
      values.woodAddTopCap = !!source.woodAddTopCap;
      values.woodAddTrim = !!source.woodAddTrim;
      values.woodKickBoardSize = source.woodKickBoardSize || '2x6';
      values.woodKickBoardStack = source.woodKickBoardStack || '1';
      values.woodTopCapSize = source.woodTopCapSize || '2x6';
      values.woodTrimType = source.woodTrimType || '1x4';
      values.woodRepairStainBrand = normalizeWoodStainBrand(source.woodRepairStainBrand);
    }else{
      values.style = source.style || SEED.style[0];
      values.height = source.height || '4ft';
      values.postSize = source.postSize || '2x2';
      values.panelAttachment = source.panelAttachment || 'Welding';
      values.wroughtCustomStickLength = normalizeWroughtCustomStickLength(source.wroughtCustomStickLength);
      values.wroughtPanelFabrication = normalizeWroughtPanelFabrication(source.wroughtPanelFabrication);
      values.wroughtPowderCoatPanels = !!source.wroughtPowderCoatPanels;
      values.wroughtPowderCoatPosts = !!source.wroughtPowderCoatPosts;
      values.picketSize = source.picketSize || SEED.picketSize[0];
      values.picketHeight = source.picketHeight || '';
      values.puppy = source.puppy || SEED.puppy[0];
      values.railsCount = Math.max(1, parseInt(source.railsCount, 10) || 2);
      values.rails = cloneRailsForBulk(source.rails, values.railsCount);
    }

    return { normalizedFenceType, values };
  }

  function preserveSectionForBulk(section){
    return {
      id: section.id,
      collapsed: section.collapsed,
      label: section.label,
      useExistingPostsForReplacement: normalizeUseExistingPostsForReplacement(section.useExistingPostsForReplacement),
      woodInstallPostSpacing: normalizeWoodInstallPostSpacing(section.woodInstallPostSpacing),
      woodReplacementPostSpacing: normalizeWoodReplacementPostSpacing(section.woodReplacementPostSpacing),
      length: section.length,
      hardscape: section.hardscape,
      trim: section.trim,
      digOut: section.digOut,
      mapGenerated: section.mapGenerated,
      mapSegmentId: section.mapSegmentId,
      mapGeneratedLabel: section.mapGeneratedLabel,
      mapMeasuredLength: section.mapMeasuredLength,
      mapLengthOverride: section.mapLengthOverride,
      notes: section.notes,
    };
  }

  function applyBasicsToAllSectionsFrom(sourceId){
    syncStateFromDOM();
    if(!state.sections.length){
      return;
    }
    const source = state.sections.find(sec => sec.id === sourceId);
    if(!source){
      return;
    }
    const template = buildBulkBasicsTemplate(source);
    if(!template){
      return;
    }

    const targetFenceType = template.normalizedFenceType;
    const templateValues = template.values;

    state.sections = state.sections.map(section=>{
      const currentFenceType = normalizeBulkFenceType(section.fenceType);
      let nextSection;
      if(currentFenceType !== targetFenceType){
        const preserved = preserveSectionForBulk(section);
        nextSection = createSectionBase({
          ...preserved,
          fenceType: templateValues.fenceType,
          scopeType: templateValues.scopeType
        });
      }else{
        nextSection = { ...section };
      }

      Object.entries(templateValues).forEach(([key, value])=>{
        if(key === 'rails'){
          const existingRails = Array.isArray(nextSection.rails) ? nextSection.rails : [];
          nextSection.rails = Array.isArray(value)
            ? value.map((rail, idx)=>{
              const existingRail = existingRails[idx] || {};
              const existingPatches = Math.max(0, Number(existingRail.patches) || 0);
              const existingReplacements = Math.max(0, Number(existingRail.replacements) || 0);
              return {
                size: rail.size,
                stacked: !!rail.stacked,
                size2: rail.size2 || rail.size,
                patches: existingPatches,
                replacements: existingReplacements,
              };
            })
            : [];
          return;
        }
        const shouldClone = Array.isArray(value) || (value && typeof value === 'object');
        nextSection[key] = shouldClone ? JSON.parse(JSON.stringify(value)) : value;
      });
      return nextSection;
    });

    render();
    persist();
  }

  function createSectionFromStyle(source){
    if(!source) return null;
    const base = createSectionBase({
      fenceType: source.fenceType,
      scopeType: source.scopeType,
      painting: source.painting
    });
    STYLE_FIELDS.forEach(key=>{
      if(typeof source[key] === 'undefined') return;
      const value = source[key];
      if(key === 'rails' && Array.isArray(value)){
        base.rails = value.map(rail=>({
          size: rail.size,
          stacked: !!rail.stacked,
          size2: rail.size2 || rail.size,
          patches: 0,
          replacements: 0,
        }));
        return;
      }
      const shouldClone = Array.isArray(value) || (value && typeof value === 'object');
      base[key] = shouldClone ? JSON.parse(JSON.stringify(value)) : value;
    });
    return base;
  }

  function duplicateSectionStyleFrom(source){
    const nextSection = createSectionFromStyle(source);
    if(!nextSection) return;
    state.sections.push(nextSection);
    render();
  }
  function duplicateFirstSectionStyle(){
    syncStateFromDOM();
    if(!state.sections.length) return;
    duplicateSectionStyleFrom(state.sections[0]);
  }
  function duplicateLatestSectionStyle(){
    syncStateFromDOM();
    if(!state.sections.length) return;
    duplicateSectionStyleFrom(state.sections[state.sections.length-1]);
  }
  function removeSection(id){
    syncStateFromDOM();
    state.sections = state.sections.filter(s=>s.id!==id);
    render();
  }

  function readSectionFromDOM(card){
    const id = card.getAttribute('data-id');
    function val(field){
      const el = card.querySelector(`[data-field="${field}"]`);
      if(!el) return '';
      if(el.classList.contains('sp-number')){
        return parseInt(el.querySelector('input').value||'0',10) || 0;
      }
      if(el.type==='checkbox'){ return !!el.checked; }
      if(el.tagName==='INPUT' || el.tagName==='TEXTAREA' || el.tagName==='SELECT') return el.value;
      return '';
    }

    const railsCount = parseInt(val('railsCount') || '2', 10);
    const rails = [];
    for(let i=0;i<railsCount;i++){
      rails.push({
        size: val(`railSize_${i}`),
        stacked: !!val(`railStacked_${i}`),
        size2: val(`railSize2_${i}`),
        patches: val(`railPatches_${i}`),
        replacements: val(`railRepl_${i}`)
      });
    }

    // NEW: Finials (dynamic rows)
    const finials = [];
    const finCont = card.querySelector('[data-finials]');
    if (finCont){
      const rows = Array.from(finCont.querySelectorAll('[data-finial-row]'));
      rows.forEach(row => {
        const qty = parseInt((row.querySelector('[data-finial-qty] input')?.value)||'0',10) || 0;
        const style = (row.querySelector('[data-finial-style]')?.value) || (SEED.finialStyles && SEED.finialStyles[0]);
        const material = (row.querySelector('[data-finial-material]')?.value) || (SEED.finialMaterials && SEED.finialMaterials[0]);
        const picketSize = (row.querySelector('[data-finial-picket]')?.value) || (SEED.picketSize && SEED.picketSize[0]);
        if(qty>0){ finials.push({ qty, style, material, picketSize }); }
      });
    }

    const puppyInserts = [];
    const puppyCont = card.querySelector('[data-puppy-inserts]');
    if(puppyCont){
      const rows = Array.from(puppyCont.querySelectorAll('[data-puppy-insert-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-puppy-insert-qty] input')?.value)||'0',10) || 0;
        const picketSize = (row.querySelector('[data-puppy-insert-size]')?.value) || PUPPY_INSERT_SIZES[0];
        if(qty>0){ puppyInserts.push({ qty, picketSize }); }
      });
    }

    // NEW: Caps (dynamic rows)
    const caps = [];
    const capCont = card.querySelector('[data-caps]');
    if (capCont){
      const rows = Array.from(capCont.querySelectorAll('[data-cap-row]'));
      rows.forEach(row => {
        const qty = parseInt((row.querySelector('[data-cap-qty] input')?.value)||'0',10) || 0;
        const style = (row.querySelector('[data-cap-style]')?.value) || (SEED.capStyles && SEED.capStyles[0]);
        const material = (row.querySelector('[data-cap-material]')?.value) || (SEED.capMaterials && SEED.capMaterials[0]);
        const postSize = (row.querySelector('[data-cap-post]')?.value) || (SEED.capPostSizes && SEED.capPostSizes[0]);
        if(qty>0){ caps.push({ qty, style, material, postSize }); }
      });
    }

    // PANELs (dynamic rows)
    const panels = [];
    const panelsCont = card.querySelector('[data-panels]');
    if(panelsCont){
      const rows = Array.from(panelsCont.querySelectorAll('[data-panel-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-panel-qty] input')?.value)||'0',10) || 0;
        const height = (row.querySelector('[data-panel-height]')?.value) || SEED.height[1];
        const style  = (row.querySelector('[data-panel-style]')?.value) || SEED.style[0];
        const railSize = (row.querySelector('[data-panel-rail]')?.value) || SEED.railSize[0];
        const picketSize = (row.querySelector('[data-panel-picket]')?.value) || SEED.picketSize[0];
        const widthIn = parseInt((row.querySelector('[data-panel-width] input')?.value)||'0',10) || 0;
        const hasFinials = /Finials/i.test(style);
        const finialStyle = hasFinials
          ? ((row.querySelector('[data-panel-finial-style]')?.value) || SEED.finialStyles[0])
          : '';
        if(qty>0){ panels.push({ qty, height, style, railSize, picketSize, widthIn, finialStyle }); }
      });
    }

    const gapAdditions = [];
    const gapCont = card.querySelector('[data-gap-additions]');
    if(gapCont){
      const rows = Array.from(gapCont.querySelectorAll('[data-gap-addition-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-gap-addition-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-gap-addition-size]')?.value) || SEED.railSize[0];
        if(qty>0){ gapAdditions.push({ qty, size }); }
      });
    }

    const diagonalBraces = [];
    const braceCont = card.querySelector('[data-diagonal-braces]');
    if(braceCont){
      const rows = Array.from(braceCont.querySelectorAll('[data-diagonal-brace-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-diagonal-brace-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-diagonal-brace-size]')?.value) || SEED.picketSize[0];
        if(qty>0){ diagonalBraces.push({ qty, size }); }
      });
    }

    const postReplacements = [];
    const postRepCont = card.querySelector('[data-post-replacements]');
    if(postRepCont){
      const rows = Array.from(postRepCont.querySelectorAll('[data-post-replacement-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-post-replacement-qty] input')?.value)||'0',10) || 0;
        const size = (row.querySelector('[data-post-replacement-size]')?.value) || SEED.postSize[0];
        if(qty>0){ postReplacements.push({ qty, size }); }
      });
    }

    const postRealignments = [];
    const postRealignCont = card.querySelector('[data-post-realign]');
    if(postRealignCont){
      const rows = Array.from(postRealignCont.querySelectorAll('[data-post-realign-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-post-realign-qty] input')?.value)||'0',10) || 0;
        const rawMethod = (row.querySelector('[data-post-realign-method]')?.value) || 'concrete';
        const method = rawMethod === 'cut-weld' ? 'cut-weld' : 'concrete';
        const size = (row.querySelector('[data-post-realign-size]')?.value) || SEED.postRealignSize[0];
        if(qty>0){
          const entry = { qty, method, size };
          postRealignments.push(entry);
        }
      });
    }

    const woodPostRealignments = [];
    const woodPostRealignCont = card.querySelector('[data-wood-post-realign]');
    if(woodPostRealignCont){
      const rows = Array.from(woodPostRealignCont.querySelectorAll('[data-wood-post-realign-row]'));
      rows.forEach(row=>{
        const qty = parseInt((row.querySelector('[data-wood-post-realign-qty] input')?.value)||'0',10) || 0;
        const method = (row.querySelector('[data-wood-post-realign-method]')?.value) || 'dig-straighten';
        if(qty>0){
          woodPostRealignments.push({ qty, method });
        }
      });
    }

    const currentFenceType = val('fenceType') || 'Wrought Iron';
    const normalizedFence = currentFenceType.toLowerCase();
    const scopeTypeValue = val('scopeType') || 'repair';
    const panelAttachmentValue = val('panelAttachment');
    const rawPaintingSelection = normalizedFence === 'wood' ? 'None' : val('painting');
    const wroughtPanelFabrication = normalizeWroughtPanelFabrication(val('wroughtPanelFabrication'));
    const powderCoatPanelsValue = false;
    const powderCoatPostsValue = false;
    const paintingSelection = normalizedFence === 'wood'
      ? 'None'
      : effectiveWroughtPaintingSelection({
        fenceType: currentFenceType,
        scopeType: scopeTypeValue,
        panelAttachment: panelAttachmentValue,
        wroughtPanelFabrication,
        wroughtPowderCoatPanels: powderCoatPanelsValue,
        painting: rawPaintingSelection
      });
    const paintingMethod = normalizedFence === 'wood' ? '' : val('paintingApplication');
    const paintingPrepExtra = paintingSelection === 'Paint Section' ? val('paintingPrepExtra') : false;
    const paintingCurrentColor = normalizedFence === 'wood'
      ? ''
      : (val('paintingCurrentColor') || WROUGHT_CURRENT_COLOR_OPTIONS[0]);
    const paintingTargetColor = normalizedFence === 'wood'
      ? ''
      : (val('paintingTargetColor') || WROUGHT_PAINT_COLOR_OPTIONS[0]);
    updateMapLengthOverrideFromCard(card);
    const mapLengthOverride = parsePositiveInt(card.dataset.mapLengthOverride);
    const mapMeasuredLength = parsePositiveInt(card.dataset.mapMeasuredLength);

    const sectionData = {
      id,
      label: val('label').trim(),
      fenceType: currentFenceType,
      scopeType: scopeTypeValue,
      useExistingPostsForReplacement: normalizeUseExistingPostsForReplacement(val('useExistingPostsForReplacement')),
      postInstallMethod: normalizePostInstallMethod(val('postInstallMethod')),
      woodInstallPostSpacing: normalizeWoodInstallPostSpacing(val('woodInstallPostSpacing')),
      woodReplacementPostSpacing: normalizeWoodReplacementPostSpacing(val('woodReplacementPostSpacing')),
      style: val('style'),
      height: val('height'),
      postSize: val('postSize'),
      postSpacing: val('postSpacing'),
      panelAttachment: panelAttachmentValue,
      wroughtCustomStickLength: val('wroughtCustomStickLength') || '12',
      wroughtPanelFabrication,
      wroughtPowderCoatPanels: powderCoatPanelsValue,
      wroughtPowderCoatPosts: powderCoatPostsValue,
      installFinialStyle: val('installFinialStyle'),
      postReplacements,
      postRealignments,

      railsCount,
      rails,
      gapAdditions,
      diagonalBraces,

      railSize: rails[0]?.size || '',
      railStacked: !!rails[0]?.stacked,
      railSize2: rails[0]?.size2 || '',

      picketSize: val('picketSize'),
      picketHeight: val('picketHeight'),
      puppy: val('puppy'),
      puppyPicketSize: val('puppyPicketSize'),
      puppyPicketHeight: val('puppyPicketHeight'),
      puppyPicketReplace: val('puppyPicketReplace'),
      painting: paintingSelection,
      paintingApplication: paintingMethod,
      paintingPrepExtra,
      paintingCurrentColor,
      paintingTargetColor,
      woodHeight: val('woodHeight'),
      woodStyle: val('woodStyle'),
      woodPicketWidth: val('woodPicketWidth'),
      woodRailSize: val('woodRailSize'),
      woodPost: val('woodPost'),
      woodType: val('woodType'),
      woodFinish: val('woodFinish'),
      woodKickBoardSize: val('woodKickBoardSize'),
      woodKickBoardStack: val('woodKickBoardStack'),
      woodTopCapSize: val('woodTopCapSize'),
      woodTrimType: val('woodTrimType'),
      woodPostRealignments,
      woodRepairPicketReplace: val('woodRepairPicketReplace'),
      woodRepairPicketInstall: val('woodRepairPicketInstall'),
      woodRepairRailReplace: val('woodRepairRailReplace'),
      woodRepairRailInstall: val('woodRepairRailInstall'),
      woodRepairPostReplace: val('woodRepairPostReplace'),
      woodRepairPostReplaceTie: val('woodRepairPostReplaceTie'),
      woodRepairPostReplaceCap: val('woodRepairPostReplaceCap'),
      woodRepairPostInstall: val('woodRepairPostInstall'),
      woodRepairPostInstallMethod: val('woodRepairPostInstallMethod'),
      woodRepairPostInstallTie: val('woodRepairPostInstallTie'),
      woodRepairPanelReplace: val('woodRepairPanelReplace'),
      woodRepairPanelWidth: val('woodRepairPanelWidth'),
      woodRepairWalkGateCount: val('woodRepairWalkGateCount'),
      woodRepairWalkGateHinges: val('woodRepairWalkGateHinges'),
      woodRepairWalkGateLatch: val('woodRepairWalkGateLatch'),
      woodRepairWalkGateWood: val('woodRepairWalkGateWood'),
      woodRepairGateStrengthen: val('woodRepairGateStrengthen'),
      woodRepairGateReplace: val('woodRepairGateReplace'),
      woodRepairTopCapReplaceLf: val('woodRepairTopCapReplaceLf'),
      woodRepairTopCapReplaceSize: val('woodRepairTopCapReplaceSize'),
      woodRepairTrimReplaceLf: val('woodRepairTrimReplaceLf'),
      woodRepairTrimReplaceSize: val('woodRepairTrimReplaceSize'),
      woodRepairKickReplaceLf: val('woodRepairKickReplaceLf'),
      woodRepairKickReplaceSize: val('woodRepairKickReplaceSize'),
      woodRepairKickReplaceStack: val('woodRepairKickReplaceStack'),
      woodRepairStain: val('woodRepairStain'),
      woodRepairStainBrand: val('woodRepairStainBrand'),
      woodAddKickBoard: val('woodAddKickBoard'),
      woodAddTopCap: val('woodAddTopCap'),
      woodAddTrim: val('woodAddTrim'),
      retainingWallLength: val('retainingWallLength'),
      retainingWallHeight: val('retainingWallHeight'),
      length: val('length'),
      hardscape: val('hardscape'),
      trim: val('trim'),
      digOut: val('digOut'),
      wiPickets: val('wiPickets'),
      weldRedos: val('weldRedos'),
      walkGates: val('walkGates'),
      walkGatesRealign: val('walkGatesRealign'),
      walkGatesHardware: val('walkGatesHardware'),
      walkGatesRebuild: val('walkGatesRebuild'),
      walkLatch: val('walkLatch'),
      walkHinges: val('walkHinges'),
      walkRebuildFrame: val('walkRebuildFrame'),
      walkRebuildPicket: val('walkRebuildPicket'),
      walkRebuildLatch: val('walkRebuildLatch'),
      walkRebuildHinges: val('walkRebuildHinges'),

      // NEW
      walkGatesAdd: val('walkGatesAdd'),
      walkAddType: val('walkAddType'),
      walkAddPostSize: val('walkAddPostSize'),
      walkAddFrameSize: val('walkAddFrameSize'),
      walkAddPicketSize: val('walkAddPicketSize'),
      walkAddLatch: val('walkAddLatch'),
      walkAddHinges: val('walkAddHinges'),
      woodWalkGatesAdd: val('woodWalkGatesAdd'),
      woodWalkAddType: val('woodWalkAddType'),
      woodWalkAddPostType: val('woodWalkAddPostType'),
      woodWalkAddFrameSize: val('woodWalkAddFrameSize'),
      woodWalkAddPicketWidth: val('woodWalkAddPicketWidth'),
      driveGateChainReplace: val('driveGateChainReplace'),
      driveGateOperatorReplace: val('driveGateOperatorReplace'),
      driveGateOperatorType: val('driveGateOperatorType'),
      driveGateOperatorPower: val('driveGateOperatorPower'),
      driveGateOperatorInstall: val('driveGateOperatorInstall'),
      driveGateOperatorInstallType: val('driveGateOperatorInstallType'),
      driveGateOperatorInstallPower: val('driveGateOperatorInstallPower'),
      driveGateOperatorInstallPlatform: val('driveGateOperatorInstallPlatform'),

      // NEW: finials
      finials,
      // NEW: puppy picket inserts
      puppyInserts,
      // NEW: caps
      caps,
      // NEW: panels
      panels,

      mapGenerated: card.dataset.mapGenerated === 'true',
      mapSegmentId: card.dataset.mapSegmentId || '',
      mapGeneratedLabel: card.dataset.mapGeneratedLabel || '',
      mapMeasuredLength,
      mapLengthOverride: mapLengthOverride || '',

      notes: val('notes').trim()
    };
    return sanitizeWroughtFieldsForFenceType(sectionData);
  }

  function syncStateFromDOM(){
    const cards = $$('.sp-card', sectionsEl);
    if(!cards.length) return;
    const newSections = cards.map(readSectionFromDOM);
    newSections.forEach(ns=>{
      const old = state.sections.find(s=>s.id===ns.id);
      if(old){
        if('collapsed' in old) ns.collapsed = old.collapsed;
      }
    });
    state.sections = newSections;
  }

  function writeSectionToDOM(card, data){
    function set(field, value){
      const el = card.querySelector(`[data-field="${field}"]`);
      if(!el) return;
      if(el.classList.contains('sp-number')){
        el.querySelector('input').value = value ?? '';
      } else if(el.type==='checkbox'){
        el.checked = Boolean(value);
      } else if(el.tagName==='SELECT' || el.tagName==='INPUT' || el.tagName==='TEXTAREA'){
        el.value = value ?? '';
      }
    }
    card.dataset.mapGenerated = data.mapGenerated ? 'true' : 'false';
    if(data.mapSegmentId){
      card.dataset.mapSegmentId = data.mapSegmentId;
    }else{
      delete card.dataset.mapSegmentId;
    }
    if(data.mapGeneratedLabel){
      card.dataset.mapGeneratedLabel = data.mapGeneratedLabel;
    }else{
      delete card.dataset.mapGeneratedLabel;
    }
    const mapMeasuredLength = parsePositiveInt(data.mapMeasuredLength);
    if(mapMeasuredLength){
      card.dataset.mapMeasuredLength = String(mapMeasuredLength);
    }else{
      delete card.dataset.mapMeasuredLength;
    }
    const mapLengthOverride = parsePositiveInt(data.mapLengthOverride);
    if(mapLengthOverride){
      card.dataset.mapLengthOverride = String(mapLengthOverride);
    }else{
      delete card.dataset.mapLengthOverride;
    }
    set('label', data.label||'');
    set('fenceType', data.fenceType || 'Wrought Iron');
    set('scopeType', data.scopeType||'repair');
    set('useExistingPostsForReplacement', normalizeUseExistingPostsForReplacement(data.useExistingPostsForReplacement));
    set('postInstallMethod', normalizePostInstallMethod(data.postInstallMethod));
    set('woodInstallPostSpacing', normalizeWoodInstallPostSpacing(data.woodInstallPostSpacing));
    set('woodReplacementPostSpacing', normalizeWoodReplacementPostSpacing(data.woodReplacementPostSpacing));
    set('style', data.style||SEED.style[0]);
    set('height', data.height||'4ft');
    set('postSize', data.postSize||'2x2');
    set('postSpacing', data.postSpacing||'8');
    set('panelAttachment', data.panelAttachment||'Welding');
    set('wroughtCustomStickLength', normalizeWroughtCustomStickLength(data.wroughtCustomStickLength));
    const panelFabrication = normalizeWroughtPanelFabrication(data.wroughtPanelFabrication);
    set('wroughtPanelFabrication', panelFabrication);
    set('wroughtPowderCoatPanels', false);
    set('wroughtPowderCoatPosts', false);
    set('installFinialStyle', data.installFinialStyle||SEED.finialStyles[0]);

    set('railsCount', data.railsCount || 2);
    renderRailsControls(card, data);
    renderGapAdditionsControls(card, data);
    renderDiagonalBracesControls(card, data);

    set('picketSize', data.picketSize||SEED.picketSize[0]);
    set('picketHeight', data.picketHeight||'');
    set('puppy', data.puppy||SEED.puppy[0]);
    set('puppyPicketSize', data.puppyPicketSize || data.picketSize || SEED.picketSize[0]);
    set('puppyPicketHeight', data.puppyPicketHeight || '');
    set('puppyPicketReplace', data.puppyPicketReplace || '');
    const normalizedFenceType = (data.fenceType || 'Wrought Iron').toLowerCase();
    const scopeForPaint = data.scopeType || 'repair';
    const attachmentMethod = data.panelAttachment || 'Welding';
    const defaultPainting = normalizedFenceType === 'wood'
      ? 'None'
      : (!data.painting && (scopeForPaint === 'install' || scopeForPaint === 'replace'))
        ? (attachmentMethod === 'Brackets' ? 'None' : 'Spot Paint Welds')
        : (data.painting || 'Paint Section');
    set('painting', defaultPainting);
    set('paintingApplication', data.paintingApplication || 'By Hand');
    set('paintingPrepExtra', Boolean(data.paintingPrepExtra));
    set('paintingCurrentColor', data.paintingCurrentColor || WROUGHT_CURRENT_COLOR_OPTIONS[0]);
    set('paintingTargetColor', data.paintingTargetColor || WROUGHT_PAINT_COLOR_OPTIONS[0]);
    set('woodHeight', data.woodHeight || '6ft');
    set('woodStyle', data.woodStyle || 'Side by Side');
    set('woodPicketWidth', data.woodPicketWidth || '5.5"');
    set('woodRailSize', data.woodRailSize || '2x4');
    const woodPostVal = data.woodPost || 'Round Steel';
    set('woodPost', woodPostVal);
    set('woodType', data.woodType || 'Cedar');
    set('woodFinish', data.woodFinish || 'Oil Based Stain');
    set('woodKickBoardSize', data.woodKickBoardSize || '2x6');
    set('woodKickBoardStack', data.woodKickBoardStack || '1');
    set('woodTopCapSize', data.woodTopCapSize || '2x6');
    set('woodTrimType', data.woodTrimType || '1x4');
    set('woodRepairPicketReplace', data.woodRepairPicketReplace || '');
    set('woodRepairPicketInstall', data.woodRepairPicketInstall || '');
    set('woodRepairRailReplace', data.woodRepairRailReplace || '');
    set('woodRepairRailInstall', data.woodRepairRailInstall || '');
    set('woodRepairPostReplace', data.woodRepairPostReplace || '');
    const defaultTie = defaultTieForWoodPost(woodPostVal);
    set('woodRepairPostReplaceTie', data.woodRepairPostReplaceTie || defaultTie);
    const hasPostCap = Object.prototype.hasOwnProperty.call(data, 'woodRepairPostReplaceCap');
    set('woodRepairPostReplaceCap', hasPostCap ? data.woodRepairPostReplaceCap : defaultCapForWoodPost(woodPostVal));
    set('woodRepairPostInstall', data.woodRepairPostInstall || '');
    set('woodRepairPostInstallMethod', data.woodRepairPostInstallMethod || WOOD_POST_INSTALL_METHODS[1].value);
    set('woodRepairPostInstallTie', data.woodRepairPostInstallTie || defaultTie);
    set('woodRepairPanelReplace', data.woodRepairPanelReplace || '');
    set('woodRepairPanelWidth', data.woodRepairPanelWidth || '');
    set('woodRepairWalkGateCount', data.woodRepairWalkGateCount || '');
    set('woodRepairWalkGateHinges', Boolean(data.woodRepairWalkGateHinges));
    set('woodRepairWalkGateLatch', Boolean(data.woodRepairWalkGateLatch));
    set('woodRepairWalkGateWood', Boolean(data.woodRepairWalkGateWood));
    set('woodRepairGateStrengthen', data.woodRepairGateStrengthen || '');
    set('woodRepairGateReplace', data.woodRepairGateReplace || '');
    set('woodRepairTopCapReplaceLf', data.woodRepairTopCapReplaceLf || '');
    set('woodRepairTopCapReplaceSize', data.woodRepairTopCapReplaceSize || data.woodTopCapSize || '2x6');
    set('woodRepairTrimReplaceLf', data.woodRepairTrimReplaceLf || '');
    set('woodRepairTrimReplaceSize', data.woodRepairTrimReplaceSize || data.woodTrimType || WOOD_TRIM_TYPES[1]);
    set('woodRepairKickReplaceLf', data.woodRepairKickReplaceLf || '');
    set('woodRepairKickReplaceSize', data.woodRepairKickReplaceSize || data.woodKickBoardSize || '2x6');
    set('woodRepairKickReplaceStack', data.woodRepairKickReplaceStack || data.woodKickBoardStack || '1');
    set('woodRepairStain', data.woodRepairStain || 'none');
    set('woodRepairStainBrand', normalizeWoodStainBrand(data.woodRepairStainBrand));
    set('woodAddKickBoard', Boolean(data.woodAddKickBoard));
    set('woodAddTopCap', Boolean(data.woodAddTopCap));
    set('woodAddTrim', Boolean(data.woodAddTrim));
    set('retainingWallLength', data.retainingWallLength || '');
    set('retainingWallHeight', data.retainingWallHeight || '');
    updateWoodAddonsConditional(card);
    set('length', data.length||'');
    set('hardscape', data.hardscape||'');
    set('trim', data.trim||'');
    set('digOut', data.digOut||'');
    set('wiPickets', data.wiPickets||'');
    set('weldRedos', data.weldRedos||'');
    set('walkGates', data.walkGates||'');
    set('walkGatesRealign', data.walkGatesRealign||'');
    set('walkGatesHardware', data.walkGatesHardware||'');
    set('walkGatesRebuild', data.walkGatesRebuild||'');
    set('walkLatch', data.walkLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkHinges', data.walkHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');
    set('walkRebuildFrame', data.walkRebuildFrame || SEED.railSize[0]);
    set('walkRebuildPicket', data.walkRebuildPicket || SEED.picketSize[0]);
    set('walkRebuildLatch', data.walkRebuildLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkRebuildHinges', data.walkRebuildHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');

    set('walkGatesAdd', data.walkGatesAdd||'');
    set('walkAddType', data.walkAddType || WALK_GATE_TYPES[0]);
    set('walkAddPostSize', data.walkAddPostSize || data.postSize || '2x2');
    set('walkAddFrameSize', data.walkAddFrameSize || SEED.railSize[0]);
    set('walkAddPicketSize', data.walkAddPicketSize || SEED.picketSize[0]);
    set('walkAddLatch', data.walkAddLatch || (GATE.latchTypes && GATE.latchTypes[0]) || 'Gravity Latch');
    set('walkAddHinges', data.walkAddHinges || (GATE.hingeTypes && GATE.hingeTypes[0]) || 'Door Hinges');
    const woodGateLegacyCount = normalizedFenceType === 'wood' ? (data.walkGatesAdd || '') : '';
    const hasWoodGateCount = Object.prototype.hasOwnProperty.call(data, 'woodWalkGatesAdd');
    set('woodWalkGatesAdd', hasWoodGateCount ? data.woodWalkGatesAdd : woodGateLegacyCount);
    set('woodWalkAddType', data.woodWalkAddType || data.walkAddType || WALK_GATE_TYPES[0]);
    set('woodWalkAddPostType', normalizeWoodGatePostType(data.woodWalkAddPostType || data.walkAddPostSize || data.woodPost || WOOD_GATE_POST_TYPES[1]));
    set('woodWalkAddFrameSize', normalizeWoodGateFrameSize(data.woodWalkAddFrameSize || data.walkAddFrameSize || data.woodRailSize || WOOD_RAIL_SIZES[1]));
    set('woodWalkAddPicketWidth', normalizeWoodGatePicketWidth(data.woodWalkAddPicketWidth || data.walkAddPicketSize || data.woodPicketWidth || WOOD_PICKET_WIDTHS[2]));
    set('driveGateChainReplace', data.driveGateChainReplace || '');
    set('driveGateOperatorReplace', data.driveGateOperatorReplace || '');
    set('driveGateOperatorType', data.driveGateOperatorType || DRIVE_GATE_OPERATOR_TYPES[0]);
    set('driveGateOperatorPower', data.driveGateOperatorPower || DRIVE_GATE_POWER_TYPES[0]);
    set('driveGateOperatorInstall', data.driveGateOperatorInstall || '');
    set('driveGateOperatorInstallType', data.driveGateOperatorInstallType || DRIVE_GATE_OPERATOR_TYPES[0]);
    const installPower = DRIVE_GATE_POWER_TYPES_INSTALL.includes(data.driveGateOperatorInstallPower)
      ? data.driveGateOperatorInstallPower
      : DRIVE_GATE_POWER_TYPES_INSTALL[0];
    set('driveGateOperatorInstallPower', installPower);
    set('driveGateOperatorInstallPlatform', Boolean(data.driveGateOperatorInstallPlatform));

    set('notes', data.notes||'');

    // NEW: render post groups
    renderPostReplacementControls(card, data);
    renderPostRealignControls(card, data);
    renderWoodPostRealignControls(card, data);
    // NEW: render finial rows
    renderFinialsControls(card, data);
    renderPuppyInsertControls(card, data);
    // NEW: render cap rows
    renderCapsControls(card, data);
    // NEW: render panel rows
    renderPanelsControls(card, data);
    const toggleBtn = card.querySelector('.sp-toggle');
    const isCollapsed = Boolean(data.collapsed);
    card.classList.toggle('is-collapsed', isCollapsed);
    if(toggleBtn){
      toggleBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      toggleBtn.setAttribute('aria-expanded', (!isCollapsed).toString());
    }
  }
  // === NEW: cap row rendering & persistence ===
  function renderPostGroups(card, data, cfg){
    const cont = card.querySelector(cfg.container);
    if(!cont) return;
    cont.innerHTML = '';
    const options = Array.isArray(cfg.options) && cfg.options.length ? cfg.options : SEED.postSize;
    const arr = Array.isArray(data[cfg.prop]) ? data[cfg.prop] : [];

    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute(cfg.rowAttr, '');
      row.innerHTML = `
        <div class="sp-field col-3">
          <label class="sp-label">Qty</label>
          <div class="sp-number" ${cfg.qtyAttr}>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Post Size</label>
          <select class="sp-select" ${cfg.sizeAttr}>${createSelect(options)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" ${cfg.removeAttr} type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector(cfg.sizeSel);
      if(sizeSel){
        sizeSel.value = item.size || options[0];
      }
    });

    const addBtn = card.querySelector(cfg.addBtn);
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s[cfg.prop])) s[cfg.prop] = [];
        const defaultSize = typeof cfg.defaultSize === 'function'
          ? cfg.defaultSize(s)
          : cfg.defaultSize;
        const nextSize = defaultSize || options[0] || '';
        s[cfg.prop].push({ qty: 1, size: nextSize });
        renderPostGroups(card, s, cfg);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest(cfg.removeSel);
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll(cfg.rowSel));
      const row = btn.closest(cfg.rowSel);
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s[cfg.prop])) return;
      if(idx >= 0){
        s[cfg.prop].splice(idx,1);
        renderPostGroups(card, s, cfg);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches(cfg.sizeSel)){
        persistPostGroupsFromDOM(card, cfg);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest(cfg.qtySel)){
        persistPostGroupsFromDOM(card, cfg);
        persist();
      }
    });
    updateMapControlsUI();
  }

  function persistPostGroupsFromDOM(card, cfg){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector(cfg.container);
    const rows = cont ? Array.from(cont.querySelectorAll(cfg.rowSel)) : [];
    const options = Array.isArray(cfg.options) && cfg.options.length ? cfg.options : SEED.postSize;
    s[cfg.prop] = rows.map(row=>{
      const qty = parseInt((row.querySelector(`${cfg.qtySel} input`)?.value)||'0',10) || 0;
      const size = (row.querySelector(cfg.sizeSel)?.value) || options[0] || '';
      return { qty, size };
    });
  }

  function persistPostRealignmentsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-post-realign]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-post-realign-row]')) : [];
    s.postRealignments = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-post-realign-qty] input')?.value)||'0',10) || 0;
      const rawMethod = (row.querySelector('[data-post-realign-method]')?.value) || 'concrete';
      const method = rawMethod === 'cut-weld' ? 'cut-weld' : 'concrete';
      const size = (row.querySelector('[data-post-realign-size]')?.value) || SEED.postRealignSize[0] || '';
      return { qty, method, size };
    });
  }

  function persistWoodPostRealignmentsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-wood-post-realign]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-wood-post-realign-row]')) : [];
    s.woodPostRealignments = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-wood-post-realign-qty] input')?.value)||'0',10) || 0;
      const method = (row.querySelector('[data-wood-post-realign-method]')?.value) || 'dig-straighten';
      return { qty, method };
    });
  }

  function renderPostReplacementControls(card, data){
    renderPostGroups(card, data, {
      prop: 'postReplacements',
      container: '[data-post-replacements]',
      rowAttr: 'data-post-replacement-row',
      rowSel: '[data-post-replacement-row]',
      qtyAttr: 'data-post-replacement-qty',
      qtySel: '[data-post-replacement-qty]',
      sizeAttr: 'data-post-replacement-size',
      sizeSel: '[data-post-replacement-size]',
      removeAttr: 'data-post-replacement-remove',
      removeSel: '[data-post-replacement-remove]',
      addBtn: '[data-post-replacement-add]',
      options: SEED.postSize,
      defaultSize: (section)=> section.postSize || SEED.postSize[0]
    });
  }

  function updatePostRealignRowState(row){
    if(!row) return;
    const methodSel = row.querySelector('[data-post-realign-method]');
    const sizeWrap = row.querySelector('[data-post-realign-size-wrap]');
    const sizeSel = row.querySelector('[data-post-realign-size]');
    const method = (methodSel?.value) || 'concrete';
    const isCutWeld = method === 'cut-weld';
    if(sizeWrap){
      sizeWrap.style.display = isCutWeld ? 'none' : '';
    }
    if(sizeSel){
      sizeSel.disabled = isCutWeld;
    }
  }

  function renderPostRealignControls(card, data){
    const cont = card.querySelector('[data-post-realign]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.postRealignments) ? data.postRealignments : [];
    const methodOptions = POST_REALIGN_METHODS.map(opt=>`<option value="${escapeAttr(opt.value)}">${escapeHtml(opt.label)}</option>`).join('');

    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-post-realign-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-post-realign-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Method</label>
          <select class="sp-select" data-post-realign-method>${methodOptions}</select>
        </div>
        <div class="sp-field col-4" data-post-realign-size-wrap>
          <label class="sp-label">Post Size</label>
          <select class="sp-select" data-post-realign-size>${createSelect(SEED.postRealignSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-post-realign-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const methodSel = row.querySelector('[data-post-realign-method]');
      if(methodSel){
        const normalized = String(item.method || 'concrete').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'concrete';
        methodSel.value = normalized;
      }
      const sizeSel = row.querySelector('[data-post-realign-size]');
      if(sizeSel){ sizeSel.value = item.size || SEED.postRealignSize[0]; }
      updatePostRealignRowState(row);
    });

    const addBtn = card.querySelector('[data-post-realign-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.postRealignments)) s.postRealignments = [];
        const defaultSize = SEED.postRealignSize[0] || '2x2';
        s.postRealignments.push({ qty: 1, size: defaultSize, method: 'concrete' });
        renderPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-post-realign-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-post-realign-row]'));
      const row = btn.closest('[data-post-realign-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.postRealignments)) return;
      if(idx >= 0){
        s.postRealignments.splice(idx,1);
        renderPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      const methodSel = e.target.closest('[data-post-realign-method]');
      const sizeSel = e.target.closest('[data-post-realign-size]');
      if(methodSel){
        const row = methodSel.closest('[data-post-realign-row]');
        updatePostRealignRowState(row);
        persistPostRealignmentsFromDOM(card);
        persist();
      } else if(sizeSel){
        persistPostRealignmentsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-post-realign-qty]')){
        persistPostRealignmentsFromDOM(card);
        persist();
      }
    });
  }

  function renderWoodPostRealignControls(card, data){
    const cont = card.querySelector('[data-wood-post-realign]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.woodPostRealignments) ? data.woodPostRealignments : [];
    const fallbackDig = parseInt(data.woodRepairPostRealignDig || 0, 10) || 0;
    const fallbackCut = parseInt(data.woodRepairPostRealignCutWeld || 0, 10) || 0;
    if(!arr.length && (fallbackDig || fallbackCut)){
      const temp = [];
      if(fallbackDig){ temp.push({ qty: fallbackDig, method: 'dig-straighten' }); }
      if(fallbackCut){ temp.push({ qty: fallbackCut, method: 'cut-weld' }); }
      data.woodPostRealignments = temp;
    }

    const methodOptions = WOOD_POST_METHODS.map(opt=>`<option value="${escapeAttr(opt.value)}">${escapeHtml(opt.label)}</option>`).join('');

    data.woodPostRealignments.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-wood-post-realign-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-wood-post-realign-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-6">
          <label class="sp-label">Method</label>
          <select class="sp-select" data-wood-post-realign-method>${methodOptions}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-wood-post-realign-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const methodSel = row.querySelector('[data-wood-post-realign-method]');
      if(methodSel){
        const normalized = String(item.method || 'dig-straighten').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'dig-straighten';
        methodSel.value = normalized;
      }
    });

    const addBtn = card.querySelector('[data-wood-post-realign-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.woodPostRealignments)) s.woodPostRealignments = [];
        s.woodPostRealignments.push({ qty: 1, method: 'dig-straighten' });
        renderWoodPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-wood-post-realign-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-wood-post-realign-row]'));
      const row = btn.closest('[data-wood-post-realign-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.woodPostRealignments)) return;
      if(idx >= 0){
        s.woodPostRealignments.splice(idx,1);
        renderWoodPostRealignControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.closest('[data-wood-post-realign-method]')){
        persistWoodPostRealignmentsFromDOM(card);
        persist();
        updateWoodRepairControls(card);
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-wood-post-realign-qty]')){
        persistWoodPostRealignmentsFromDOM(card);
        persist();
      }
    });
  }

  const POST_SIZE_KEY = {
    '1 1/2" x 1 1/2"': 'posts1p5',
    '2x2': 'posts2x2',
    '3x3': 'posts3x3',
    '4x4': 'posts4x4'
  };
  const POST_KEY_LABEL = {
    posts1p5: '1 1/2" x 1 1/2"',
    posts2x2: '2x2',
    posts3x3: '3x3',
    posts4x4: '4x4'
  };
  const CAP_LABEL_RE = /^caps - (.+?) - (.+?) \((.+?)\)$/; // material, style, postSize

  function postSizeKey(size){
    const raw = String(size||'').trim();
    if(POST_SIZE_KEY[raw]) return POST_SIZE_KEY[raw];
    const compact = raw
      .toLowerCase()
      .replace(/×/g,'x')
      .replace(/\s+/g,'')
      .replace(/inch|\"/g,'');
    if(compact === '11/2x11/2' || compact === '1.5x1.5') return 'posts1p5';
    if(compact === '2x2') return 'posts2x2';
    if(compact === '3x3') return 'posts3x3';
    if(compact === '4x4') return 'posts4x4';
    return null;
  }

  function countPostGroupsByMethod(arr, method='concrete'){
    const counts = { posts1p5:0, posts2x2:0, posts3x3:0, posts4x4:0 };
    const targetMethod = String(method || 'concrete').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'concrete';
    (Array.isArray(arr) ? arr : []).forEach(item=>{
      const qty = parseInt(item?.qty,10) || 0;
      if(qty <= 0) return;
      const itemMethod = String(item?.method || 'concrete').toLowerCase() === 'cut-weld' ? 'cut-weld' : 'concrete';
      if(itemMethod !== targetMethod) return;
      const key = postSizeKey(item?.size || item?.postSize || SEED.postRealignSize[0] || '');
      if(key && Object.prototype.hasOwnProperty.call(counts, key)){
        counts[key] += qty;
      }
    });
    return counts;
  }

  function countPostGroups(arr){
    return countPostGroupsByMethod(arr, 'concrete');
  }

  function postKeyToLabel(key){
    return POST_KEY_LABEL[key] || '';
  }

  function countRealignCutWeld(arr){
    let total = 0;
    (Array.isArray(arr) ? arr : []).forEach(item=>{
      const qty = parseInt(item?.qty,10) || 0;
      if(qty <= 0) return;
      if((item?.method || 'concrete') === 'cut-weld'){
        total += qty;
      }
    });
    return total;
  }

  function normalizePostInstallMethod(value){
    const raw = String(value == null ? '' : value).trim().toLowerCase();
    if(
      raw === 'anchored' ||
      raw === 'anchor' ||
      raw === 'anchor-to-concrete' ||
      raw === 'anchor to concrete' ||
      raw === 'surface-anchor' ||
      raw === 'surface anchor'
    ){
      return 'anchored';
    }
    return 'dig-set-concrete';
  }

  function postInstallMethodLabel(value){
    return normalizePostInstallMethod(value) === 'anchored'
      ? 'Anchor to Concrete'
      : 'Dig and Set in Concrete';
  }

  function normalizeUseExistingPostsForReplacement(value){
    if(value === true) return 'yes';
    const raw = String(value == null ? '' : value).trim().toLowerCase();
    if(raw === 'yes' || raw === 'true' || raw === '1' || raw === 'y'){
      return 'yes';
    }
    return 'no';
  }

  function shouldUseExistingPostsForReplacement(section){
    if(!section) return false;
    const scopeType = String(section.scopeType || '').toLowerCase();
    if(scopeType !== 'replace') return false;
    return normalizeUseExistingPostsForReplacement(section.useExistingPostsForReplacement) === 'yes';
  }

  function normalizeWoodInstallPostSpacing(value){
    const raw = String(value == null ? '' : value).trim().toLowerCase();
    if(raw === '6' || raw === '6ft' || raw === '6 ft'){
      return '6';
    }
    return '8';
  }

  function woodInstallPostSpacingFt(section){
    if(!section) return 8;
    return parseInt(normalizeWoodInstallPostSpacing(section.woodInstallPostSpacing), 10) || 8;
  }

  function normalizeWoodReplacementPostSpacing(value){
    const raw = String(value == null ? '' : value).trim().toLowerCase();
    if(raw === '6' || raw === '6ft' || raw === '6 ft'){
      return '6';
    }
    return '8';
  }

  function woodReplacementPostSpacingFt(section){
    if(!section) return 8;
    return parseInt(normalizeWoodReplacementPostSpacing(section.woodReplacementPostSpacing), 10) || 8;
  }

  function woodInstallRailLengthFt(section){
    if(!section) return 8;
    const scopeType = String(section.scopeType || 'repair').toLowerCase();
    if(scopeType !== 'install' && scopeType !== 'replace'){
      return 8;
    }
    const useExistingPostsForReplacement = shouldUseExistingPostsForReplacement(section);
    if(!useExistingPostsForReplacement){
      return 8;
    }
    const replacementPostSpacingFt = woodReplacementPostSpacingFt(section);
    const isRoundSteel = isRoundSteelPost(section.woodPost || '');
    return (replacementPostSpacingFt === 6 && isRoundSteel) ? 12 : 8;
  }

  function woodInstallRailLengthsForSections(sections){
    const lengths = new Set();
    const list = Array.isArray(sections) ? sections : [];
    list.forEach(section=>{
      if((section?.fenceType || '').toLowerCase() !== 'wood') return;
      const scopeType = String(section?.scopeType || 'repair').toLowerCase();
      if(scopeType !== 'install' && scopeType !== 'replace') return;
      const sectionLengthFt = Math.max(0, parseFloat(section?.length || 0) || 0);
      if(sectionLengthFt <= 0) return;
      lengths.add(woodInstallRailLengthFt(section));
    });
    return Array.from(lengths)
      .map(value=>parseFloat(value))
      .filter(value=>isFinite(value) && value > 0)
      .sort((a,b)=>a-b);
  }

  function woodInstallRailLabelFromLengths(lengths){
    const ordered = Array.isArray(lengths) ? lengths : [];
    const formatLength = (value)=>{
      const num = parseFloat(value);
      if(!isFinite(num) || num <= 0) return '';
      if(Math.abs(num - Math.round(num)) < 0.001){
        return String(Math.round(num));
      }
      return num.toFixed(2).replace(/\.?0+$/, '');
    };
    const joinLabels = (items)=>{
      const list = Array.isArray(items) ? items.filter(Boolean) : [];
      if(!list.length) return '';
      if(list.length === 1) return list[0];
      if(list.length === 2) return `${list[0]} and ${list[1]}`;
      return `${list.slice(0, -1).join(', ')}, and ${list[list.length - 1]}`;
    };
    if(!ordered.length) return 'wood rails';
    if(ordered.length === 1){
      return `${formatLength(ordered[0])}ft wood rails`;
    }
    const labels = ordered.map(value=> `${formatLength(value)}ft`).filter(Boolean);
    return `wood rails (${joinLabels(labels)})`;
  }

  function addPostCounts(target, counts){
    Object.keys(counts).forEach(key=>{
      target[key] = (target[key]||0) + (parseInt(counts[key],10) || 0);
    });
  }

  function renderCapsControls(card, data){
    const cont = card.querySelector('[data-caps]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.caps) ? data.caps : [];
    arr.forEach((c)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-cap-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-cap-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${c.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-cap-style>${createSelect(SEED.capStyles)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Material</label>
          <select class="sp-select" data-cap-material>${createSelect(SEED.capMaterials)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Post Size</label>
          <select class="sp-select" data-cap-post>${createSelect(SEED.capPostSizes)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-cap-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const styleSel = row.querySelector('[data-cap-style]'); if(styleSel) styleSel.value = c.style || SEED.capStyles[0];
      const matSel   = row.querySelector('[data-cap-material]'); if(matSel) matSel.value = c.material || SEED.capMaterials[0];
      const postSel  = row.querySelector('[data-cap-post]'); if(postSel) postSel.value = c.postSize || SEED.capPostSizes[0];
    });

    const addBtn = card.querySelector('[data-cap-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.caps)) s.caps = [];
        s.caps.push({ qty: 1, style: SEED.capStyles[0], material: SEED.capMaterials[0], postSize: SEED.capPostSizes[0] });
        renderCapsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-cap-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-cap-row]'));
      const row = btn.closest('[data-cap-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.caps)) return;
      s.caps.splice(idx,1);
      renderCapsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-cap-style], [data-cap-material], [data-cap-post]')){
        persistCapsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-cap-qty]')){
        persistCapsFromDOM(card);
        persist();
      }
    });
  }

  function persistCapsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-caps]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-cap-row]')) : [];
    s.caps = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-cap-qty] input')?.value)||'0',10) || 0;
      const style = (row.querySelector('[data-cap-style]')?.value) || SEED.capStyles[0];
      const material = (row.querySelector('[data-cap-material]')?.value) || SEED.capMaterials[0];
      const postSize = (row.querySelector('[data-cap-post]')?.value) || SEED.capPostSizes[0];
      return { qty, style, material, postSize };
    });
  }

  // ===== Rails helpers/handlers =====
  function railLabels(count){
    const n = parseInt(count||2,10);
    if(n===4) return ['Top Rail','Second Rail','Third Rail','Bottom Rail'];
    if(n===3) return ['Top Rail','Middle Rail','Bottom Rail'];
    return ['Top Rail','Bottom Rail'];
  }

  function sectionRailSizes(section){
    const sizes = new Set();
    const rails = Array.isArray(section?.rails) ? section.rails : [];
    const count = section?.railsCount || rails.length;
    for(let i=0;i<count;i++){
      const r = rails[i] || {};
      if(r.size) sizes.add(r.size);
      if(r.stacked && r.size2) sizes.add(r.size2);
    }
    const gaps = Array.isArray(section?.gapAdditions) ? section.gapAdditions : [];
    gaps.forEach(g=>{ if(g && g.size) sizes.add(g.size); });
    if(!sizes.size){
      if(section?.railSize) sizes.add(section.railSize);
      if(section?.railStacked && section?.railSize2) sizes.add(section.railSize2);
    }
    return Array.from(sizes).filter(Boolean);
  }

  function renderRailsControls(card, data){
    const row  = card.querySelector('[data-rails-row]');
    const repairRow = card.querySelector('[data-rail-repair-row]');
    if(!row) return;
    $$('[data-rail-block]', row).forEach(el=> el.remove());
    if(repairRow) $$('[data-rail-block]', repairRow).forEach(el=> el.remove());
    const count = parseInt((data.railsCount!=null?data.railsCount:2),10);
    const labels = railLabels(count);
    const rails = Array.isArray(data.rails) ? data.rails : [];
    row.style.setProperty('--rail-cols', `repeat(${count+1}, minmax(200px, 1fr))`);
    if(repairRow){
      repairRow.style.setProperty('--rail-cols', `repeat(${count}, minmax(200px, 1fr))`);
    }
    labels.forEach((label,i)=>{
      const block = document.createElement('div');
      block.className = `sp-field`;
      block.setAttribute('data-rail-block','');
      const patchesHtml = numberControl('railPatches_'+i,'0');
      const replHtml    = numberControl('railRepl_'+i,'0');
      block.innerHTML = `
        <label class="sp-label">${label} Size</label>
        <select class="sp-select" data-field="railSize_${i}">${createSelect(SEED.railSize)}</select>
        <div class="sp-row" style="margin-top:6px">
          <label class="sp-row" style="gap:6px; align-items:center">
            <input type="checkbox" data-field="railStacked_${i}" />
            <span>Stacked</span>
          </label>
        </div>
        <div class="sp-field" data-if="railStacked_${i}" style="display:none; margin-top:6px">
          <label class="sp-label">Second ${label} Size</label>
          <select class="sp-select" data-field="railSize2_${i}">${createSelect(SEED.railSize)}</select>
        </div>
      `;
      row.appendChild(block);
      if(repairRow){
        const repairBlock = document.createElement('div');
        repairBlock.className = 'sp-field';
        repairBlock.setAttribute('data-rail-block','');
        repairBlock.innerHTML = `
          <label class="sp-label">${label} Repairs</label>
          <div class="sp-field" data-rail-repair style="margin-top:6px">
            <label class="sp-label"># Rail Patches (${label})</label>
            ${patchesHtml}
          </div>
          <div class="sp-field" data-rail-repair style="margin-top:6px">
            <label class="sp-label"># Full Rail Replacements (${label})</label>
            ${replHtml}
          </div>
        `;
        repairRow.appendChild(repairBlock);
      }
      const r = rails[i] || {};
      const sizeEl    = card.querySelector(`[data-field="railSize_${i}"]`);
      const stackEl   = card.querySelector(`[data-field="railStacked_${i}"]`);
      const size2El   = card.querySelector(`[data-field="railSize2_${i}"]`);
      const patchesBox= card.querySelector(`[data-field="railPatches_${i}"]`);
      const replBox   = card.querySelector(`[data-field="railRepl_${i}"]`);
      if(sizeEl) sizeEl.value = r.size || SEED.railSize[0];
      if(stackEl) stackEl.checked = Boolean(r.stacked);
      if(size2El) size2El.value = r.size2 || SEED.railSize[0];
      if(patchesBox) patchesBox.querySelector('input').value = r.patches || 0;
      if(replBox)    replBox.querySelector('input').value    = r.replacements || 0;
      const cond = card.querySelector(`[data-if="railStacked_${i}"]`);
      if(cond && stackEl) cond.style.display = stackEl.checked ? 'block' : 'none';
    });
  }

  function renderGapAdditionsControls(card, data){
    const cont = card.querySelector('[data-gap-additions]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.gapAdditions) ? data.gapAdditions : [];
    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-gap-addition-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-gap-addition-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-gap-addition-size>${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-gap-addition-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-gap-addition-size]');
      if(sizeSel) sizeSel.value = item.size || SEED.railSize[0];
    });

    const addBtn = card.querySelector('[data-gap-addition-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.gapAdditions)) s.gapAdditions = [];
        s.gapAdditions.push({ qty:1, size: SEED.railSize[0] });
        renderGapAdditionsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-gap-addition-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-gap-addition-row]'));
      const row = btn.closest('[data-gap-addition-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.gapAdditions)) return;
      s.gapAdditions.splice(idx,1);
      renderGapAdditionsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-gap-addition-size]')){
        persistGapAdditionsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-gap-addition-qty]')){
        persistGapAdditionsFromDOM(card);
        persist();
      }
    });
  }

  function persistGapAdditionsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-gap-additions]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-gap-addition-row]')) : [];
    s.gapAdditions = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-gap-addition-qty] input')?.value)||'0',10) || 0;
      const size = (row.querySelector('[data-gap-addition-size]')?.value) || SEED.railSize[0];
      return { qty, size };
    });
  }

  function renderDiagonalBracesControls(card, data){
    const cont = card.querySelector('[data-diagonal-braces]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.diagonalBraces) ? data.diagonalBraces : [];
    arr.forEach(item => {
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-diagonal-brace-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-diagonal-brace-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Brace Size</label>
          <select class="sp-select" data-diagonal-brace-size>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-diagonal-brace-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-diagonal-brace-size]');
      if(sizeSel) sizeSel.value = item.size || SEED.picketSize[0];
    });

    const addBtn = card.querySelector('[data-diagonal-brace-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.diagonalBraces)) s.diagonalBraces = [];
        const defaultSize = s.picketSize || SEED.picketSize[0];
        s.diagonalBraces.push({ qty:1, size: defaultSize });
        renderDiagonalBracesControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-diagonal-brace-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-diagonal-brace-row]'));
      const row = btn.closest('[data-diagonal-brace-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.diagonalBraces)) return;
      s.diagonalBraces.splice(idx,1);
      renderDiagonalBracesControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-diagonal-brace-size]')){
        persistDiagonalBracesFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-diagonal-brace-qty]')){
        persistDiagonalBracesFromDOM(card);
        persist();
      }
    });
  }

  function persistDiagonalBracesFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-diagonal-braces]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-diagonal-brace-row]')) : [];
    s.diagonalBraces = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-diagonal-brace-qty] input')?.value)||'0',10) || 0;
      const size = (row.querySelector('[data-diagonal-brace-size]')?.value) || SEED.picketSize[0];
      return { qty, size };
    });
  }

  // === NEW: finial row rendering & persistence ===
  // === PANEL REPLACEMENTS: row rendering & persistence ===
  function renderPanelsControls(card, data){
    const cont = card.querySelector('[data-panels]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.panels) ? data.panels : [];

    arr.forEach((p)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-panel-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-panel-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${p.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Height</label>
          <select class="sp-select" data-panel-height>${createSelect(SEED.height)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-panel-style>${createSelect(PANEL_REPLACEMENT_STYLES)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Rail Size</label>
          <select class="sp-select" data-panel-rail>${createSelect(SEED.railSize)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-panel-picket>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-2">
          <label class="sp-label">Panel Width (in)</label>
          <div class="sp-number" data-panel-width>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="1" value="${p.widthIn||96}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3" data-panel-finial-wrap style="display:none">
          <label class="sp-label">Finial Style (26 / panel)</label>
          <select class="sp-select" data-panel-finial-style>${createSelect(SEED.finialStyles)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-panel-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);

      // set defaults
      row.querySelector('[data-panel-height]').value = p.height || SEED.height[1];
      row.querySelector('[data-panel-style]').value  = p.style  || SEED.style[0];
      row.querySelector('[data-panel-rail]').value   = p.railSize || SEED.railSize[0];
      row.querySelector('[data-panel-picket]').value = p.picketSize || SEED.picketSize[0];
      const finWrap = row.querySelector('[data-panel-finial-wrap]');
      const styleSel = row.querySelector('[data-panel-style]');
      const finSel = row.querySelector('[data-panel-finial-style]');
      if(styleSel){
        const show = /Finials/i.test(styleSel.value);
        finWrap.style.display = show ? 'block' : 'none';
      }
      if(finSel){ finSel.value = p.finialStyle || SEED.finialStyles[0]; }
    });

    const addBtn = card.querySelector('[data-panel-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.panels)) s.panels = [];
        s.panels.push({ qty:1, height: SEED.height[1], style: SEED.style[0], railSize: SEED.railSize[0], picketSize: SEED.picketSize[0], widthIn: 96, finialStyle: ''});
        renderPanelsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-panel-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-panel-row]'));
      const row = btn.closest('[data-panel-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.panels)) return;
      s.panels.splice(idx,1);
      renderPanelsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-panel-style], [data-panel-height], [data-panel-rail], [data-panel-picket], [data-panel-finial-style]')){
        // Toggle finial picker visibility
        if(e.target.matches('[data-panel-style]')){
          const wrap = e.target.closest('[data-panel-row]').querySelector('[data-panel-finial-wrap]');
          const show = /Finials/i.test(e.target.value);
          wrap.style.display = show ? 'block' : 'none';
          if(show){
            const finSel = wrap.querySelector('[data-panel-finial-style]');
            if(finSel && !finSel.value){ finSel.value = SEED.finialStyles[0]; }
          }
        }
        persistPanelsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-panel-qty]') || e.target.closest('[data-panel-width]')){
        persistPanelsFromDOM(card);
        persist();
      }
    });
  }

  function persistPanelsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-panels]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-panel-row]')) : [];
    s.panels = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-panel-qty] input')?.value)||'0',10) || 0;
      const height = (row.querySelector('[data-panel-height]')?.value) || SEED.height[1];
      const style  = (row.querySelector('[data-panel-style]')?.value) || SEED.style[0];
      const railSize = (row.querySelector('[data-panel-rail]')?.value) || SEED.railSize[0];
      const picketSize = (row.querySelector('[data-panel-picket]')?.value) || SEED.picketSize[0];
      const widthIn = parseInt((row.querySelector('[data-panel-width] input')?.value)||'0',10) || 0;
      const hasFinials = /Finials/i.test(style);
      const finialStyle = hasFinials
        ? ((row.querySelector('[data-panel-finial-style]')?.value) || SEED.finialStyles[0])
        : '';
      return { qty, height, style, railSize, picketSize, widthIn, finialStyle };
    });
  }
  function renderFinialsControls(card, data){
    const cont = card.querySelector('[data-finials]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.finials) ? data.finials : [];
    arr.forEach((f)=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-finial-row','');
      row.innerHTML = `
        <div class="sp-field col-2">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-finial-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${f.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Style</label>
          <select class="sp-select" data-finial-style>${createSelect(SEED.finialStyles)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Material</label>
          <select class="sp-select" data-finial-material>${createSelect(SEED.finialMaterials)}</select>
        </div>
        <div class="sp-field col-3">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-finial-picket>${createSelect(SEED.picketSize)}</select>
        </div>
        <div class="sp-field col-1" style="align-self:end">
          <button class="sp-btn danger" data-finial-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const styleSel = row.querySelector('[data-finial-style]'); if(styleSel) styleSel.value = f.style || SEED.finialStyles[0];
      const matSel   = row.querySelector('[data-finial-material]'); if(matSel)  matSel.value  = f.material || SEED.finialMaterials[0];
      const pickSel  = row.querySelector('[data-finial-picket]'); if(pickSel)   pickSel.value = f.picketSize || SEED.picketSize[0];
    });

    const addBtn = card.querySelector('[data-finial-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.finials)) s.finials = [];
        s.finials.push({ qty: 1, style: SEED.finialStyles[0], material: SEED.finialMaterials[0], picketSize: s.picketSize || SEED.picketSize[0] });
        renderFinialsControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-finial-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-finial-row]'));
      const row = btn.closest('[data-finial-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.finials)) return;
      s.finials.splice(idx,1);
      renderFinialsControls(card, s);
      attachNumberHandlers(card);
      persist();
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-finial-style], [data-finial-material], [data-finial-picket]')){
        persistFinialsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-finial-qty]')){
        persistFinialsFromDOM(card);
        persist();
      }
    });
  }

  function renderPuppyInsertControls(card, data){
    const cont = card.querySelector('[data-puppy-inserts]');
    if(!cont) return;
    cont.innerHTML = '';
    const arr = Array.isArray(data.puppyInserts) ? data.puppyInserts : [];
    arr.forEach(item=>{
      const row = document.createElement('div');
      row.className = 'sp-grid';
      row.setAttribute('data-puppy-insert-row','');
      row.innerHTML = `
        <div class="sp-field col-3">
          <label class="sp-label">Qty</label>
          <div class="sp-number" data-puppy-insert-qty>
            <button type="button" class="sp-step" data-dir="-1" aria-label="decrement">–</button>
            <input type="number" inputmode="numeric" step="1" min="0" value="${item.qty||0}" />
            <button type="button" class="sp-step" data-dir="1" aria-label="increment">+</button>
          </div>
        </div>
        <div class="sp-field col-4">
          <label class="sp-label">Picket Size</label>
          <select class="sp-select" data-puppy-insert-size>${createSelect(PUPPY_INSERT_SIZES)}</select>
        </div>
        <div class="sp-field col-2" style="align-self:end">
          <button class="sp-btn danger" data-puppy-insert-remove type="button">Remove</button>
        </div>`;
      cont.appendChild(row);
      const sizeSel = row.querySelector('[data-puppy-insert-size]');
      const normalized = normalizeSize(item.picketSize);
      const preferred = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
      if(sizeSel){ sizeSel.value = preferred; }
    });

    const addBtn = card.querySelector('[data-puppy-insert-add]');
    if(addBtn){
      addBtn.onclick = ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId);
        if(!s) return;
        if(!Array.isArray(s.puppyInserts)) s.puppyInserts = [];
        const normalized = normalizeSize(s.picketSize);
        const defaultSize = PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
        s.puppyInserts.push({ qty: 1, picketSize: defaultSize });
        renderPuppyInsertControls(card, s);
        attachNumberHandlers(card);
        persist();
      };
    }

    cont.addEventListener('click', (e)=>{
      const btn = e.target.closest('[data-puppy-insert-remove]');
      if(!btn) return;
      const rows = Array.from(cont.querySelectorAll('[data-puppy-insert-row]'));
      const row = btn.closest('[data-puppy-insert-row]');
      const idx = rows.indexOf(row);
      const secId = card.getAttribute('data-id');
      const s = state.sections.find(x=>x.id===secId);
      if(!s || !Array.isArray(s.puppyInserts)) return;
      if(idx>=0){
        s.puppyInserts.splice(idx,1);
        renderPuppyInsertControls(card, s);
        attachNumberHandlers(card);
        persist();
      }
    });

    cont.addEventListener('change', (e)=>{
      if(e.target.matches('[data-puppy-insert-size]')){
        persistPuppyInsertsFromDOM(card);
        persist();
      }
    });

    cont.addEventListener('input', (e)=>{
      if(e.target.closest('[data-puppy-insert-qty]')){
        persistPuppyInsertsFromDOM(card);
        persist();
      }
    });
  }

  function persistPuppyInsertsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-puppy-inserts]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-puppy-insert-row]')) : [];
    s.puppyInserts = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-puppy-insert-qty] input')?.value)||'0',10) || 0;
      let picketSize = (row.querySelector('[data-puppy-insert-size]')?.value) || PUPPY_INSERT_SIZES[0];
      const normalized = normalizeSize(picketSize);
      if(PUPPY_INSERT_SIZES.includes(normalized)){
        picketSize = normalized;
      } else {
        picketSize = PUPPY_INSERT_SIZES[0];
      }
      return { qty, picketSize };
    });
  }

  function persistFinialsFromDOM(card){
    const secId = card.getAttribute('data-id');
    const s = state.sections.find(x=>x.id===secId);
    if(!s) return;
    const cont = card.querySelector('[data-finials]');
    const rows = cont ? Array.from(cont.querySelectorAll('[data-finial-row]')) : [];
    s.finials = rows.map(row=>{
      const qty = parseInt((row.querySelector('[data-finial-qty] input')?.value)||'0',10) || 0;
      const style = (row.querySelector('[data-finial-style]')?.value) || SEED.finialStyles[0];
      const material = (row.querySelector('[data-finial-material]')?.value) || SEED.finialMaterials[0];
      const picketSize = (row.querySelector('[data-finial-picket]')?.value) || SEED.picketSize[0];
      return { qty, style, material, picketSize };
    });
  }

  function attachRailsHandlers(card){
    const countSel = card.querySelector('[data-field="railsCount"]');
    if(countSel){
      countSel.addEventListener('change', ()=>{
        const secId = card.getAttribute('data-id');
        const s = state.sections.find(x=>x.id===secId) || {};
        const newCount = parseInt(countSel.value||'2',10);
        s.railsCount = newCount;
        if(!Array.isArray(s.rails)) s.rails = [];
        const labels = railLabels(newCount);
        s.rails = labels.map((_, i)=> s.rails[i] || { size: SEED.railSize[0], stacked:false, size2:SEED.railSize[0], patches:0, replacements:0 });
        renderRailsControls(card, s);
        renderGapAdditionsControls(card, s);
        renderDiagonalBracesControls(card, s);
        attachNumberHandlers(card);
        persist();
      });
    }

    card.addEventListener('change', (e)=>{
      const t = e.target;
      if(!t) return;
      if(t.matches('input[data-field^="railStacked_"]')){
        const key = t.getAttribute('data-field');
        const cond = card.querySelector(`[data-if="${key}"]`);
        if(cond) cond.style.display = t.checked ? 'block' : 'none';
      }
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateWoodAddonsConditional(card);
      updateWoodRepairControls(card);
      updateInstallConditional(card);
      persist();
    });
  }

  function attachNumberHandlers(card){
    if(card.dataset.numberHandlersAttached === 'true') return;
    card.dataset.numberHandlersAttached = 'true';

    card.addEventListener('click', (e)=>{
      const btn = e.target.closest('.sp-step');
      if(!btn || !card.contains(btn)) return;
      const box = btn.closest('.sp-number');
      if(!box) return;
      const input = $('input', box);
      if(!input) return;
      const dir = parseInt(btn.getAttribute('data-dir')||'0',10) || 0;
      const current = parseInt(input.value||'0',10) || 0;
      const min = parseInt(input.getAttribute('min')||'0',10) || 0;
      const next = Math.max(min, current + dir);
      input.value = next;
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateInstallConditional(card);
      persist();
    });

    card.addEventListener('change', (e)=>{
      const input = e.target.closest('.sp-number input');
      if(!input || !card.contains(input)) return;
      const val = parseInt(input.value||'0',10) || 0;
      const min = parseInt(input.getAttribute('min')||'0',10)||0;
      input.value = Math.max(min, val);
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateInstallConditional(card);
      persist();
    });
  }

  function allowInstallFinials(style, puppy){
    return /finials/i.test(String(style||'')) || /finials/i.test(String(puppy||''));
  }

  function hasPuppyPickets(puppy){
    return /puppy/i.test(String(puppy||'')) && !/none/i.test(String(puppy||''));
  }

  function updatePuppyPicketRepairFields(card){
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isRepair = scope !== 'install' && scope !== 'replace';
    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWrought = fenceType === 'wrought iron';
    const puppyVal = (card.querySelector('[data-field="puppy"]') || {}).value || '';
    const show = isRepair && isWrought && hasPuppyPickets(puppyVal);
    card.querySelectorAll('[data-puppy-repair]').forEach(el=>{
      el.style.display = show ? '' : 'none';
    });
    if(show){
      const sizeSel = card.querySelector('[data-field="puppyPicketSize"]');
      if(sizeSel && !sizeSel.value){
        sizeSel.value = (card.querySelector('[data-field="picketSize"]') || {}).value || SEED.picketSize[0];
      }
    }
  }

  function updatePaintingApplicationUI(card){
    const wrap = card.querySelector('[data-painting-application]');
    const prepWrap = card.querySelector('[data-painting-prep]');
    const colorWraps = card.querySelectorAll('[data-painting-colors]');
    const paintingSel = card.querySelector('[data-field="painting"]');
    const methodSel = card.querySelector('[data-field="paintingApplication"]');
    const prepSel = card.querySelector('[data-field="paintingPrepExtra"]');
    const paintingVal = paintingSel ? paintingSel.value : '';
    const showMethod = paintingVal === 'Paint Section' || paintingVal === 'Prime and Paint';
    if(wrap){
      wrap.style.display = showMethod ? '' : 'none';
    }
    const showColors = paintingVal === 'Paint Section' || paintingVal === 'Prime and Paint' || paintingVal === 'Spot Paint Welds';
    colorWraps.forEach(el=>{ el.style.display = showColors ? '' : 'none'; });
    if(prepWrap){
      const showPrep = paintingVal === 'Paint Section';
      prepWrap.style.display = showPrep ? '' : 'none';
      if(!showPrep && prepSel){
        prepSel.checked = false;
      }
    }
    if(showMethod){
      if(methodSel && !methodSel.value){
        methodSel.value = 'By Hand';
      }
    }else if(methodSel && methodSel.value !== 'By Hand'){
      methodSel.value = 'By Hand';
      methodSel.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  function updateStyleGroupVisibility(card){
    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWood = fenceType === 'wood';
    const styleGroup = card.querySelector('[data-style-group]');
    if(styleGroup){
      styleGroup.style.display = isWood ? 'none' : '';
    }
  }

  function updateInstallConditional(card){
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isInstall = scope === 'install' || scope === 'replace';
    const isReplace = scope === 'replace';
    card.querySelectorAll('[data-install-only]').forEach(el=>{
      el.style.display = isInstall ? '' : 'none';
    });
    card.querySelectorAll('[data-replace-only]').forEach(el=>{
      el.style.display = isReplace ? '' : 'none';
    });
    card.querySelectorAll('[data-repair-only]').forEach(el=>{
      el.style.display = isInstall ? 'none' : '';
    });

    const styleVal = (card.querySelector('[data-field="style"]') || {}).value || '';
    const puppyVal = (card.querySelector('[data-field="puppy"]') || {}).value || '';
    const finialsWrap = card.querySelector('[data-install-finials]');
    if(finialsWrap){
      const showFinials = isInstall && allowInstallFinials(styleVal, puppyVal);
      finialsWrap.style.display = showFinials ? '' : 'none';
      const finSel = card.querySelector('[data-field="installFinialStyle"]');
      if(finSel && showFinials && !finSel.value){
        finSel.value = SEED.finialStyles[0];
      }
    }

    card.querySelectorAll('[data-rail-repair]').forEach(el=>{
      el.style.display = isInstall ? 'none' : '';
      if(isInstall){
        const input = el.querySelector('input');
        if(input){ input.value = '0'; }
      }
    });

    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWrought = fenceType === 'wrought iron';
    const isWood = fenceType === 'wood';
    const useExistingPostsSel = card.querySelector('[data-field="useExistingPostsForReplacement"]');
    const useExistingPostsForReplacement = normalizeUseExistingPostsForReplacement(useExistingPostsSel ? useExistingPostsSel.value : 'no') === 'yes';
    const postInstallMethodWrap = card.querySelector('[data-post-install-method-wrap]');
    const postInstallMethodSel = card.querySelector('[data-field="postInstallMethod"]');
    const woodInstallPostSpacingWrap = card.querySelector('[data-wood-install-post-spacing-wrap]');
    const woodInstallPostSpacingSel = card.querySelector('[data-field="woodInstallPostSpacing"]');
    const existingPostSpacingWrap = card.querySelector('[data-existing-post-spacing-wrap]');
    const existingPostSpacingSel = card.querySelector('[data-field="woodReplacementPostSpacing"]');
    if(postInstallMethodSel){
      postInstallMethodSel.value = normalizePostInstallMethod(postInstallMethodSel.value);
    }
    if(woodInstallPostSpacingSel){
      woodInstallPostSpacingSel.value = normalizeWoodInstallPostSpacing(woodInstallPostSpacingSel.value);
    }
    if(existingPostSpacingSel){
      existingPostSpacingSel.value = normalizeWoodReplacementPostSpacing(existingPostSpacingSel.value);
    }
    if(postInstallMethodWrap){
      const showPostInstallMethod = isInstall && !(isReplace && useExistingPostsForReplacement);
      postInstallMethodWrap.style.display = showPostInstallMethod ? '' : 'none';
    }
    if(woodInstallPostSpacingWrap){
      const showInstallPostSpacing = isWood && isInstall && !(isReplace && useExistingPostsForReplacement);
      woodInstallPostSpacingWrap.style.display = showInstallPostSpacing ? '' : 'none';
    }
    if(existingPostSpacingWrap){
      const showExistingPostSpacing = isWood && isReplace && useExistingPostsForReplacement;
      existingPostSpacingWrap.style.display = showExistingPostSpacing ? '' : 'none';
    }
    const fabricationSel = card.querySelector('[data-field="wroughtPanelFabrication"]');
    if(fabricationSel && !fabricationSel.value){
      fabricationSel.value = WROUGHT_PANEL_FABRICATION_OPTIONS[0];
    }
    const panelFabrication = normalizeWroughtPanelFabrication(fabricationSel ? fabricationSel.value : '');
    const showShopFabricationFields = false;
    card.querySelectorAll('[data-shop-fabrication-only]').forEach(el=>{
      el.style.display = showShopFabricationFields ? '' : 'none';
    });
    if(!showShopFabricationFields){
      const powderPanels = card.querySelector('[data-field="wroughtPowderCoatPanels"]');
      const powderPosts = card.querySelector('[data-field="wroughtPowderCoatPosts"]');
      if(powderPanels){ powderPanels.checked = false; }
      if(powderPosts){ powderPosts.checked = false; }
    }
    const showRetainingWall = isInstall && (isWrought || isWood);
    const retainingWrap = card.querySelector('[data-retaining-wall]');
    if(retainingWrap){
      retainingWrap.style.display = showRetainingWall ? '' : 'none';
    }

    const paintingSel = card.querySelector('[data-field="painting"]');
    if(paintingSel){
      const currentVal = paintingSel.value;
      if(isWood && currentVal !== 'None'){
        paintingSel.value = 'None';
        paintingSel.dispatchEvent(new Event('change', { bubbles: true }));
      } else if(isInstall && isWrought){
        const attachmentSel = card.querySelector('[data-field="panelAttachment"]');
        const usesBrackets = attachmentSel ? attachmentSel.value === 'Brackets' : false;
        const orderedTmiPanels = isOrderedTmiPanelFabrication(panelFabrication);
        const powderCoatForcesSpot = orderedTmiPanels && !usesBrackets;
        if(powderCoatForcesSpot){
          if(currentVal !== 'Spot Paint Welds'){
            paintingSel.value = 'Spot Paint Welds';
            paintingSel.dispatchEvent(new Event('change', { bubbles: true }));
          }
        } else {
          const desired = usesBrackets ? 'None' : 'Spot Paint Welds';
          const autoValues = new Set(['', 'Paint Section', 'Spot Paint Welds', 'None']);
          if(autoValues.has(currentVal) && currentVal !== desired){
            paintingSel.value = desired;
            paintingSel.dispatchEvent(new Event('change', { bubbles: true }));
          }
        }
      }
    }
    updatePaintingApplicationUI(card);
    updatePuppyPicketRepairFields(card);
    updateStyleGroupVisibility(card);
  }

  function updateFenceTypeConditional(card){
    const typeSel = card.querySelector('[data-field="fenceType"]');
    const fenceType = (typeSel?.value || 'Wrought Iron').toLowerCase();
    const isWood = fenceType === 'wood';
    card.classList.toggle('is-wood', isWood);
    card.classList.toggle('is-wrought', !isWood);
    const paintingField = card.querySelector('[data-field="painting"]');
    const paintingWrap = paintingField?.closest('.sp-field');
    const paintingAppWrap = card.querySelector('[data-painting-application]');
    const paintingPrepWrap = card.querySelector('[data-painting-prep]');
    if(isWood){
      if(paintingField && paintingField.value !== 'None'){
        paintingField.value = 'None';
        paintingField.dispatchEvent(new Event('change', { bubbles: true }));
      }
      if(paintingWrap){ paintingWrap.style.display = 'none'; }
      if(paintingAppWrap){ paintingAppWrap.style.display = 'none'; }
      if(paintingPrepWrap){ paintingPrepWrap.style.display = 'none'; }
    }else{
      if(paintingWrap){ paintingWrap.style.display = ''; }
      updatePaintingApplicationUI(card);
    }
    if(isWood){
      const defaultWoodPost = 'Round Steel';
      const defaultTie = defaultTieForWoodPost(defaultWoodPost);
      const defaults = {
        woodHeight: '6ft',
        woodStyle: 'Side by Side',
        woodPicketWidth: '5.5"',
        woodRailSize: '2x4',
        woodPost: defaultWoodPost,
        woodType: 'Cedar',
        woodFinish: 'Oil Based Stain',
        woodKickBoardSize: '2x6',
        woodKickBoardStack: '1',
        woodTopCapSize: '2x6',
        woodTrimType: '1x4',
        woodWalkAddType: WALK_GATE_TYPES[0],
        woodWalkAddPostType: defaultWoodPost,
        woodWalkAddFrameSize: WOOD_RAIL_SIZES[1],
        woodWalkAddPicketWidth: WOOD_PICKET_WIDTHS[2],
        woodPostRealignments: [],
        woodRepairPostInstallMethod: WOOD_POST_INSTALL_METHODS[1].value,
        woodRepairPostReplaceTie: defaultTie,
        woodRepairPostInstallTie: defaultTie,
        woodRepairTopCapReplaceSize: '2x6',
        woodRepairTrimReplaceSize: '1x4',
        woodRepairKickReplaceSize: '2x6',
        woodRepairKickReplaceStack: '1',
        woodRepairStain: 'none',
        woodRepairStainBrand: DEFAULT_WOOD_STAIN_BRAND
      };
      Object.entries(defaults).forEach(([field, val])=>{
        const el = card.querySelector(`[data-field="${field}"]`);
        if(!el) return;
        if((el.tagName === 'SELECT' || el.tagName === 'INPUT') && !el.value){
          el.value = val;
        }
      });
    }
    updateWoodAddonsConditional(card);
    updateWoodRepairControls(card);
    updatePuppyPicketRepairFields(card);
    updateStyleGroupVisibility(card);
  }

  function resetSectionForFenceType(card, nextType){
    if(!card) return;
    const normalizedType = String(nextType || '').toLowerCase();
    const secId = card.getAttribute('data-id');
    const existingIdx = state.sections.findIndex(s=>s.id===secId);
    const existing = existingIdx >= 0 ? state.sections[existingIdx] : null;
    const preserved = existing ? {
      id: existing.id,
      label: existing.label,
      scopeType: existing.scopeType,
      useExistingPostsForReplacement: normalizeUseExistingPostsForReplacement(existing.useExistingPostsForReplacement),
      woodInstallPostSpacing: normalizeWoodInstallPostSpacing(existing.woodInstallPostSpacing),
      woodReplacementPostSpacing: normalizeWoodReplacementPostSpacing(existing.woodReplacementPostSpacing),
      length: existing.length,
      hardscape: existing.hardscape,
      trim: existing.trim,
      digOut: existing.digOut,
      mapGenerated: existing.mapGenerated,
      mapSegmentId: existing.mapSegmentId,
      mapGeneratedLabel: existing.mapGeneratedLabel,
      mapMeasuredLength: existing.mapMeasuredLength,
      mapLengthOverride: existing.mapLengthOverride,
      collapsed: existing.collapsed
    } : { id: secId, scopeType: 'repair' };
    const fenceType = normalizedType === 'wood' ? 'Wood' : 'Wrought Iron';
    const fresh = createSectionBase({ ...preserved, fenceType });
    if(existingIdx >= 0){
      state.sections.splice(existingIdx, 1, fresh);
    } else {
      state.sections.push(fresh);
    }
    writeSectionToDOM(card, fresh);
    card.dataset.lastFenceType = normalizedType;
    card.dataset.lastWoodPost = (fresh.woodPost || '').toLowerCase();
    updateFenceTypeConditional(card);
    updateInstallConditional(card);
    updateWalkGateConditional(card);
    updateDriveGateOperatorConditional(card);
    refreshMapPolylineColors();
    persist();
  }

  function updateWoodAddonsConditional(card){
    const checkbox = card.querySelector('[data-field="woodAddKickBoard"]');
    const kickboardDetails = card.querySelector('[data-kickboard-settings]');
    const topCapCheckbox = card.querySelector('[data-field="woodAddTopCap"]');
    const topCapDetails = card.querySelector('[data-topcap-settings]');
    const trimCheckbox = card.querySelector('[data-field="woodAddTrim"]');
    const trimDetails = card.querySelector('[data-trim-settings]');
    const showKickboard = checkbox && checkbox.checked;
    const showTopCap = topCapCheckbox && topCapCheckbox.checked;
    const showTrim = trimCheckbox && trimCheckbox.checked;

    if(kickboardDetails){
      kickboardDetails.style.display = showKickboard ? '' : 'none';
    }
    if(topCapDetails){
      topCapDetails.style.display = showTopCap ? '' : 'none';
    }
    if(trimDetails){
      trimDetails.style.display = showTrim ? '' : 'none';
    }
  }

  function updateWoodRepairControls(card){
    const postType = (card.querySelector('[data-field="woodPost"]')?.value || '').toLowerCase();
    const prevPostType = (card.dataset.lastWoodPost || '').toLowerCase();
    if(postType && postType !== prevPostType){
      applyWoodPostDefaults(card, prevPostType);
    }
    if(postType){
      card.dataset.lastWoodPost = postType;
    }
    const allowCutWeld = postType === 'round steel' || postType === 'postmaster';
    const methodSelects = card.querySelectorAll('[data-wood-post-realign-method]');
    methodSelects.forEach(sel => {
      const cutOption = Array.from(sel.options).find(opt=>opt.value==='cut-weld');
      if(cutOption){ cutOption.disabled = !allowCutWeld; }
      if(!allowCutWeld && sel.value === 'cut-weld'){
        sel.value = 'dig-straighten';
        persistWoodPostRealignmentsFromDOM(card);
      }
    });
  }

  function updateWalkGateConditional(card){
    const getN = (f)=>{
      const box = card.querySelector(`.sp-number[data-field="${f}"] input`);
      return parseInt((box && box.value) || '0',10) || 0;
    };
    const wg = getN('walkGates');
    const hw = getN('walkGatesHardware');
    const rb = getN('walkGatesRebuild');
    const add = getN('walkGatesAdd');
    const woodAdd = getN('woodWalkGatesAdd');
    const scopeSel = card.querySelector('[data-field="scopeType"]');
    const scope = scopeSel ? scopeSel.value : 'repair';
    const isInstall = scope === 'install' || scope === 'replace';
    const fenceType = (card.querySelector('[data-field="fenceType"]')?.value || '').toLowerCase();
    const isWood = fenceType === 'wood';

    const wrap = card.querySelector('[data-wg-wrap]');
    if(wrap){ wrap.style.display = (!isInstall && wg>0) ? 'block' : 'none'; }
    const hwWrap = card.querySelector('[data-wg-hw-wrap]');
    if(hwWrap){ hwWrap.style.display = (!isInstall && wg>0 && hw>0) ? 'block' : 'none'; }
    const rbWrap = card.querySelector('[data-wg-rebuild-wrap]');
    if(rbWrap){ rbWrap.style.display = (!isInstall && wg>0 && rb>0) ? 'block' : 'none'; }

    const addWrap = card.querySelector('[data-wg-add-wrap]');
    if(addWrap){ addWrap.style.display = (!isWood && add>0) ? 'block' : 'none'; }
    const woodAddWrap = card.querySelector('[data-wood-wg-add-wrap]');
    if(woodAddWrap){ woodAddWrap.style.display = (isWood && woodAdd>0) ? 'block' : 'none'; }
  }

  function updateDriveGateOperatorConditional(card){
    const replBox = card.querySelector('.sp-number[data-field="driveGateOperatorReplace"] input');
    const replCount = parseInt((replBox && replBox.value) || '0',10) || 0;
    const replWrap = card.querySelector('[data-drive-operator-wrap]');
    if(replWrap){ replWrap.style.display = replCount>0 ? 'block' : 'none'; }

    const installBox = card.querySelector('.sp-number[data-field="driveGateOperatorInstall"] input');
    const installCount = parseInt((installBox && installBox.value) || '0',10) || 0;
    const installWrap = card.querySelector('[data-drive-operator-install-wrap]');
    if(installWrap){ installWrap.style.display = installCount>0 ? 'block' : 'none'; }
  }

  function updateMapLengthOverrideFromCard(card){
    if(!card || card.dataset.mapGenerated !== 'true'){
      if(card){
        delete card.dataset.mapLengthOverride;
      }
      return;
    }
    const lengthControl = card.querySelector('[data-field="length"]');
    const input = lengthControl ? lengthControl.querySelector('input') : null;
    if(!input){
      delete card.dataset.mapLengthOverride;
      return;
    }
    const value = parsePositiveInt(input.value);
    const measured = parsePositiveInt(card.dataset.mapMeasuredLength);
    if(value > 0 && (!measured || value !== measured)){
      card.dataset.mapLengthOverride = String(value);
    }else{
      delete card.dataset.mapLengthOverride;
    }
  }

  function applyMapLinkedStateToCard(card, sectionData){
    const lengthControl = card.querySelector('[data-field="length"]');
    if(lengthControl && lengthControl.classList.contains('sp-number')){
      const input = lengthControl.querySelector('input');
      const buttons = lengthControl.querySelectorAll('button');
      if(sectionData.mapGenerated){
        lengthControl.classList.add('is-map-linked');
        if(input){
          input.readOnly = false;
          input.removeAttribute('aria-readonly');
        }
        buttons.forEach(btn=>{
          btn.disabled = false;
          btn.removeAttribute('aria-disabled');
        });
        updateMapLengthOverrideFromCard(card);
      }else{
        lengthControl.classList.remove('is-map-linked');
        if(input){
          input.readOnly = false;
          input.removeAttribute('aria-readonly');
        }
        buttons.forEach(btn=>{
          btn.disabled = false;
          btn.removeAttribute('aria-disabled');
        });
        delete card.dataset.mapLengthOverride;
        delete card.dataset.mapMeasuredLength;
      }
    }

    const removeBtn = card.querySelector('.sp-del');
    if(removeBtn){
      if(sectionData.mapGenerated){
        removeBtn.disabled = true;
        removeBtn.title = 'Remove this run on the map to delete the section';
      }else{
        removeBtn.disabled = false;
        removeBtn.title = '';
      }
    }

    const duplicateBtn = card.querySelector('.sp-dup');
    if(duplicateBtn){
      if(sectionData.mapGenerated){
        duplicateBtn.disabled = true;
        duplicateBtn.title = 'Duplicate not available for map-linked sections';
      }else{
        duplicateBtn.disabled = false;
        duplicateBtn.title = '';
      }
    }

    const actionRow = card.querySelector('.sp-card-header .sp-row');
    if(actionRow){
      let chip = actionRow.querySelector('[data-map-chip]');
      if(sectionData.mapGenerated){
        if(!chip){
          chip = document.createElement('span');
          chip.className = 'sp-chip is-info';
          chip.dataset.mapChip = 'true';
          chip.textContent = 'Map linked';
          actionRow.insertBefore(chip, actionRow.firstChild);
        }
      }else if(chip){
        chip.remove();
      }
    }
  }

  function updateQuickActions(){
    const hasSections = state.sections.length > 0;
    const firstBtn = document.getElementById('sp-quick-dup-first');
    const lastBtn = document.getElementById('sp-quick-dup-last');
    const addBtn = document.getElementById('sp-quick-add');

    if(addBtn){ addBtn.disabled = false; }

    if(firstBtn){
      firstBtn.disabled = !hasSections;
      const firstLabel = state.sections[0]?.label?.trim();
      firstBtn.title = hasSections
        ? `Copy style from Section 1${firstLabel ? ` – ${firstLabel}` : ''}`
        : 'Add a section to copy its style';
    }

    if(lastBtn){
      lastBtn.disabled = !hasSections;
      const latest = state.sections[state.sections.length-1];
      const lastLabel = latest?.label?.trim();
      lastBtn.title = hasSections
        ? `Copy style from Section ${state.sections.length}${lastLabel ? ` – ${lastLabel}` : ''}`
        : 'Add a section to copy its style';
    }
  }

  function render(){
    const sectionsEl = document.getElementById('sp-sections');
    sectionsEl.innerHTML = '';
    state.sections.forEach((s, idx)=>{
      const wrapper = document.createElement('div');
      wrapper.innerHTML = sectionTemplate(s.id, idx);
      const card = wrapper.firstElementChild;
      sectionsEl.appendChild(card);
      writeSectionToDOM(card, s);
      card.dataset.lastFenceType = (s.fenceType || 'Wrought Iron').toLowerCase();
      card.dataset.lastWoodPost = (s.woodPost || '').toLowerCase();
      updateSectionBasicsGate(card);
      updateFenceTypeConditional(card);
      attachNumberHandlers(card);
      attachRailsHandlers(card);
      updateWalkGateConditional(card);
      updateDriveGateOperatorConditional(card);
      updateInstallConditional(card);
      applyMapLinkedStateToCard(card, s);

      const titleEl = $('.sp-card-title', card);
      const labelInput = card.querySelector('[data-field="label"]');
      function refreshTitle(){
        const v = (labelInput.value||'').trim();
        titleEl.textContent = `Section ${idx+1}${v ? ' - ' + v : ''}`;
      }
      refreshTitle();
      labelInput.addEventListener('input', ()=>{
        refreshTitle();
        updateSectionBasicsGate(card);
      });

      const deleteBtn = $('.sp-del', card);
      if(deleteBtn){
        let confirmTimer = null;
        const resetConfirm = ()=>{
          deleteBtn.dataset.confirm = '';
          deleteBtn.textContent = 'Remove';
          deleteBtn.classList.remove('is-confirm');
          if(confirmTimer){
            clearTimeout(confirmTimer);
            confirmTimer = null;
          }
        };
        deleteBtn.addEventListener('click', ()=>{
          if(deleteBtn.dataset.confirm === 'true'){
            resetConfirm();
            removeSection(s.id);
            persist();
            return;
          }
          deleteBtn.dataset.confirm = 'true';
          deleteBtn.textContent = 'Confirm Remove';
          deleteBtn.classList.add('is-confirm');
          if(confirmTimer){
            clearTimeout(confirmTimer);
          }
          confirmTimer = setTimeout(()=>{ resetConfirm(); }, 4000);
        });
      }
      $('.sp-dup', card).addEventListener('click', ()=>{ duplicateSection(s.id); persist(); });

      const applyBasicsBtn = $('.sp-apply-basics-all', card);
      if(applyBasicsBtn){
        const canApply = state.sections.length > 1;
        applyBasicsBtn.disabled = !canApply;
        applyBasicsBtn.title = canApply
          ? 'Apply this section basic settings to all sections'
          : 'Add at least one more section to bulk apply basics';
        applyBasicsBtn.addEventListener('click', ()=>{
          if(state.sections.length <= 1){
            return;
          }
          syncStateFromDOM();
          const source = state.sections.find(sec => sec.id === s.id);
          if(!source){
            return;
          }
          const sourceLabel = (source.label || '').trim();
          const sourceFence = normalizeBulkFenceType(source.fenceType) === 'wood' ? 'wood' : 'wrought iron';
          const sourceTitle = sourceLabel ? `Section ${idx+1} - ${sourceLabel}` : `Section ${idx+1}`;
          const ok = confirm(`Apply ${sourceFence} basic settings from ${sourceTitle} to all ${state.sections.length} sections?`);
          if(!ok){
            return;
          }
          applyBasicsToAllSectionsFrom(s.id);
        });
      }

      const toggleBtn = $('.sp-toggle', card);
      if(toggleBtn){
        toggleBtn.addEventListener('click', ()=>{
          const next = !card.classList.contains('is-collapsed');
          card.classList.toggle('is-collapsed', next);
          toggleBtn.textContent = next ? 'Expand' : 'Collapse';
          toggleBtn.setAttribute('aria-expanded', (!next).toString());
          const sec = state.sections.find(x=>x.id===s.id);
          if(sec){ sec.collapsed = next; }
          persist();
        });
      }

      $$('input, select, textarea', card).forEach(el=>{
        el.addEventListener('input', ()=>{
          if(el.closest('.sp-number[data-field="length"]') && card.dataset.mapGenerated === 'true'){
            updateMapLengthOverrideFromCard(card);
            scheduleMapSectionsUpdate();
          }
          updateSectionBasicsGate(card);
          persist();
        });
        el.addEventListener('change', ()=>{
          if(el.closest('.sp-number[data-field="length"]') && card.dataset.mapGenerated === 'true'){
            updateMapLengthOverrideFromCard(card);
            scheduleMapSectionsUpdate();
          }
          if(el.matches('[data-field="fenceType"]')){
            const nextType = (el.value || '').toLowerCase();
            const prevType = card.dataset.lastFenceType || '';
            if(nextType !== prevType){
              resetSectionForFenceType(card, nextType);
              return;
            }
          }
          updateFenceTypeConditional(card);
          updateWalkGateConditional(card);
          updateDriveGateOperatorConditional(card);
          updateInstallConditional(card);
          updateSectionBasicsGate(card);
          persist();
        });
      });
    });
    refreshMapPolylineColors();
    updateQuickActions();
  }

  function feetFromStr(h){
    const m = String(h||'').match(/(\d+)/);
    return m ? parseInt(m[1],10) : 0;
  }
  function styleFactor(v){
    const raw = String(v || '').toLowerCase();
    if(raw.includes('extended picket') && raw.includes('finial')) return 1.75;
    if(raw.includes('extended picket')) return 2;
    if(raw.includes('flat top')) return 3;
    return 1.5;
  }
  function railPacePenalty(count){
    const rails = parseInt(count, 10);
    if(!rails || rails <= 2) return 0;
    return (rails - 2) * 0.25;
  }
  function puppyAdj(v){
    if(v === 'Puppy Pickets') return 0.25;
    if(v === 'Puppy Pickets w/ Finials') return 0.5;
    return 0;
  }
  function normalizeLabelText(text){
    return String(text||'')
      .replace(/\u201D|”/g,'"')
      .replace(/\u201C|“/g,'"')
      .replace(/\u2019|’/g,"'")
      .replace(/\u2018|‘/g,"'")
      .replace(/×/g,'x')
      .trim();
  }
  function normalizeWroughtCustomStickLength(value){
    const raw = String(value ?? '').trim();
    const parsed = parseInt(raw, 10);
    return parsed === 24 ? '24' : '12';
  }
  function normalizeWroughtPanelFabrication(value){
    const raw = String(value || '').trim().toLowerCase();
    if(!raw){
      return WROUGHT_PANEL_FABRICATION_ON_SITE;
    }
    if(
      raw === 'shop' ||
      raw === 'tmi' ||
      raw === 'order custom panels (tmi)' ||
      raw === 'order custom panels' ||
      raw === 'order from tmi' ||
      raw === 'ordered from tmi'
    ){
      return WROUGHT_PANEL_FABRICATION_ORDER_TMI;
    }
    if(
      raw === 'on site' ||
      raw === 'onsite' ||
      raw === 'build on site' ||
      raw === 'field build'
    ){
      return WROUGHT_PANEL_FABRICATION_ON_SITE;
    }
    const match = WROUGHT_PANEL_FABRICATION_OPTIONS.find(option=> option.toLowerCase() === raw);
    return match || WROUGHT_PANEL_FABRICATION_ON_SITE;
  }
  function isOrderedTmiPanelFabrication(value){
    return normalizeWroughtPanelFabrication(value) === WROUGHT_PANEL_FABRICATION_ORDER_TMI;
  }
  function wroughtCustomStickLengthFt(value){
    return parseInt(normalizeWroughtCustomStickLength(value), 10) || 12;
  }
  function normalizePaintColorKey(value){
    const raw = normalizeLabelText(value || '').toLowerCase();
    if(!raw) return '';
    if(raw.includes('black')) return 'black';
    if(raw.includes('brown')) return 'brown';
    if(raw.includes('bronze')) return 'bronze';
    if(raw.includes('white')) return 'white';
    if(raw.includes('aluminum')) return 'aluminum';
    if(raw.includes('gray') || raw.includes('grey')) return 'gray';
    if(raw.includes('green')) return 'green';
    if(raw.includes('blue')) return 'blue';
    if(raw.includes('yellow')) return 'yellow';
    if(raw.includes('red')) return 'red';
    if(raw.includes('orange')) return 'orange';
    if(raw.includes('rust') || raw.includes('weather')) return 'rust/weathered';
    return raw;
  }
  function paintCoatCountForSection(section){
    const fenceType = String(section?.fenceType || '').toLowerCase();
    if(fenceType && fenceType !== 'wrought iron') return 1;
    const current = normalizePaintColorKey(section?.paintingCurrentColor || WROUGHT_CURRENT_COLOR_OPTIONS[0]);
    const target = normalizePaintColorKey(section?.paintingTargetColor || WROUGHT_PAINT_COLOR_OPTIONS[0]);
    if(!current || !target) return 1;
    return current === target ? 1 : 2;
  }
  function effectiveWroughtPaintingSelection(section){
    const fenceType = String(section?.fenceType || '').toLowerCase();
    if(fenceType && fenceType !== 'wrought iron') return 'None';
    const scopeType = String(section?.scopeType || 'repair').toLowerCase();
    const isInstallScope = scopeType === 'install' || scopeType === 'replace';
    const attachment = String(section?.panelAttachment || '').trim();
    if(isInstallScope && attachment === 'Brackets'){
      return 'None';
    }
    const panelFabrication = normalizeWroughtPanelFabrication(section?.wroughtPanelFabrication);
    if(isInstallScope && isOrderedTmiPanelFabrication(panelFabrication)){
      return 'Spot Paint Welds';
    }
    const raw = String(section?.painting || '').trim();
    if(raw) return raw;
    return isInstallScope ? 'Spot Paint Welds' : 'Paint Section';
  }
  function isFullWroughtSectionPaintMode(mode){
    return mode === 'Paint Section' || mode === 'Prime and Paint';
  }
  function isAnyWroughtPaintMode(mode){
    return isFullWroughtSectionPaintMode(mode) || mode === 'Spot Paint Welds';
  }
  function normalizeWoodStainBrand(value){
    const raw = String(value || '').trim().toLowerCase();
    const match = WOOD_STAIN_BRANDS.find(brand=>brand.toLowerCase() === raw);
    return match || DEFAULT_WOOD_STAIN_BRAND;
  }
  function woodStainBucketMaterialLabel(brand){
    return `5 gal wood stain bucket (${normalizeWoodStainBrand(brand)})`;
  }
  function isPostmasterPost(post){
    return /postmaster/i.test(String(post||''));
  }
  function isRoundSteelPost(post){
    return /round steel/i.test(String(post||''));
  }
  function woodRoundSteelPostLabelForHeight(heightFt){
    const normalizedHeight = Math.max(0, parseFloat(heightFt || 0) || 0);
    return normalizedHeight >= 8 ? '12ft round steel' : '9ft round steel';
  }
  function defaultTieForWoodPost(post){
    return isPostmasterPost(post) ? NO_TIES_OPTION : SIMPSON_TIE_OPTIONS[0];
  }
  function defaultCapForWoodPost(post){
    if(isPostmasterPost(post)) return '';
    if(isRoundSteelPost(post)) return 'Dome cap';
    return '';
  }
  function isNoTiesSelection(tie){
    return /no\s*ties/i.test(String(tie||''));
  }
  function normalizeWoodGatePostType(value, fallback=WOOD_GATE_POST_TYPES[1]){
    const raw = String(value || '').trim();
    if(!raw) return fallback;
    const direct = WOOD_GATE_POST_TYPES.find(item=>item.toLowerCase() === raw.toLowerCase());
    if(direct) return direct;
    const lower = raw.toLowerCase();
    if(lower.includes('postmaster')) return 'Postmaster';
    if(lower.includes('round')) return 'Round Steel';
    if(lower.includes('wood')) return 'Wood 4x4';
    if(lower.includes('4x4')) return 'Wood 4x4';
    return fallback;
  }
  function normalizeWoodGateFrameSize(value, fallback=WOOD_RAIL_SIZES[1]){
    const raw = normalizeSize(value);
    const match = WOOD_RAIL_SIZES.find(item=>normalizeSize(item) === raw);
    return match || fallback;
  }
  function normalizeWoodGatePicketWidth(value, fallback=WOOD_PICKET_WIDTHS[2]){
    const raw = normalizeSize(value);
    const match = WOOD_PICKET_WIDTHS.find(item=>normalizeSize(item) === raw);
    return match || fallback;
  }
  function applyWoodPostDefaults(card, prevPost){
    if(!card) return;
    const postSel = card.querySelector('[data-field="woodPost"]');
    if(!postSel) return;
    const nextPost = postSel.value || '';
    const prevTieDefault = defaultTieForWoodPost(prevPost);
    const nextTieDefault = defaultTieForWoodPost(nextPost);
    const prevCapDefault = defaultCapForWoodPost(prevPost);
    const nextCapDefault = defaultCapForWoodPost(nextPost);
    const replaceTieSel = card.querySelector('[data-field="woodRepairPostReplaceTie"]');
    const installTieSel = card.querySelector('[data-field="woodRepairPostInstallTie"]');
    const capSel = card.querySelector('[data-field="woodRepairPostReplaceCap"]');
    [replaceTieSel, installTieSel].forEach(sel=>{
      if(!sel) return;
      const current = sel.value || '';
      if(!current || current === prevTieDefault){
        sel.value = nextTieDefault;
      }
    });
    if(capSel){
      const current = capSel.value || '';
      if(current === prevCapDefault){
        capSel.value = nextCapDefault;
      }
    }
  }
  function woodPicketStyleForSection(section){
    return section && section.woodAddTrim ? 'Flat Top' : 'Dog Ear';
  }
  function woodPicketMaterialLabel(section){
    if(!section) return 'wood picket';
    const widthLabel = normalizeLabelText(section.woodPicketWidth || '');
    const heightLabel = normalizeLabelText(section.woodHeight || section.height || '');
    const typeLabel = normalizeLabelText(section.woodType || '') || 'Cedar';
    const styleLabel = woodPicketStyleForSection(section);
    const parts = [widthLabel, heightLabel, typeLabel, styleLabel].filter(Boolean);
    if(!parts.length) return 'wood picket';
    return `wood picket (${parts.join(', ')})`;
  }
  function woodRailMaterialLabel(section, railLengthFt=8, includeLength=false){
    if(!section) return 'wood rail';
    const sizeLabel = normalizeLabelText(section.woodRailSize || '');
    const typeLabel = woodRailTypeLabel(section);
    const numericLength = Number(railLengthFt || 0);
    const showLength = isFinite(numericLength) && numericLength > 0 && (includeLength || numericLength !== 8);
    const lengthLabel = showLength
      ? `${Math.round(numericLength)}ft`
      : '';
    const parts = [sizeLabel, typeLabel, lengthLabel].filter(Boolean);
    return `wood rail${parts.length ? ` (${parts.join(', ')})` : ''}`;
  }
  function woodGate2x4MaterialLabel(section){
    if(!section) return 'wood rail (2x4)';
    const typeLabel = woodRailTypeLabel(section);
    const parts = ['2x4', typeLabel].filter(Boolean);
    return `wood rail (${parts.join(', ')})`;
  }
  function woodBoardPieceLength(typeLabel, sizeLabel){
    const typeMap = WOOD_BOARD_PIECE_PRICING[typeLabel];
    if(!typeMap || !Object.prototype.hasOwnProperty.call(typeMap, sizeLabel)) return 0;
    const entry = typeMap[sizeLabel] || {};
    const lengthFt = Number(entry.lengthFt || 0);
    return isFinite(lengthFt) ? lengthFt : 0;
  }
  function addWoodBoardReplaceLf(map, size, lf){
    const cleanSize = normalizeLabelText(size || '');
    const lengthFt = parseFloat(lf);
    if(!cleanSize || !isFinite(lengthFt) || lengthFt <= 0) return;
    map.set(cleanSize, (map.get(cleanSize) || 0) + lengthFt);
  }
  function woodRailDescriptor(section){
    if(!section) return 'rail';
    const sizeLabel = normalizeLabelText(section.woodRailSize || '');
    const typeLabel = woodRailTypeLabel(section);
    const parts = [sizeLabel, typeLabel].filter(Boolean);
    return parts.length ? `${parts.join(' ')} rail` : 'rail';
  }
  function woodRailTypeLabel(section){
    if(!section) return '';
    const typeLabel = normalizeLabelText(section.woodType || '');
    if(!typeLabel) return '';
    const finishLabel = String(section.woodFinish || '');
    if(/stain/i.test(finishLabel) && /cedar/i.test(typeLabel)){
      return 'Stained Cedar';
    }
    return typeLabel;
  }
  function walkGateTypeIsDouble(typeLabel){
    return /double/i.test(String(typeLabel || ''));
  }
  function walkGateAddCount(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      const count = parseInt(section?.woodWalkGatesAdd ?? section?.walkGatesAdd ?? 0, 10) || 0;
      return count;
    }
    return parseInt(section?.walkGatesAdd || 0, 10) || 0;
  }
  function walkGateAddType(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      return section?.woodWalkAddType || section?.walkAddType || WALK_GATE_TYPES[0];
    }
    return section?.walkAddType || WALK_GATE_TYPES[0];
  }
  function walkGateAddPostLabel(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      return normalizeWoodGatePostType(section?.woodWalkAddPostType || section?.woodPost || WOOD_GATE_POST_TYPES[1]);
    }
    return section?.walkAddPostSize || '';
  }
  function walkGateAddFrameLabel(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      return normalizeWoodGateFrameSize(section?.woodWalkAddFrameSize || section?.woodRailSize || WOOD_RAIL_SIZES[1]);
    }
    return section?.walkAddFrameSize || '';
  }
  function walkGateAddPicketLabel(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      return normalizeWoodGatePicketWidth(section?.woodWalkAddPicketWidth || section?.woodPicketWidth || WOOD_PICKET_WIDTHS[2]);
    }
    return section?.walkAddPicketSize || '';
  }
  function walkGateAddLatchLabel(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      return 'wood walk gate latch';
    }
    return section?.walkAddLatch || '';
  }
  function walkGateAddHingeLabel(section){
    if((section?.fenceType || '').toLowerCase() === 'wood'){
      return 'wood walk gate hinge';
    }
    return section?.walkAddHinges || '';
  }
  function woodGateFrameMaterialLabel(section, frameSize){
    if(!section) return 'wood rail (2x4)';
    const normalizedFrame = normalizeWoodGateFrameSize(frameSize || section.woodRailSize || WOOD_RAIL_SIZES[1]);
    const typeLabel = woodRailTypeLabel(section);
    const typedLabel = `wood rail (${[normalizedFrame, typeLabel].filter(Boolean).join(', ')})`;
    const sizeOnlyLabel = `wood rail (${normalizedFrame})`;
    if(Object.prototype.hasOwnProperty.call(PRICE_MISC, typedLabel)){
      return typedLabel;
    }
    if(Object.prototype.hasOwnProperty.call(PRICE_MISC, sizeOnlyLabel)){
      return sizeOnlyLabel;
    }
    return typedLabel;
  }
  function woodPicketMaterialLabelWithWidth(section, width){
    if(!section) return 'wood picket';
    const next = { ...section, woodPicketWidth: width || section.woodPicketWidth };
    return woodPicketMaterialLabel(next);
  }
  function woodPicketUnitPriceFromLabel(label){
    const raw = String(label||'');
    if(!/^wood picket/i.test(raw)) return null;
    const match = raw.match(/wood picket \(([^,)]+)/i);
    const widthLabel = match ? normalizeLabelText(match[1]) : '';
    if(widthLabel){
      const key = `wood picket (${widthLabel})`;
      if(Object.prototype.hasOwnProperty.call(PRICE_MISC, key)){
        return PRICE_MISC[key] || 0;
      }
    }
    if(Object.prototype.hasOwnProperty.call(PRICE_MISC, 'wood picket')){
      return PRICE_MISC['wood picket'] || 0;
    }
    return null;
  }
  function woodRailUnitPriceFromLabel(label){
    const raw = String(label||'');
    if(!/^wood rail/i.test(raw)) return null;
    let lengthFt = 8;
    let unitPrice = null;
    const match = raw.match(/^wood rail\s*\(([^)]+)\)/i);
    if(match){
      const tokens = String(match[1] || '')
        .split(',')
        .map(token=>normalizeLabelText(token))
        .filter(Boolean);
      const nonLengthTokens = [];
      tokens.forEach(token=>{
        const lengthMatch = token.match(/^(\d+(?:\.\d+)?)\s*ft$/i);
        if(lengthMatch){
          const parsedLength = parseFloat(lengthMatch[1]);
          if(isFinite(parsedLength) && parsedLength > 0){
            lengthFt = parsedLength;
          }
          return;
        }
        nonLengthTokens.push(token);
      });
      if(nonLengthTokens.length){
        const fullKey = `wood rail (${nonLengthTokens.join(', ')})`;
        if(Object.prototype.hasOwnProperty.call(PRICE_MISC, fullKey)){
          unitPrice = PRICE_MISC[fullKey] || 0;
        }
      }
      if(unitPrice === null && nonLengthTokens.length){
        const sizeOnlyKey = `wood rail (${nonLengthTokens[0]})`;
        if(Object.prototype.hasOwnProperty.call(PRICE_MISC, sizeOnlyKey)){
          unitPrice = PRICE_MISC[sizeOnlyKey] || 0;
        }
      }
    }
    if(unitPrice === null && Object.prototype.hasOwnProperty.call(PRICE_MISC, raw)){
      unitPrice = PRICE_MISC[raw] || 0;
    }
    if(unitPrice === null && Object.prototype.hasOwnProperty.call(PRICE_MISC, 'wood rail')){
      unitPrice = PRICE_MISC['wood rail'] || 0;
    }
    if(unitPrice === null){
      return null;
    }
    const multiplier = lengthFt >= 12 ? 2 : 1;
    return unitPrice * multiplier;
  }
  function woodBoardCostFromLabel(label, qty){
    const raw = String(label||'');
    const match = raw.match(/^wood\s+(top cap|trim|kick board)\s*\(([^)]+)\)/i);
    if(!match) return null;
    const typeLabel = String(match[1] || '').toLowerCase();
    const sizeRaw = match[2] ? String(match[2]) : '';
    const sizeLabel = normalizeLabelText(sizeRaw.split(',')[0] || '');
    const typeMap = WOOD_BOARD_PIECE_PRICING[typeLabel];
    if(!typeMap || !Object.prototype.hasOwnProperty.call(typeMap, sizeLabel)){
      return { totalCost: 0, pieces: 0, pieceCost: 0, unpriced: true };
    }
    const config = typeMap[sizeLabel] || {};
    const pieceLengthFt = Number(config.lengthFt || 0);
    const pieceCost = Number(config.cost || 0);
    const lengthMatch = raw.match(/(\d+(?:\.\d+)?)\s*(?:ft|feet|lf)\b/i);
    const lengthFt = lengthMatch ? (parseFloat(lengthMatch[1]) || 0) : 0;
    const itemQty = Number(qty || 0);

    if(!isFinite(pieceLengthFt) || pieceLengthFt <= 0 || !isFinite(pieceCost) || pieceCost <= 0){
      return { totalCost: 0, pieces: 0, pieceCost: pieceCost || 0, unpriced: true };
    }

    let pieces = 0;
    if(lengthFt > 0 && itemQty > 0){
      const totalLength = lengthFt * itemQty;
      pieces = Math.ceil(totalLength / pieceLengthFt);
    } else if(itemQty > 0){
      pieces = itemQty;
    }

    const totalCost = pieces * pieceCost;
    return { totalCost, pieces, pieceCost, unpriced: false };
  }
  function addMat(map, label, qty){
    if(!qty || qty <= 0) return;
    const cleanLabel = normalizeLabelText(label);
    map[cleanLabel] = (map[cleanLabel]||0) + qty;
  }

  function addPostAnchorMaterials(map, postCount){
    const qty = Math.max(0, parseInt(postCount, 10) || 0);
    if(qty <= 0) return;
    addMat(map, POST_ANCHOR_PLATE_LABEL, qty);
    addMat(map, POST_ANCHOR_HARDWARE_LABEL, qty * 4);
  }

  function normalizeSize(txt){
    return String(txt||'')
      .replace(/\\u201D|”/g,'"')
      .replace(/\\u201C|“/g,'"')
      .replace(/\\u00BC|¼/g,'1/4')
      .replace(/\\u00BD|½/g,'1/2')
      .replace(/\\u00BE|¾/g,'3/4')
      .replace(/×/g,'x')
      .trim();
  }
  function isPanelPuppyInsertStyle(style){
    return /Puppy Picket Insert/i.test(style || '');
  }
  function normalizePuppyInsertSize(size){
    const normalized = normalizeSize(size);
    return PUPPY_INSERT_SIZES.includes(normalized) ? normalized : PUPPY_INSERT_SIZES[0];
  }

  function puppyPicketDetailLabel(size, height){
    const normalizedSize = normalizeSize(size);
    const sizeLabel = normalizedSize || normalizeLabelText(size);
    const heightNum = parseInt(height||0,10) || 0;
    const heightLabel = heightNum > 0 ? `${heightNum} in` : '';
    if(sizeLabel && heightLabel) return `${sizeLabel} × ${heightLabel}`;
    return sizeLabel || (heightLabel ? `${heightLabel} tall` : '');
  }

  function snapshotForNotes(){
    const sections = JSON.parse(JSON.stringify(state.sections || []));
    const crewMembers = getActiveCrewMembers();
    return {
      version: NOTES_DATA_VERSION,
      generatedAt: new Date().toISOString(),
      state: {
        sections,
        customerType: getCustomerType(),
        crewMembers
      },
      map: serializeMapDrawing(),
      estimate: {
        number: lastEstimateLookupNumber || '',
        address: mapAddressInput ? (mapAddressInput.value || '').trim() : '',
        id: lastEstimateId || '',
      }
    };
  }

  function applySnapshotToState(payload){
    if(!payload || !payload.state || !Array.isArray(payload.state.sections)){
      throw new Error('No sections found in the embedded data');
    }
    clearMapDrawing({ skipSections: true });
    const nextSections = payload.state.sections.map(sec => createSectionBase(sec));
    if(!nextSections.length){
      throw new Error('No sections found in the embedded data');
    }

    state.sections = nextSections;

    const snapshotCustomerType = payload.state && payload.state.customerType ? normalizeCustomerType(payload.state.customerType) : '';
    if(snapshotCustomerType){
      if(customerTypeSelect){
        customerTypeSelect.value = snapshotCustomerType;
      }
      state.customerType = snapshotCustomerType;
    }else if(customerTypeSelect){
      state.customerType = normalizeCustomerType(customerTypeSelect.value);
    }
    const snapshotCrewMembers = normalizeCrewMembers(payload.state && payload.state.crewMembers);
    applyCrewMembersSelection(snapshotCrewMembers.length ? snapshotCrewMembers : DEFAULT_CREW_MEMBERS.slice());
    updatePricingMinimumUI();
    setCustomerTypeConfirmed(false);

    const snapshotEstimateNumber = sanitizeEstimateNumber(payload.estimate && payload.estimate.number ? payload.estimate.number : '');
    const snapshotEstimateAddress = (payload.estimate && payload.estimate.address ? payload.estimate.address : '').trim();
    const snapshotEstimateId = normalizeEstimateId(payload.estimate && (payload.estimate.id || payload.estimate.estimateId || payload.estimate.estimate_id));
    const importAddress = (payload.map && payload.map.address) || snapshotEstimateAddress || '';

    if(estimateNumberInput){
      estimateNumberInput.value = snapshotEstimateNumber;
    }
    lastEstimateLookupNumber = snapshotEstimateNumber;
    lastEstimateAddress = snapshotEstimateAddress || importAddress;
    lastEstimateId = snapshotEstimateId;
    lastEstimateExists = !!snapshotEstimateNumber;

    if(mapAddressInput){
      mapAddressInput.value = importAddress || '';
      if(importAddress){
        focusMapOnAddress(importAddress);
      }
    }

    if(payload.map){
      restoreMapFromSnapshot(payload.map);
    }

    render();
    renderServiceLineNotes([]);
    generateNotes({ skipScroll: true });
    if(snapshotEstimateNumber){
      lookupEstimateAddress(snapshotEstimateNumber);
    }else{
      updateEstimateStatus('', '');
    }
  }

  const PRICE_FT = {
    '1/2\"': 0.57,
    '5/8\"': 0.68,
    '3/4\"': 0.9041666667,
    '1\"':   1.07,
    '1x2\"': 1.65,
    '1 1/2\"': 1.46,
    '1 1/4\"': 1.46,
    '1 3/4\"': 2.57,
    '2x2\"': 2.39625,
    '3x3\"': 6.00,
    '4x4': 6.22375,
    '2\"': 2.39625,
    '3\"': 6.00,
    'Flat Bar 1/4\" x 1\"': 0.58
  };
  const PRICE_MISC = {
    'Gravity Latch': 5,
    'Short Pool Latch': 80,
    'Tall Pool Latch': 90,
    'Single Lock Box': 5,
    'Double Lock Box': 10,
    'Pair of Door Hinges': 5,
    'Pair of Bat Wing Hinges': 5,
    'Pair of Auto Close Hinges': 50,
    'Wood 4x4 posts': 20,
    'Round Steel posts': 23.61,
    '9ft round steel posts': 23.61,
    '12ft round steel posts': 31.82,
    'Postmaster posts': 50,
    'Dome cap post cap': 1.13,
    'Flat cap post cap': 1.13,
    'Simpson 1 piece ties': 1.81,
    'Simpson 2 piece ties': 1.81,
    'lag screws': 0.075,
    'lag screw bags (100)': 7.50,
    'ring shank nails': 0.04,
    'postmaster screw boxes (170)': 16.65,
    'Skid steer rental': 500,
    'wood walk gate hinge': 35,
    'wood walk gate latch': 20,
    // NEW
    'replacement finial': 1.25,
    'puppy picket insert (1/2")': 62.59,
    'puppy picket insert (5/8")': 62.59,
    'picket plugs (1/2")': 0.10,
    'picket plugs (5/8")': 0.11,
    'prefab gate panel': 0,
    'LiftMaster drive gate operator': 2000,
    [DRIVE_GATE_OPERATOR_DETAILS['Single Swing'].label]: DRIVE_GATE_OPERATOR_DETAILS['Single Swing'].unitCost,
    [DRIVE_GATE_OPERATOR_DETAILS['Double Swing'].label]: DRIVE_GATE_OPERATOR_DETAILS['Double Swing'].unitCost,
    [DRIVE_GATE_OPERATOR_DETAILS['Sliding'].label]: DRIVE_GATE_OPERATOR_DETAILS['Sliding'].unitCost,
    'Drive gate power run (new wiring)': 2000,
    'Solar gate power kit': 500,
    'Sliding drive gate chain': 150,
    [POST_ANCHOR_PLATE_LABEL]: 3.24,
    [POST_ANCHOR_HARDWARE_LABEL]: 2,
    'panel mount bracket': 1.27,
    'powder coat panel': 40,
    'powder coat post': 10,
    '5 gal wood stain bucket': WOOD_STAIN_BUCKET_COSTS[DEFAULT_WOOD_STAIN_BRAND],
    '5 gal wood stain bucket (HueMiller)': WOOD_STAIN_BUCKET_COSTS['HueMiller'],
    '5 gal wood stain bucket (Ready Seal)': WOOD_STAIN_BUCKET_COSTS['Ready Seal'],
    '5 gal wood stain bucket (Wood Defender)': WOOD_STAIN_BUCKET_COSTS['Wood Defender'],
    'wood picket': 3.0,
    'wood picket (3.5")': 2.5,
    'wood picket (4")': 2.75,
    'wood picket (5.5")': 3.25,
    'wood picket (6")': 3.5,
    'wood rail (2x3, Pressure Treated)': 3.23,
    'wood rail (2x4, Cedar)': 9.33,
    'wood rail (2x4, Stained Cedar)': 10.81,
    'wood rail (2x3)': 10.81,
    'wood rail (2x4)': 10.81,
    'wood rail': 10.81
  };
  const PRICE_MISC_UNPRICED_LABELS = new Set([
    POST_ANCHOR_PLATE_LABEL,
    POST_ANCHOR_HARDWARE_LABEL
  ]);
  const SKID_STEER_WEEKLY_RATE = 1200;

  const WOOD_BOARD_PIECE_PRICING = {
    // Per-piece pricing and piece length (feet) for wood detail boards.
    'top cap': {
      '2x6': { lengthFt: 16, cost: 26.74 },
      '2x8': { lengthFt: 16, cost: 32.09 },
      '2x10': { lengthFt: 16, cost: 34.76 },
      '2x12': { lengthFt: 16, cost: 37.44 }
    },
    'kick board': {
      '2x6': { lengthFt: 16, cost: 17.54 },
      '2x8': { lengthFt: 16, cost: 21.05 },
      '2x10': { lengthFt: 16, cost: 22.80 },
      '2x12': { lengthFt: 16, cost: 24.56 }
    },
    'trim': {
      '1x4': { lengthFt: 8, cost: 5.76 },
      '1x2': { lengthFt: 8, cost: 5.76 }
    }
  };

  const PRICE = {
    paintGallon: 50,
    paintCan: 8,
    primerGallon: 50,
    primerCan: 8,
    concrete: 12,
    post2x2: { 8:18, 9:23.61 }
  };
  function money(n){ return Number(n||0).toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }
  function parseCurrencyInput(value){
    const cleaned = String(value || '').replace(/,/g, '');
    const num = parseFloat(cleaned);
    return isFinite(num) ? num : NaN;
  }

  const PRICING = {
    targetGrossMarginAfterOverhead: 0.30,
    minimumGrossMarginAfterOverhead: 0.20,
    maxGrossProfitPerDay: 1500,
    revenueMinimumResidential: 350,
    revenueMinimumCommercial: 2500,
    revenueMinimumFullDayHours: 9,
    revenueMinimumFullDay: 2967
  };
  const MANUAL_TRAVEL_FLAT = 50;

  function normalizeCustomerType(value){
    const raw = String(value || '').trim();
    if(!raw) return CUSTOMER_TYPES[0];
    const match = CUSTOMER_TYPES.find(option => option.toLowerCase() === raw.toLowerCase());
    return match || CUSTOMER_TYPES[0];
  }

  function getCustomerType(){
    if(customerTypeSelect){
      const rawSelectValue = String(customerTypeSelect.value || '').trim();
      if(rawSelectValue){
        return normalizeCustomerType(rawSelectValue);
      }
    }
    return normalizeCustomerType(state.customerType);
  }

  function formatPercentLabel(rate){
    const pct = Number(rate) * 100;
    if(!isFinite(pct)) return '';
    if(Number.isInteger(pct)) return `${pct}`;
    return pct.toFixed(1).replace(/\.0$/, '');
  }

  function getTargetGrossMarginRate(){
    const rate = Number(PRICING.targetGrossMarginAfterOverhead);
    return (isFinite(rate) && rate > 0 && rate < 1) ? rate : 0;
  }

  function getMinimumGrossMarginRate(){
    const rate = Number(PRICING.minimumGrossMarginAfterOverhead);
    return (isFinite(rate) && rate > 0 && rate < 1) ? rate : 0;
  }

  function getGrossProfitCapPerDay(){
    const cap = Number(PRICING.maxGrossProfitPerDay);
    return (isFinite(cap) && cap > 0) ? cap : 0;
  }

  function getGrossProfitCapDays(totalHours, explicitDayCount){
    const explicit = Number(explicitDayCount);
    if(isFinite(explicit) && explicit > 0){
      return Math.max(1, Math.ceil(explicit));
    }
    const dayHours = Math.max(0.25, Number(CREW_SETTINGS.maxDayHours || 9) || 9);
    const hours = Number(totalHours);
    if(!isFinite(hours) || hours <= 0){
      return 1;
    }
    return Math.max(1, Math.ceil(hours / dayHours));
  }

  function getGrossProfitCap(totalHours, explicitDayCount){
    const capPerDay = getGrossProfitCapPerDay();
    if(capPerDay <= 0) return null;
    return capPerDay * getGrossProfitCapDays(totalHours, explicitDayCount);
  }

  function getBaseRevenueMinimum(){
    const type = getCustomerType();
    if(type === 'Commercial' || type === 'City'){
      const commercialMin = Number(PRICING.revenueMinimumCommercial);
      return isFinite(commercialMin) && commercialMin > 0 ? commercialMin : null;
    }
    const residentialMin = Number(PRICING.revenueMinimumResidential);
    return isFinite(residentialMin) && residentialMin > 0 ? residentialMin : null;
  }

  function getRevenueMinimum(totalHours){
    const mins = [];
    const baseMinimum = getBaseRevenueMinimum();
    if(isFinite(baseMinimum) && baseMinimum > 0){
      mins.push(baseMinimum);
    }
    const hours = Number(totalHours);
    if(isFinite(hours) && hours >= PRICING.revenueMinimumFullDayHours){
      mins.push(PRICING.revenueMinimumFullDay);
    }
    if(!mins.length) return null;
    return Math.max(...mins);
  }

  function getMinimumLabelAndValue(){
    const revenueMin = getBaseRevenueMinimum();
    if(isFinite(revenueMin) && revenueMin > 0){
      return { label: 'Minimum charge', value: revenueMin };
    }
    return { label: 'Minimum charge', value: 0 };
  }

  function getMinimumSummaryText(){
    const revenueMin = getBaseRevenueMinimum();
    const targetMarginLabel = formatPercentLabel(getTargetGrossMarginRate());
    const minimumMarginLabel = formatPercentLabel(getMinimumGrossMarginRate());
    if(isFinite(revenueMin) && revenueMin > 0){
      return `${targetMarginLabel}% target gross margin after overhead, ${minimumMarginLabel}% minimum gross margin after overhead, $${money(revenueMin)} minimum charge`;
    }
    return `${targetMarginLabel}% target gross margin after overhead, ${minimumMarginLabel}% minimum gross margin after overhead`;
  }

  function updatePricingMinimumUI(){
    const minValue = getMinimumLabelAndValue();
    if(customerMinHint){
      customerMinHint.textContent = `${minValue.label}: $${money(minValue.value)}`;
    }
    updateManualQuote();
  }

  const RATES = {
    overhead:   0.25,
    overheadCap: 10000,
    overheadHighRevenueThreshold: 100000,
    overheadHighRevenueRate: 0.10,
    commission: 0.25,
    // Combined overhead + MCOR flat rate
    mcor:       0.00
  };

  function overheadAmountForRevenue(revenue){
    const value = Number(revenue);
    if(!isFinite(value) || value <= 0) return 0;
    if(value > RATES.overheadHighRevenueThreshold){
      return value * RATES.overheadHighRevenueRate;
    }
    return Math.min(value * RATES.overhead, RATES.overheadCap);
  }

  function grossProfitForRevenue(revenue, directCosts){
    const rev = Number(revenue);
    const costs = Number(directCosts);
    if(!isFinite(rev) || !isFinite(costs)) return NaN;
    return rev - costs - overheadAmountForRevenue(rev);
  }

  function solveRevenueForGrossProfitAmount(directCosts, targetGross){
    const costs = Number(directCosts);
    const target = Number(targetGross);
    if(!isFinite(costs) || costs < 0) return NaN;
    if(!isFinite(target) || target < 0) return NaN;

    const meetsTargetGross = (revenue)=>{
      const gross = grossProfitForRevenue(revenue, costs);
      return isFinite(gross) && gross >= target;
    };

    let low = 0;
    let high = Math.max(costs + target + 1, 100);
    let attempts = 0;
    while(!meetsTargetGross(high) && attempts < 60){
      high *= 2;
      attempts += 1;
      if(!isFinite(high) || high > 1e12){
        return NaN;
      }
    }
    if(!meetsTargetGross(high)) return NaN;

    for(let i=0;i<60;i++){
      const mid = (low + high) / 2;
      if(meetsTargetGross(mid)){
        high = mid;
      }else{
        low = mid;
      }
    }
    return high;
  }

  function solveRevenueForGrossProfitMargin(directCosts, marginFloor){
    const costs = Number(directCosts);
    const ratio = Number(marginFloor);
    if(!isFinite(costs) || costs < 0) return NaN;
    if(!isFinite(ratio) || ratio <= 0 || ratio >= 1) return NaN;
    if(costs === 0) return 0;

    const meetsMargin = (revenue)=>{
      const rev = Number(revenue);
      if(!isFinite(rev) || rev <= 0) return false;
      const gross = grossProfitForRevenue(rev, costs);
      return isFinite(gross) && gross >= (rev * ratio);
    };

    let low = 0;
    let high = Math.max(costs + 1, 100);
    let attempts = 0;
    while(!meetsMargin(high) && attempts < 60){
      high *= 2;
      attempts += 1;
      if(!isFinite(high) || high > 1e12){
        return NaN;
      }
    }
    if(!meetsMargin(high)) return NaN;

    for(let i=0;i<60;i++){
      const mid = (low + high) / 2;
      if(meetsMargin(mid)){
        high = mid;
      }else{
        low = mid;
      }
    }
    return high;
  }

  function computeChargeRevenue(directCosts, totalHours, options = {}){
    const cost = Number(directCosts);
    const hours = Number(totalHours);
    if(!isFinite(cost) || cost < 0) return { revenue: NaN, mode: 'invalid' };
    const targetMargin = getTargetGrossMarginRate();
    const minimumMargin = getMinimumGrossMarginRate();
    if(!isFinite(targetMargin) || targetMargin <= 0 || targetMargin >= 1
      || !isFinite(minimumMargin) || minimumMargin <= 0 || minimumMargin >= 1){
      return { revenue: NaN, mode: 'invalid-margin-target' };
    }

    let revenue = solveRevenueForGrossProfitMargin(cost, targetMargin);
    if(!isFinite(revenue) || revenue < 0){
      return { revenue: NaN, mode: 'invalid' };
    }

    const revenueMinimum = getRevenueMinimum(totalHours);
    if(isFinite(revenueMinimum) && revenueMinimum > revenue){
      revenue = revenueMinimum;
    }

    const grossProfitCapPerDay = getGrossProfitCapPerDay();
    const grossProfitCapDays = getGrossProfitCapDays(totalHours, options.dayCount);
    const grossProfitCap = getGrossProfitCap(totalHours, options.dayCount);
    const revenueForGrossProfitCap = (isFinite(grossProfitCap) && grossProfitCap >= 0)
      ? solveRevenueForGrossProfitAmount(cost, grossProfitCap)
      : NaN;
    const revenueForMinimumMargin = solveRevenueForGrossProfitMargin(cost, minimumMargin);
    const revenueBeforeGuards = revenue;
    let revenueAfterCap = revenue;
    if(isFinite(revenueForGrossProfitCap) && revenueForGrossProfitCap > 0 && revenueAfterCap > revenueForGrossProfitCap){
      revenueAfterCap = revenueForGrossProfitCap;
    }
    const grossCapApplied = (revenueBeforeGuards - revenueAfterCap) > 0.01;
    let revenueAfterMinimumMargin = revenueAfterCap;
    if(isFinite(revenueForMinimumMargin) && revenueForMinimumMargin > 0 && revenueAfterMinimumMargin < revenueForMinimumMargin){
      revenueAfterMinimumMargin = revenueForMinimumMargin;
    }
    const minimumGrossMarginApplied = (revenueAfterMinimumMargin - revenueAfterCap) > 0.01;
    revenue = revenueAfterMinimumMargin;
    if(isFinite(revenueMinimum) && revenueMinimum > revenue){
      revenue = revenueMinimum;
    }

    const grossProfit = grossProfitForRevenue(revenue, cost);
    const grossMarginAchieved = (isFinite(grossProfit) && revenue > 0)
      ? (grossProfit / revenue)
      : NaN;
    return {
      revenue,
      mode: 'gross-margin-target',
      targetMargin,
      hours,
      revenueMinimum,
      grossMarginAchieved,
      overheadAmount: overheadAmountForRevenue(revenue),
      minimumMargin,
      revenueForMinimumMargin,
      minimumGrossMarginApplied,
      grossProfitCapPerDay,
      grossProfitCapDays,
      grossProfitCap,
      grossCapApplied
    };
  }

  function setManualModal(open){
    if(!manualModal) return;
    manualModal.setAttribute('aria-hidden', open ? 'false' : 'true');
    manualModal.classList.toggle('is-open', !!open);

    if(open && manualCostInput){
      manualCostInput.focus();
      if(typeof manualCostInput.select === 'function'){
        manualCostInput.select();
      }
    }
  }

  function setImportModal(open){
    if(!importModal) return;
    importModal.setAttribute('aria-hidden', open ? 'false' : 'true');
    importModal.classList.toggle('is-open', !!open);

    if(open && importTextEl){
      importTextEl.focus();
      if(typeof importTextEl.select === 'function'){
        importTextEl.select();
      }
    }
  }

  function clearManualMetrics(){
    if(manualGrossOutput) manualGrossOutput.textContent = '';
    if(manualGrossHourOutput) manualGrossHourOutput.textContent = '';
    if(manualCommissionOutput) manualCommissionOutput.textContent = '';
    if(manualNetOutput) manualNetOutput.textContent = '';
  }

  function updateManualQuote(){
    if(!manualCostInput || !manualChargeOutput || !manualStatusEl || !manualModeChip) return;

    const raw = (manualCostInput.value || '').trim();
    if(!raw){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = '';
      delete manualStatusEl.dataset.state;
      clearManualMetrics();
      return;
    }

    const materialEquipmentCost = parseCurrencyInput(raw);
    if(!isFinite(materialEquipmentCost) || materialEquipmentCost < 0){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = 'Enter a valid non-negative cost amount.';
      manualStatusEl.dataset.state = 'error';
      clearManualMetrics();
      return;
    }

    const rawHours = manualHoursInput ? (manualHoursInput.value || '').trim() : '';
    const totalHours = parseFloat(rawHours);
    if(!isFinite(totalHours) || totalHours <= 0){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = '';
      manualStatusEl.dataset.state = 'error';
      clearManualMetrics();
      return;
    }

    const laborCost = totalHours * getActiveLaborRate();
    const travelCost = MANUAL_TRAVEL_FLAT;
    const totalCost = materialEquipmentCost + laborCost + travelCost;
    const pricing = computeChargeRevenue(totalCost, totalHours);
    if(!pricing || !isFinite(pricing.revenue)){
      manualChargeOutput.textContent = '';
      manualModeChip.style.display = 'none';
      manualStatusEl.textContent = 'Pricing inputs produced an invalid result. Check overhead, margin target, and costs.';
      manualStatusEl.dataset.state = 'error';
      clearManualMetrics();
      return;
    }

    const revenue = pricing.revenue;
    manualChargeOutput.textContent = '$' + money(revenue);
    manualModeChip.textContent = `${formatPercentLabel(getTargetGrossMarginRate())}% margin target`;
    manualModeChip.classList.remove('is-warn');
    manualModeChip.classList.add('is-info');
    manualModeChip.style.display = 'inline-block';
    manualStatusEl.textContent = '';
    manualStatusEl.dataset.state = 'success';

    const revenueExcludingMcor = revenue * (1 - RATES.mcor);
    const overheadAmount = overheadAmountForRevenue(revenue);
    const overheadAmountForCommission = overheadAmountForRevenue(revenueExcludingMcor);
    const commissionValue = RATES.commission * (revenueExcludingMcor - overheadAmountForCommission - totalCost);
    const grossProfit = revenue - totalCost - overheadAmount;
    const netProfit = grossProfit - commissionValue;

    if(manualGrossOutput) manualGrossOutput.textContent = '$' + money(grossProfit);
    if(manualCommissionOutput) manualCommissionOutput.textContent = '$' + money(commissionValue);
    if(manualNetOutput) manualNetOutput.textContent = '$' + money(netProfit);

    if(manualGrossHourOutput){
      if(isFinite(totalHours) && totalHours > 0){
        manualGrossHourOutput.textContent = '$' + money(grossProfit / totalHours);
      } else {
        manualGrossHourOutput.textContent = '';
      }
    }

  }

  async function generateNotes(eventOrOptions){
    let options = {};
    if(eventOrOptions && typeof eventOrOptions === 'object'){
      if('target' in eventOrOptions || 'currentTarget' in eventOrOptions){
        if(typeof eventOrOptions.preventDefault === 'function'){
          eventOrOptions.preventDefault();
        }
      }else{
        options = eventOrOptions;
      }
    }

    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
      autoGenerateTimer = null;
    }
    if(isGeneratingNotes){
      pendingNotesRegeneration = true;
      return;
    }
    isGeneratingNotes = true;
    pendingNotesRegeneration = false;

    const shouldScroll = !options.skipScroll;

    try{
      syncStateFromDOM();
      state.sections.forEach(s=>{ delete s._panelCalc; delete s._installCalc; delete s._woodPanelCalc; });

    // --- PANEL REPLACEMENT helpers ---
    const PANEL_PRICE = {
      // keyed as: `${feet}ft|p${psize}|style`
      // style key: 'base' for standard/extended (no finials); 'finials' when Extended Picket w/ Finials
      // puppy key: 'puppy' for Flat Top w/ Puppy Pickets
      'puppy': 111.37,
      '3|p1/2"|base': 59.91,
      '3|p5/8"|base': 59.91,
      '4|p1/2"|base': 64.48,
      '4|p5/8"|base': 72.11,
      '5|p1/2"|base': 66.39,
      '5|p5/8"|base': 66.39,
      '5|p1/2"|finials': 72.63,
      '5|p5/8"|finials': 91.75,
      '6|p1/2"|base': 76.35,
      '6|p5/8"|base': 94.57,
    };
    function feetFromHeightStr(h){ const m = String(h||'').match(/(\d+)/); return m? parseInt(m[1],10):0; }
    function pkey(feet, picketSize, style){
      if(/Puppy Pickets/i.test(style)){
        return 'puppy';
      }
      const ps = normalizeSize(picketSize);
      const p = (ps==='1/2"')? 'p1/2"' : (ps==='5/8"'? 'p5/8"' : `p${ps}`);
      const sKey = /Finials/i.test(style) ? 'finials' : 'base';
      return `${feet}|${p}|${sKey}`;
    }
    function collectPanelPuppyInsertInfo(list, fallbackSize){
      const sizes = new Map();
      let total = 0;
      if(!Array.isArray(list)) return { total, sizes };
      list.forEach(panel=>{
        if(!panel) return;
        const qty = parseInt(panel.qty,10) || 0;
        if(qty <= 0) return;
        if(!isPanelPuppyInsertStyle(panel.style)) return;
        const sizeLabel = normalizePuppyInsertSize(panel.picketSize || fallbackSize);
        total += qty;
        sizes.set(sizeLabel, (sizes.get(sizeLabel)||0) + qty);
      });
      return { total, sizes };
    }
    function isPrefabEligible(widthIn, railSize, picketSize){
      const rs = normalizeSize(railSize);
      const ps = normalizeSize(picketSize);
      return (parseInt(widthIn,10)||0) <= 96 && rs === '1"' && (ps==='1/2"' || ps==='5/8"');
    }
    function picketCountForWidth(widthIn, picketSize){
      const gap = 3 + 15/16; // 3.9375
      const ps = normalizeSize(picketSize);
      const widths = { '1/2"': 0.5, '5/8"': 0.625, '3/4"': 0.75, '1"': 1 };
      const pw = widths[ps] || 0.5;
      const stride = pw + gap/12; // inches to feet then combine? keep inches to avoid rounding
      // Work fully in inches
      const strideIn = (pw*1) * 1.0 + 3.9375; // picket width inches + gap inches
      return Math.max(1, Math.floor( (parseFloat(widthIn)||0 + 3.9375) / strideIn ));
    }
    const roundTo = (value, decimals = 1)=>{
      const factor = Math.pow(10, decimals);
      return Math.round((Number(value) || 0) * factor) / factor;
    };
    function parseWoodInches(value, fallback){
      const match = String(value||'').match(/(\d+(\.\d+)?)/);
      const num = match ? parseFloat(match[1]) : NaN;
      if(isFinite(num) && num > 0) return num;
      const fb = parseFloat(fallback);
      return isFinite(fb) && fb > 0 ? fb : 0;
    }
    function woodRailsForHeight(heightFt){
      if(!isFinite(heightFt) || heightFt <= 0) return 3;
      return 3;
    }
    function woodStyleUsesOverlapPickets(styleValue){
      return /(board on board|shadowbox)/i.test(String(styleValue || ''));
    }
    function woodPicketCountForWidth(widthIn, picketWidthIn, useOverlapCount){
      const width = parseFloat(widthIn) || 0;
      if(width <= 0) return 0;
      const divisor = useOverlapCount ? 3.5 : (parseFloat(picketWidthIn) || 0);
      if(divisor <= 0) return 0;
      const base = width / divisor;
      const withExtra = useOverlapCount ? base : (base * 1.1);
      return Math.ceil(withExtra);
    }
    function splitWoodTrimSizes(trimType){
      const raw = normalizeLabelText(trimType || '');
      if(!raw) return [];
      if(raw.includes('&')){
        return raw.split('&').map(part=> normalizeLabelText(part)).filter(Boolean);
      }
      return [raw];
    }
    function calcWoodPanelReplacement(section, panelCount){
      const panels = parseInt(panelCount||0,10) || 0;
      if(!section || panels <= 0) return null;
      const widthFtRaw = parseFloat(section.woodRepairPanelWidth||0) || 0;
      const widthFt = roundTo(widthFtRaw > 0 ? widthFtRaw : 8, 2);
      const widthIn = widthFt * 12;
      const picketWidthIn = parseWoodInches(section.woodPicketWidth, 5.5);
      const useOverlapCount = woodStyleUsesOverlapPickets(section.woodStyle || '');
      const picketsPerPanel = woodPicketCountForWidth(widthIn, picketWidthIn, useOverlapCount);
      const totalPickets = picketsPerPanel * panels;
      const heightFt = Math.max(0, feetFromStr(section.woodHeight || section.height));
      const railsPerPanel = woodRailsForHeight(heightFt);
      const totalRails = railsPerPanel * panels;
      const panelLf = roundTo(widthFt * panels, 2);
      const topCap = section.woodAddTopCap
        ? { size: section.woodTopCapSize || '2x6', lf: panelLf }
        : null;
      const trimSizes = section.woodAddTrim ? splitWoodTrimSizes(section.woodTrimType || 'Trim') : [];
      const trim = trimSizes.length ? { sizes: trimSizes, lf: panelLf } : null;
      const kickStack = parseInt(section.woodKickBoardStack||0,10) || 1;
      const kick = section.woodAddKickBoard
        ? { size: section.woodKickBoardSize || '2x6', stack: kickStack, lf: panelLf }
        : null;
      return {
        panels,
        widthFt,
        widthIn,
        panelLf,
        picketsPerPanel,
        totalPickets,
        railsPerPanel,
        totalRails,
        topCap,
        trim,
        kick
      };
    }

    const lines = [];
    const SERVICE_BUCKET_LABELS = {
      installation: 'Wrought Iron Installation',
      woodInstallation: 'Fence Installation',
      replacement: 'Wrought Iron Replacement',
      repairs: 'Wrought Iron Repairs',
      driveGateOperator: 'Drive Gate Operator Replacement',
      driveGateOperatorInstall: 'Drive Gate Operator Installation',
      slidingDriveGateRepairs: 'Sliding Drive Gate Repairs',
      painting: 'Wrought Iron Painting',
      railReplacement: 'Rail Replacement',
      woodRepairs: 'Wood Fence Repairs',
      woodStain: 'Wood Fence Staining'
    };
    const serviceBuckets = Object.keys(SERVICE_BUCKET_LABELS).reduce((acc, key)=>{
      acc[key] = [];
      return acc;
    }, {});
    const SERVICE_NAME_TO_BUCKET = {
      'Wrought Iron Fence Installation': 'installation',
      'Wood Fence Installation': 'woodInstallation',
      'Install New Fence Sections': 'installation',
      'Add Single Walk Gate': 'installation',
      'Add Double Walk Gate': 'installation',
      'Wrought Iron Fence Replacement': 'replacement',
      'Wood Fence Replacement': 'woodInstallation',
      'Remove Fence Sections': 'replacement',
      'Surface Preparation & Painting': 'painting',
      'Dig Out Encroaching Soil': 'repairs',
      'Replace Damaged Pickets': 'repairs',
      'Rail Patch Repairs': 'repairs',
      'Full Rail Replacement': 'repairs',
      'Full Rail Gap Filler': 'repairs',
      'Replace Fence Posts': 'repairs',
      'Realign Leaning Posts': 'repairs',
      'Finial Replacement': 'repairs',
      'Post Cap Replacement': 'repairs',
      'Install Prefab Panels': 'repairs',
      'Build Custom Panels': 'repairs',
      'Realign Walk Gates': 'repairs',
      'Replace Walk Gate Hardware': 'repairs',
      'Rebuild Walk Gates': 'repairs',
      'Drive Gate Operator Replacement': 'driveGateOperator',
      'Drive Gate Operator Installation': 'driveGateOperatorInstall',
      'Sliding Drive Gate Repairs': 'slidingDriveGateRepairs',
      'Add Diagonal Braces': 'repairs',
      'Install Puppy Picket Inserts': 'repairs',
      'Rail Replacement': 'railReplacement',
      'Wood Fence Repairs': 'woodRepairs',
      'Wood Fence Staining': 'woodStain',
      'Wood Fence Wash & Stain': 'woodStain',
      'Wood Fence Wash Hail & Stain': 'woodStain'
    };
    function ensureSentence(text){
      const trimmed = (text || '').trim();
      if(!trimmed) return '';
      return /[.!?]$/.test(trimmed) ? trimmed : `${trimmed}.`;
    }
    function addServiceLine(name, desc){
      if(!name || !desc) return;
      const normalizedName = name.trim();
      const bucket = SERVICE_NAME_TO_BUCKET[normalizedName]
        || (/^Fence Installation:/i.test(normalizedName) ? 'woodInstallation' : null)
        || (normalizedName.includes('Paint') ? 'painting' : 'repairs');
      const sentence = ensureSentence(desc);
      if(!sentence) return;
      if(!serviceBuckets[bucket]){
        serviceBuckets[bucket] = [];
      }
      if(bucket === 'woodInstallation'){
        serviceBuckets[bucket].push({ name: normalizedName, desc: sentence });
        return;
      }
      serviceBuckets[bucket].push(sentence);
    }
    function buildServiceLineOutput(){
      const output = [];
      Object.entries(SERVICE_BUCKET_LABELS).forEach(([key, label])=>{
        const parts = serviceBuckets[key] || [];
        if(!parts.length) return;
        if(key === 'woodInstallation'){
          parts.forEach(item=>{
            const title = (item && item.name) ? String(item.name).trim() : label;
            const desc = ensureSentence(item && item.desc ? String(item.desc) : '');
            if(title && desc){
              output.push({ name: title, desc });
            }
          });
          return;
        }
        let desc = parts.join(' ');
        if(key === 'repairs'){
          const disclaimer = 'The repairs listed are based on what was identified at the time of this estimate. Additional repairs may be required that were not visible or discoverable during inspection. If our crew identifies any additional issues on site, we will notify you for approval prior to proceeding, and any extra work will be billed at an additional cost.';
          desc = desc ? `${desc}\n\n${disclaimer}` : disclaimer;
        }
        output.push({ name: label, desc });
      });
      return output;
    }
    function describeCount(count, singular, plural){
      const n = parseInt(count,10) || 0;
      if(n <= 0) return '';
      const label = n === 1 ? singular : (plural || singular + 's');
      return `${n} ${label}`;
    }
    function summarizeWalkHardware(sections){
      const comboCounts = new Map();
      let total = 0;
      sections.forEach(sec=>{
        const count = parseInt(sec?.walkGatesHardware||0,10) || 0;
        if(count <= 0) return;
        total += count;
        const latch = (sec?.walkLatch || '').trim();
        const hinges = (sec?.walkHinges || '').trim();
        const key = `${latch}|||${hinges}`;
        comboCounts.set(key, (comboCounts.get(key)||0) + count);
      });
      const details = [];
      const combos = [];
      comboCounts.forEach((count, key)=>{
        const [latch, hinges] = key.split('|||');
        const labels = [latch, hinges].filter(Boolean).join(' + ') || 'hardware';
        const gateLabel = describeCount(count, 'gate', 'gates');
        details.push(`${labels}: ${gateLabel}`);
        combos.push({ count, latch, hinges });
      });
      return { total, details, combos };
    }
    function walkHardwareActionLines(summary){
      const lines = [];
      if(!summary || !(summary.total > 0)) return lines;
      const combos = Array.isArray(summary.combos) ? summary.combos : [];
      if(!combos.length){
        lines.push(`Replace hardware on ${describeCount(summary.total, 'walk gate', 'walk gates')}`);
        return lines;
      }
      combos.forEach(item=>{
        const count = parseInt(item?.count, 10) || 0;
        if(count <= 0) return;
        const gatesLabel = describeCount(count, 'walk gate', 'walk gates');
        const latch = String(item?.latch || '').trim().toLowerCase();
        const hinges = String(item?.hinges || '').trim().toLowerCase();
        let hardwareLabel = '';
        if(hinges && latch){
          hardwareLabel = `${hinges} and ${latch}`;
        } else if(hinges){
          hardwareLabel = hinges;
        } else if(latch){
          hardwareLabel = latch;
        }
        lines.push(`Replace hardware on ${gatesLabel}${hardwareLabel ? ` with ${hardwareLabel}` : ''}`);
      });
      return lines;
    }
    function paintColorPhrase(color, finishFirst){
      const normalized = normalizeLabelText(color || '').toLowerCase();
      if(!normalized) return '';
      if(finishFirst && /\bgloss\b/.test(normalized)){
        const remainder = normalized.replace(/\bgloss\b/g, '').replace(/\s+/g, ' ').trim();
        if(remainder) return `gloss ${remainder}`;
      }
      return normalized;
    }
    function fenceTypeLabel(type){
      const normalized = String(type||'').toLowerCase();
      if(normalized === 'wood') return 'Wood';
      if(normalized === 'chain link') return 'Chain Link';
      if(normalized === 'vinyl') return 'Vinyl';
      return 'Wrought Iron';
    }
    function fenceTypeDefaultDetail(type, includeRemoval){
      const actionPrefix = includeRemoval ? 'Remove existing fence and install new' : 'Install';
      const label = fenceTypeLabel(type);
      const postsSentence = includeRemoval
        ? `When new posts are needed, each section uses its selected post setting method: set in concrete 36" deep or anchor to concrete with 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post.`
        : `Each section uses its selected post setting method: set in concrete 36" deep or anchor to concrete with 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post.`;
      return `${actionPrefix} ${label.toLowerCase()} fence. ${postsSentence}`;
    }
    function buildWoodInstallationServiceLineTitle(sections){
      if(!Array.isArray(sections) || !sections.length){
        return 'Fence Installation';
      }
      const heights = new Set();
      const woodTypes = new Set();
      const constructions = new Set();
      const finishes = new Set();
      sections.forEach(section=>{
        const heightLabel = normalizeLabelText(section?.woodHeight || section?.height || '');
        const typeLabel = normalizeLabelText(section?.woodType || '');
        const constructionLabel = normalizeLabelText(section?.woodStyle || '');
        const finishLabel = normalizeLabelText(section?.woodFinish || '');
        if(heightLabel) heights.add(heightLabel);
        if(typeLabel) woodTypes.add(typeLabel);
        if(constructionLabel) constructions.add(constructionLabel);
        if(finishLabel) finishes.add(finishLabel);
      });
      const descriptor = [
        joinParts(Array.from(heights)),
        joinParts(Array.from(woodTypes)),
        joinParts(Array.from(constructions))
      ].filter(Boolean).join(' ').trim();
      const finishPart = joinParts(Array.from(finishes));
      if(descriptor && finishPart){
        return `Fence Installation: ${descriptor} (${finishPart})`;
      }
      if(descriptor){
        return `Fence Installation: ${descriptor}`;
      }
      if(finishPart){
        return `Fence Installation (${finishPart})`;
      }
      return 'Fence Installation';
    }
    function groupSectionsByFenceType(sections){
      const map = new Map();
      sections.forEach(sec=>{
        const type = (sec?.fenceType || 'Wrought Iron').toLowerCase();
        if(!map.has(type)) map.set(type, []);
        map.get(type).push(sec);
      });
      return map;
    }
    function joinParts(parts){
      const clean = parts.filter(Boolean);
      if(clean.length === 0) return '';
      if(clean.length === 1) return clean[0];
      if(clean.length === 2) return `${clean[0]} and ${clean[1]}`;
      return `${clean.slice(0,-1).join(', ')}, and ${clean[clean.length-1]}`;
    }
    function formatPrefabPanelType(info){
      const styleLabel = normalizeLabelText(info?.style || '') || 'Prefab';
      const railLabel = normalizeSize(info?.rail || '');
      const picketLabel = normalizeSize(info?.picket || '');
      const sizeParts = [];
      if(railLabel) sizeParts.push(`${railLabel} rails`);
      if(picketLabel) sizeParts.push(`${picketLabel} pickets`);
      const sizeText = sizeParts.length ? joinParts(sizeParts) : '';
      return [styleLabel, sizeText].filter(Boolean).join(' ').trim() || 'prefab panel';
    }
    function summarizePrefabPanelTypes(map){
      if(!map || typeof map.forEach !== 'function' || map.size === 0) return '';
      const parts = [];
      map.forEach(info=>{
        const count = parseInt(info?.count,10) || 0;
        if(count <= 0) return;
        const typeLabel = formatPrefabPanelType(info);
        parts.push(`${count} × ${typeLabel}`);
      });
      return parts.join('; ');
    }
    function formatFtValue(value){
      const n = parseFloat(value);
      if(!isFinite(n) || n <= 0) return '';
      return n
        .toFixed(2)
        .replace(/(\.\d*?)0+$/,'$1')
        .replace(/\.$/,'');
    }
    function buildInstallServiceDescription(sections, includeRemoval){
      if(!Array.isArray(sections) || !sections.length) return '';
      const fenceType = (sections[0]?.fenceType || 'Wrought Iron').toLowerCase();
      const isWood = fenceType === 'wood';
      const WOOD_RAIL_COUNT = 3;
      const parseStackCount = (value)=>{
        const stack = parseInt(value, 10) || 0;
        return stack > 0 ? stack : 1;
      };
      const formatStackLabel = (stack)=> `${stack} stack${stack === 1 ? '' : 's'}`;
      let totalLength = 0;
      const heights = new Set();
      const styles = new Set();
      const rails = new Set();
      const railSizes = new Set();
      const spacingConcrete = new Set();
      const spacingAnchored = new Set();
      const existingPostSpacing = new Set();
      const postSizes = new Set();
      const styleGroups = new Map();
      const woodKickBoards = new Set();
      const woodTopCaps = new Set();
      const woodTrims = new Set();
      let replacementReusePostSections = 0;
      let replacementNewPostSections = 0;
      let concreteSetSections = 0;
      let anchoredSections = 0;

      sections.forEach(section=>{
        const useExistingPostsForReplacement = includeRemoval && shouldUseExistingPostsForReplacement(section);
        if(useExistingPostsForReplacement){
          replacementReusePostSections += 1;
        } else {
          replacementNewPostSections += 1;
        }
        const len = parseInt(section.length,10) || 0;
        totalLength += len;
        const sectionHeight = isWood ? section.woodHeight : section.height;
        const sectionStyle = isWood ? section.woodStyle : section.style;
        if(sectionHeight){ heights.add(String(sectionHeight).trim()); }
        if(sectionStyle){ styles.add(String(sectionStyle).trim()); }
        const groupKey = (()=>{
          const height = sectionHeight ? String(sectionHeight).trim() : '';
          const style = sectionStyle ? String(sectionStyle).trim() : '';
          return JSON.stringify({ height, style });
        })();
        if(!styleGroups.has(groupKey)){
          styleGroups.set(groupKey, {
            length: 0,
            height: sectionHeight ? String(sectionHeight).trim() : '',
            style: sectionStyle ? String(sectionStyle).trim() : '',
            postSizes: new Set(),
            picketSizes: new Set(),
            railSizes: new Set(),
            kickBoards: new Set(),
            topCaps: new Set(),
            trims: new Set()
          });
        }
        const group = styleGroups.get(groupKey);
        if(len > 0){
          group.length += len;
        }
        if(isWood){
          rails.add(`${WOOD_RAIL_COUNT} rails`);
        } else {
          const rCount = parseInt(section.railsCount,10) || (Array.isArray(section.rails) ? section.rails.length : 0);
          if(rCount > 0){ rails.add(`${rCount} rail${rCount === 1 ? '' : 's'}`); }
        }
        if(isWood && section.woodRailSize){
          const normalized = normalizeSize(section.woodRailSize);
          railSizes.add(normalized);
          group.railSizes.add(normalized);
        } else if(Array.isArray(section.rails) && section.rails.length){
          section.rails.forEach(r=>{
            if(r && r.size){
              const normalized = normalizeSize(r.size);
              railSizes.add(normalized);
              group.railSizes.add(normalized);
            }
            if(r && r.stacked && r.size2){
              const normalized = normalizeSize(r.size2);
              railSizes.add(normalized);
              group.railSizes.add(normalized);
            }
          });
        } else if(section.railSize){
          const normalized = normalizeSize(section.railSize);
          railSizes.add(normalized);
          group.railSizes.add(normalized);
          if(section.railStacked && section.railSize2){
            const normalizedStack = normalizeSize(section.railSize2);
            railSizes.add(normalizedStack);
            group.railSizes.add(normalizedStack);
          }
        }
        const postSizeVal = isWood ? section.woodPost : section.postSize;
        if(postSizeVal && !useExistingPostsForReplacement){
          const normalized = normalizeSize(postSizeVal);
          postSizes.add(normalized);
          group.postSizes.add(normalized);
        }
        if(isWood){
          if(section.woodPicketWidth){
            group.picketSizes.add(normalizeSize(section.woodPicketWidth));
          }
          if(section.woodAddKickBoard){
            const kickSize = normalizeSize(section.woodKickBoardSize || '2x6') || '2x6';
            const kickStack = parseStackCount(section.woodKickBoardStack);
            const kickLabel = `${kickSize}, ${formatStackLabel(kickStack)}`;
            group.kickBoards.add(kickLabel);
            woodKickBoards.add(kickLabel);
          }
          if(section.woodAddTopCap){
            const topCapSize = normalizeSize(section.woodTopCapSize || '2x6') || '2x6';
            group.topCaps.add(topCapSize);
            woodTopCaps.add(topCapSize);
          }
          if(section.woodAddTrim){
            const trimSizes = splitWoodTrimSizes(section.woodTrimType || '1x4');
            trimSizes.forEach(size=>{
              const trimSize = normalizeSize(size || '');
              if(!trimSize) return;
              group.trims.add(trimSize);
              woodTrims.add(trimSize);
            });
          }
        } else if(section.picketSize){
          group.picketSizes.add(normalizeSize(section.picketSize));
        }
        if(!useExistingPostsForReplacement){
          const postInstallMethod = normalizePostInstallMethod(section.postInstallMethod);
          if(postInstallMethod === 'anchored'){
            anchoredSections += 1;
          } else {
            concreteSetSections += 1;
          }
          const spacingCandidate = isWood
            ? woodInstallPostSpacingFt(section)
            : ((section._installCalc && section._installCalc.spacingFt) || parseFloat(section.postSpacing||''));
          const spacingStr = formatFtValue(spacingCandidate);
          if(spacingStr){
            if(postInstallMethod === 'anchored'){
              spacingAnchored.add(spacingStr);
            } else {
              spacingConcrete.add(spacingStr);
            }
          }
        } else {
          const spacingCandidate = isWood
            ? woodReplacementPostSpacingFt(section)
            : ((section._installCalc && section._installCalc.spacingFt) || parseFloat(section.postSpacing||''));
          const spacingStr = formatFtValue(spacingCandidate);
          if(spacingStr){ existingPostSpacing.add(spacingStr); }
        }
      });

      const descriptorParts = [];
      if(heights.size){
        const heightLabel = joinParts(Array.from(heights).map(h=> `${h} tall`));
        descriptorParts.push(heightLabel);
      }
      const fenceLabel = isWood ? 'wood fence' : 'wrought iron fence';
      const styleLabel = styles.size ? `${joinParts(Array.from(styles))} fence` : fenceLabel;
      descriptorParts.push(styleLabel);
      const descriptor = descriptorParts.filter(Boolean).join(' ').trim();

      const withParts = [];
      if(rails.size){ withParts.push(joinParts(Array.from(rails))); }
      const withText = withParts.length ? ` with ${joinParts(withParts)}` : '';
      const actionPrefix = includeRemoval ? 'Remove existing fence and install' : 'Install';
      const breakdownParts = Array.from(styleGroups.values())
        .filter(item=>item.length > 0)
        .map(item=>{
          const heightLabel = item.height ? `${item.height} tall` : '';
          const styleLabel = item.style || (isWood ? 'wood' : 'wrought iron');
          const phraseParts = [heightLabel, `${styleLabel}${/fence/i.test(styleLabel)?'':' fence'}`].filter(Boolean);
          const postDetail = item.postSizes.size ? `posts: ${joinParts(Array.from(item.postSizes))}` : '';
          const picketDetail = item.picketSizes.size ? `pickets: ${joinParts(Array.from(item.picketSizes))}` : '';
          const railDetail = item.railSizes.size ? `rails: ${joinParts(Array.from(item.railSizes).map(v=> `${v}`))}` : '';
          const kickDetail = isWood && item.kickBoards.size ? `kick board: ${joinParts(Array.from(item.kickBoards))}` : '';
          const topCapDetail = isWood && item.topCaps.size ? `top cap: ${joinParts(Array.from(item.topCaps))}` : '';
          const trimDetail = isWood && item.trims.size ? `trim: ${joinParts(Array.from(item.trims))}` : '';
          const detailParts = [postDetail, picketDetail, railDetail, kickDetail, topCapDetail, trimDetail].filter(Boolean);
          const detailText = detailParts.length ? ` (${detailParts.join('; ')})` : '';
          return `${item.length}ft of ${phraseParts.join(' ')}${detailText}`;
        });
      let firstSentence = '';
      if(breakdownParts.length){
        firstSentence = `${actionPrefix} ${joinParts(breakdownParts)}${withText}.`;
      } else {
        const lengthText = totalLength > 0 ? `${totalLength}ft` : '';
        firstSentence = lengthText
          ? `${actionPrefix} ${lengthText} of ${descriptor}${withText}.`
          : `${actionPrefix} ${descriptor}${withText}.`;
      }

      const spacingValuesConcrete = Array.from(spacingConcrete).sort((a,b)=> parseFloat(a) - parseFloat(b));
      const spacingValuesAnchored = Array.from(spacingAnchored).sort((a,b)=> parseFloat(a) - parseFloat(b));
      const railSizeValues = Array.from(railSizes).filter(Boolean);
      const postSizeValues = Array.from(postSizes).filter(Boolean);
      let postsSentence = '';
      if(replacementReusePostSections > 0 && replacementNewPostSections === 0){
        const spacingValues = Array.from(existingPostSpacing).sort((a,b)=> parseFloat(a) - parseFloat(b));
        if(spacingValues.length === 1){
          postsSentence = `Use existing posts (${spacingValues[0]}ft spacing; no new post set or anchoring).`;
        } else if(spacingValues.length > 1){
          const spacingLabels = spacingValues.map(v=> `${v}ft`);
          postsSentence = `Use existing posts (${joinParts(spacingLabels)} spacing mix; no new post set or anchoring).`;
        } else {
          postsSentence = 'Use existing posts (no new post set or anchoring).';
        }
      } else {
        const postSizeLabel = postSizeValues.length ? ` (${joinParts(postSizeValues)})` : '';
        const methodSentences = [];
        if(concreteSetSections > 0){
          if(spacingValuesConcrete.length === 1){
            methodSentences.push(`Posts${postSizeLabel} will be spaced ${spacingValuesConcrete[0]}ft apart and set in concrete 36\" deep.`);
          } else if(spacingValuesConcrete.length > 1){
            const spacingLabels = spacingValuesConcrete.map(v=> `${v}ft`);
            methodSentences.push(`Posts${postSizeLabel} will be spaced between ${joinParts(spacingLabels)} apart and set in concrete 36\" deep.`);
          } else {
            methodSentences.push(`Posts${postSizeLabel} will be set in concrete 36\" deep.`);
          }
        }
        if(anchoredSections > 0){
          if(spacingValuesAnchored.length === 1){
            methodSentences.push(`Posts${postSizeLabel} will be spaced ${spacingValuesAnchored[0]}ft apart and anchored to concrete with 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post.`);
          } else if(spacingValuesAnchored.length > 1){
            const spacingLabels = spacingValuesAnchored.map(v=> `${v}ft`);
            methodSentences.push(`Posts${postSizeLabel} will be spaced between ${joinParts(spacingLabels)} apart and anchored to concrete with 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post.`);
          } else {
            methodSentences.push(`Posts${postSizeLabel} will be anchored to concrete with 1x ${POST_ANCHOR_PLATE_LABEL} and 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post.`);
          }
        }
        postsSentence = methodSentences.join(' ');
      }

      let railSentence = '';
      if(!isWood && railSizeValues.length){
        railSentence = `Rails will use ${joinParts(railSizeValues)}.`;
      }

      let woodAddOnSentence = '';
      if(isWood && !breakdownParts.length){
        const addOnParts = [];
        if(woodKickBoards.size){
          addOnParts.push(`kick board (${joinParts(Array.from(woodKickBoards))})`);
        }
        if(woodTopCaps.size){
          addOnParts.push(`top cap (${joinParts(Array.from(woodTopCaps))})`);
        }
        if(woodTrims.size){
          addOnParts.push(`trim (${joinParts(Array.from(woodTrims))})`);
        }
        if(addOnParts.length){
          woodAddOnSentence = `Include wood add-ons: ${addOnParts.join('; ')}.`;
        }
      }

      const mixedPostHandlingSentence = (replacementReusePostSections > 0 && replacementNewPostSections > 0)
        ? 'Replacement sections marked to use existing posts exclude new post set or anchoring.'
        : '';
      return [firstSentence, postsSentence, railSentence, woodAddOnSentence, mixedPostHandlingSentence].filter(Boolean).join(' ');
    }
    const zeroPostCounts = ()=>({ posts1p5:0, posts2x2:0, posts3x3:0, posts4x4:0 });
    const countWoodRealignMethods = (entries=[])=>{
      return entries.reduce((acc, item)=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        const method = String(item?.method||'').toLowerCase();
        if(method === 'cut-weld'){
          acc.cutWeld += qty;
        } else {
          acc.dig += qty;
        }
        return acc;
      }, { dig: 0, cutWeld: 0 });
    };
    const zeroWoodMethodCounts = ()=>({ 'drive-posts': 0, 'dig-set-concrete': 0 });
    const addWoodMethodCount = (bucket, method, count)=>{
      if(!bucket) return;
      const qty = parseInt(count, 10) || 0;
      if(qty <= 0) return;
      const normalized = String(method || '').toLowerCase();
      const key = normalized === 'drive-posts' ? 'drive-posts' : 'dig-set-concrete';
      bucket[key] = (bucket[key] || 0) + qty;
    };
    const totals = {
      length:0, hardscape:0, trim:0, digOut:0, finials:0, caps:0,
      puppyInserts:0,
      diagonalBraces:0,
      wiPickets:0, wiPatches:0, wiRails:0, wiRailGaps:0, weldRedos:0,
      puppyPickets:0,
      wiPicketSizes: new Set(),
      wiPatchSizes: new Set(),
      wiRailReplaceSizes: new Set(),
      wiRailGapSizes: new Set(),
      diagonalBraceSizes: new Map(),
      puppyInsertSizes: new Map(),
      puppyPicketDetails: new Map(),
      woodPicketReplace:0, woodPicketInstall:0, woodRailReplace:0, woodRailInstall:0,
      woodPostReplace6:0, woodPostReplace8:0, woodPostRealignCutWeld:0, woodPostRealignDig:0,
      woodPostInstall:0, woodPanels:0, woodGateRepair:0, woodGateStrengthen:0, woodGateReplace:0,
      woodTopCapLf:0, woodTrimLf:0, woodKickLf:0, woodStainSqft:0,
      posts2x2:0, posts3x3:0, posts1p5:0, posts4x4:0, postsRealign2x2:0, postsRealign3x3:0, postsRealignCutWeld:0, postsRealignCutWeldBySize: zeroPostCounts(),
      retainingWallPosts: zeroPostCounts(),
      walkGates:0, walkRealign:0, walkHardware:0, walkRebuild:0,
      walkGateAdds:0,
      walkGateAddsSingle:0,
      walkGateAddsDouble:0,
      walkGateAddsRepair:0,
      walkGateAddsInstall:0,
      woodWalkGateAdds:0,
      woodWalkGateAddsSingle:0,
      woodWalkGateAddsDouble:0,
      woodWalkGateAddsRepair:0,
      woodWalkGateAddsInstall:0,
      driveGateChainReplacements:0,
      driveGateOperators:0,
      driveGateOperatorTypes: new Map(),
      driveGateOperatorPowers: new Map(),
      driveGateOperatorCombos: new Map(),
      driveGateOperatorInstalls:0,
      driveGateOperatorInstallTypes: new Map(),
      driveGateOperatorInstallPowers: new Map(),
      driveGateOperatorInstallCombos: new Map(),
      driveGateOperatorInstallPlatforms:0,
      retainingWallSqft:0,
      retainingWallCost:0,
      panelsPrefab:0, panelsCustom:0,
      panelsInstallPrefab:0, panelsInstallCustom:0,
      panelsInstallCustomShop:0, panelsInstallCustomOnSite:0, panelsInstallCustomTmi:0,
      powderCoatPanels:0, powderCoatPosts:0,
      prefabPanelTypesRepair: new Map(),
      installSections:0, replaceSections:0,
      wroughtInstallSections:0, wroughtReplaceSections:0,
      removalLf:0, removalCost:0,
      postsInstall: zeroPostCounts(),
      postsInstallConcrete: zeroPostCounts(),
      postsInstallAnchored: zeroPostCounts(),
      postsReplace: zeroPostCounts(),
      woodPostInstallMethods: zeroWoodMethodCounts()
    };
    const woodBoardReplaceLf = {
      topCap: new Map(),
      trim: new Map(),
      kick: new Map()
    };
    const woodInstallPlan = {
      sections: 0,
      totalLf: 0,
      removalLf: 0,
      removalSubLf: 0,
      removalSubCost: 0,
      totalPosts: 0,
      totalTallPosts: 0,
      totalBuildLfAdjusted: 0,
      totalTopCapPieces: 0,
      totalRails: 0,
      totalPickets: 0,
      removalCrewHours: 0,
      removalManHours: 0,
      postCrewHours: 0,
      postManHours: 0,
      cureWaitCrewHours: 0,
      cureWaitManHours: 0,
      buildCrewHours: 0,
      buildManHours: 0,
      removalDays: 0,
      postDays: 0,
      buildDays: 0,
      skidDays: 0
    };
    let hasWoodStaining = false;
    let hasWoodWashSelection = false;
    let hasWroughtRepair = false;
    let wroughtInstallRemovalPanels = 0;
    const woodStainDetails = [];
    const woodStainServiceDetails = [];
    const woodWashDetails = [];
    const materials = {};
    const installCapsByLabel = new Map();
    const picketStickTotals = {};
    const railStickTotals = {};
    const steelStickTotals = { raw1p5:{}, raw2x2:{}, raw3x3:{}, raw4x4:{} };
    const diagonalBraceFeetBySize = {};
    const stickTotalKey = (lengthFt, sizeLabel)=> `${lengthFt}|${sizeLabel}`;

    const addPicketSticks = (size, qty, stickLengthFt = 12) => {
      if(!qty || qty <= 0) return;
      const normalized = normalizeSize(size);
      const labelSize = normalized || normalizeLabelText(size);
      const lengthFt = wroughtCustomStickLengthFt(stickLengthFt);
      addMat(materials, `${lengthFt}ft picket sticks (${labelSize})`, qty);
      const key = stickTotalKey(lengthFt, labelSize);
      picketStickTotals[key] = (picketStickTotals[key]||0) + qty;
    };

    const addRailSticks = (size, qty, stickLengthFt = 12) => {
      if(!qty || qty <= 0) return;
      const normalized = normalizeSize(size);
      const labelSize = normalized || normalizeLabelText(size);
      const lengthFt = wroughtCustomStickLengthFt(stickLengthFt);
      addMat(materials, `${lengthFt}ft rail sticks (${labelSize})`, qty);
      const key = stickTotalKey(lengthFt, labelSize);
      railStickTotals[key] = (railStickTotals[key]||0) + qty;
    };
    const steelStickLabelForKind = (kind, lengthFt)=>{
      const normalizedLength = wroughtCustomStickLengthFt(lengthFt);
      if(kind === 'raw1p5') return `1.5x1.5x${normalizedLength} raw steel`;
      if(kind === 'raw2x2') return `2x2x${normalizedLength} raw steel`;
      if(kind === 'raw3x3') return `3x3x${normalizedLength} raw steel`;
      return `4x4x${normalizedLength} raw steel`;
    };
    const addSteelRawSticks = (kind, qty, stickLengthFt = 12)=>{
      const normalizedKind = Object.prototype.hasOwnProperty.call(steelStickTotals, kind) ? kind : 'raw1p5';
      const count = Math.max(0, parseInt(qty, 10) || 0);
      if(count <= 0) return;
      const lengthFt = wroughtCustomStickLengthFt(stickLengthFt);
      const current = steelStickTotals[normalizedKind][lengthFt] || 0;
      steelStickTotals[normalizedKind][lengthFt] = current + count;
      addMat(materials, steelStickLabelForKind(normalizedKind, lengthFt), count);
    };
    let manHours = 0;
    let welderHours = 0;
    let helperHours = 0;
    let shopFabricationLaborHours = 0;
    let weldedPanelHours = 0;
    let bracketPanelHours = 0;
    let wroughtInstallPanelCrewHours = 0;
    let wroughtInstallPanelLf = 0;
    let woodHelperHours = 0;
    let woodWelderHours = 0;
    let woodManHours = 0;
    let woodStainHours = 0;
    let woodWashHours = 0;
    let woodRequiresTwoPerson = false;
    const woodStainSqftByBrand = new Map();
    const woodSectionSummaries = [];
    const parseWoodStainSelection = (value)=>{
      const raw = String(value || 'none').trim();
      if(!raw || raw === 'none'){
        return { side: 'none', wash: 'none' };
      }
      if(raw.startsWith('wash-hail-')){
        return { side: raw.replace('wash-hail-','') || 'both', wash: 'hail' };
      }
      if(raw.startsWith('wash-')){
        return { side: raw.replace('wash-','') || 'both', wash: 'standard' };
      }
      return { side: raw, wash: 'none' };
    };

    state.sections.forEach((s, idx)=>{
      const title  = s.label ? `Section ${idx+1} - ${s.label}` : `Section ${idx+1}`;
      const picket = s.picketHeight ? `${s.picketSize} (height ${s.picketHeight} in)` : `${s.picketSize}`;
      const puppyPicketDetail = puppyPicketDetailLabel(s.puppyPicketSize, s.puppyPicketHeight);
      const gapAdditionsArr = Array.isArray(s.gapAdditions) ? s.gapAdditions : [];
      const diagonalBracesArr = Array.isArray(s.diagonalBraces) ? s.diagonalBraces : [];
      const braceCountByLabel = new Map();
      let braceTotalQty = 0;
      diagonalBracesArr.forEach(item=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        if(!qty) return;
        braceTotalQty += qty;
        const rawSize = item?.size || '';
        const normalized = normalizeSize(rawSize);
        const label = normalized ? normalizeLabelText(normalized) : normalizeLabelText(rawSize) || rawSize || 'picket steel';
        const displayLabel = label || 'picket steel';
        braceCountByLabel.set(displayLabel, (braceCountByLabel.get(displayLabel)||0) + qty);
        if(normalized){
          const prevCount = totals.diagonalBraceSizes.get(normalized) || 0;
          totals.diagonalBraceSizes.set(normalized, prevCount + qty);
          diagonalBraceFeetBySize[normalized] = (diagonalBraceFeetBySize[normalized]||0) + qty * 4;
        }
      });
      if(braceTotalQty > 0){
        totals.diagonalBraces += braceTotalQty;
      }
      const braceLineParts = [];
      braceCountByLabel.forEach((qty,label)=>{ braceLineParts.push(`${qty} × ${label}`); });

      const scopeType = (s.scopeType || 'repair');
      const fenceType = (s.fenceType || '').toLowerCase();
      const isWood = fenceType === 'wood';
      const isWrought = fenceType === 'wrought iron';
      const isInstall = scopeType === 'install' || scopeType === 'replace';
      const isRepair = !isInstall;
      const woodRailLengthFt = (isWood && isInstall) ? woodInstallRailLengthFt(s) : 0;
      const railsDesc = isWood
        ? (s.woodRailSize || '-')
        : (Array.isArray(s.rails) && s.rails.length)
          ? (()=>{
              const labels = railLabels(s.railsCount || s.rails.length);
              return s.rails.slice(0, s.railsCount || s.rails.length).map((r,i)=>
                r && r.stacked
                  ? `${labels[i]}: ${r.size} + ${r.size2} (stacked)`
                  : `${labels[i]}: ${r.size}`
              ).join('; ');
            })()
          : (s.railStacked ? `${s.railSize} + ${s.railSize2} (stacked)` : `${s.railSize}`);
      if(isRepair && isWrought){
        hasWroughtRepair = true;
      }
      if(scopeType === 'install'){ totals.installSections += 1; }
      if(scopeType === 'replace'){ totals.replaceSections += 1; }
      if(isWrought && scopeType === 'install'){ totals.wroughtInstallSections += 1; }
      if(isWrought && scopeType === 'replace'){ totals.wroughtReplaceSections += 1; }
      if(isWood && scopeType === 'replace'){
        const removalLengthFt = Math.max(0, parseFloat(s.length || 0) || 0);
        if(removalLengthFt > 0){
          woodInstallPlan.removalLf += removalLengthFt;
        }
      }

      let installInfo = null;
      if(isInstall && isWrought){
        const useExistingPostsForReplacement = shouldUseExistingPostsForReplacement(s);
        const postInstallMethod = normalizePostInstallMethod(s.postInstallMethod);
        const lengthFt = parseInt(s.length||0,10) || 0;
        const spacingRaw = parseFloat(s.postSpacing||'8');
        const spacingFt = (isFinite(spacingRaw) && spacingRaw > 0) ? spacingRaw : 8;
        let spanCount = 0;
        if(lengthFt > 0){ spanCount = Math.max(1, Math.ceil(lengthFt / spacingFt)); }
        const postsTotal = useExistingPostsForReplacement ? 0 : (spanCount > 0 ? spanCount + 1 : (lengthFt > 0 ? 2 : 0));
        const installCounts = zeroPostCounts();
        const pKey = postSizeKey(s.postSize);
        if(pKey && postsTotal > 0){ installCounts[pKey] = postsTotal; }

        const panelWidths = [];
        if(spanCount > 0){
          const standardWidthIn = Math.max(12, Math.round(spacingFt * 12));
          for(let iPanel=0; iPanel<spanCount; iPanel++){
            if(iPanel === spanCount - 1){
              const consumed = spacingFt * (spanCount - 1);
              const remainingFt = lengthFt - consumed;
              const widthIn = Math.max(12, Math.round((remainingFt>0 ? remainingFt : spacingFt) * 12));
              panelWidths.push(widthIn);
            } else {
              panelWidths.push(standardWidthIn);
            }
          }
        }

        const finialStyle = allowInstallFinials(s.style, s.puppy)
          ? (s.installFinialStyle || SEED.finialStyles[0])
          : '';

        const gateAddsForInstall = walkGateAddCount(s);
        const gatePostKey = postSizeKey(s.walkAddPostSize || s.postSize);
        if(!useExistingPostsForReplacement && gateAddsForInstall>0 && gatePostKey){
          installCounts[gatePostKey] = (installCounts[gatePostKey]||0) + gateAddsForInstall;
        }
        if(!useExistingPostsForReplacement){
          addPostCounts(totals.postsInstall, installCounts);
          if(postInstallMethod === 'anchored'){
            addPostCounts(totals.postsInstallAnchored, installCounts);
          } else {
            addPostCounts(totals.postsInstallConcrete, installCounts);
          }
          addPostCounts(totals, installCounts);
        }

        installInfo = {
          lengthFt,
          spacingFt,
          spanCount,
          postsTotal,
          postCounts: installCounts,
          panelWidths,
          attachment: s.panelAttachment || 'Welding',
          panelFabrication: normalizeWroughtPanelFabrication(s.wroughtPanelFabrication),
          powderCoatPanels: !!s.wroughtPowderCoatPanels,
          powderCoatPosts: !!s.wroughtPowderCoatPosts,
          postInstallMethod,
          useExistingPosts: useExistingPostsForReplacement,
          finialStyle,
          customPanels: 0,
          prefabPanels: 0,
          removalCost: 0
        };

        if(!useExistingPostsForReplacement && gateAddsForInstall>0){
          installInfo.postsTotal += gateAddsForInstall;
        }

        if(scopeType === 'replace' && lengthFt > 0){
          const removalCost = lengthFt * 3.9;
          installInfo.removalCost = removalCost;
          totals.removalLf += lengthFt;
          totals.removalCost += removalCost;
          wroughtInstallRemovalPanels += Math.max(1, spanCount);
        }

        const autoCaps = [];
        const defaultCapStyle = (SEED.capStyles && SEED.capStyles[0]) || 'Pyramid';
        const defaultCapMaterial = (SEED.capMaterials && SEED.capMaterials[0]) || 'Cast Iron';
        Object.entries(installInfo.postCounts || {}).forEach(([postKey, count])=>{
          const qty = parseInt(count,10) || 0;
          if(qty <= 0) return;
          const postSizeLabel = postKeyToLabel(postKey) || (s.postSize || '2x2');
          const capLabel = `caps - ${defaultCapMaterial} - ${defaultCapStyle} (${postSizeLabel})`;
          addMat(materials, capLabel, qty);
          installCapsByLabel.set(capLabel, (installCapsByLabel.get(capLabel)||0) + qty);
          autoCaps.push({ count: qty, postSize: postSizeLabel, style: defaultCapStyle, material: defaultCapMaterial });
        });
        if(autoCaps.length){
          installInfo.autoCaps = autoCaps;
        }
      }

      if(isInstall && (fenceType === 'wrought iron' || fenceType === 'wood')){
        const wallLength = parseFloat(s.retainingWallLength || 0) || 0;
        const wallHeight = parseFloat(s.retainingWallHeight || 0) || 0;
        if(wallLength > 0 && wallHeight > 0){
          const lengthFtForWall = parseInt(s.length||0,10) || 0;
          const spacingRawForWall = isWood ? woodInstallPostSpacingFt(s) : parseFloat(s.postSpacing||'8');
          const spacingFtForWall = (isFinite(spacingRawForWall) && spacingRawForWall > 0) ? spacingRawForWall : 8;
          const spanCountForWall = lengthFtForWall > 0 ? Math.max(1, Math.ceil(lengthFtForWall / spacingFtForWall)) : 0;
          const postsTotalForWall = spanCountForWall > 0 ? spanCountForWall + 1 : (lengthFtForWall > 0 ? 2 : 0);
          const gateAddsForInstallForWall = walkGateAddCount(s);
          const useExistingPostsForReplacement = shouldUseExistingPostsForReplacement(s);
          if(!useExistingPostsForReplacement){
            const wallPostCounts = zeroPostCounts();
            const wallPostKey = isWood ? postSizeKey(s.woodPost) : postSizeKey(s.postSize);
            if(wallPostKey){
              const wallSpanCount = Math.max(1, Math.ceil(wallLength / spacingFtForWall));
              const wallPostsTotal = wallSpanCount > 0 ? wallSpanCount + 1 : 0;
              const maxPostsAvailable = postsTotalForWall + gateAddsForInstallForWall;
              const postsForWall = Math.min(maxPostsAvailable, wallPostsTotal);
              if(postsForWall > 0){
                wallPostCounts[wallPostKey] = postsForWall;
                addPostCounts(totals.retainingWallPosts, wallPostCounts);
              }
            }
          }
          const wallSqft = wallLength * wallHeight;
          const wallCost = Math.max(wallSqft * 35, 1500);
          totals.retainingWallSqft += wallSqft;
          totals.retainingWallCost += wallCost;
        }
      }

      let sectionPatchTotal = 0;
      let sectionReplTotal = 0;
      let sectionGapTotal = 0;
      const sectionPatchSizes = new Set();
      const sectionReplSizes = new Set();
      const sectionGapSizes = new Set();
      const gapCountByLabel = new Map();
      if(isRepair){
        const railsArr = (s.rails||[]).slice(0, s.railsCount||0);
        railsArr.forEach(r=>{
          const patchCount = parseInt(r?.patches||0,10) || 0;
          const replCount = parseInt(r?.replacements||0,10) || 0;
          const primarySize = normalizeSize(r?.size);
          const secondarySize = r?.stacked ? normalizeSize(r?.size2) : '';
          if(patchCount){
            sectionPatchTotal += patchCount;
            if(primarySize) sectionPatchSizes.add(primarySize);
            if(secondarySize) sectionPatchSizes.add(secondarySize);
          }
          if(replCount){
            sectionReplTotal += replCount;
            if(primarySize) sectionReplSizes.add(primarySize);
            if(secondarySize) sectionReplSizes.add(secondarySize);
          }
        });
        gapAdditionsArr.forEach(item=>{
          const qty = parseInt(item?.qty||0,10) || 0;
          if(!qty) return;
          sectionGapTotal += qty;
          const rawSize = item?.size || '';
          const normalized = normalizeSize(rawSize);
          if(normalized) sectionGapSizes.add(normalized);
          const label = normalized ? normalizeLabelText(normalized) : normalizeLabelText(rawSize) || rawSize || 'matching rail material';
          const displayLabel = label || 'matching rail material';
          gapCountByLabel.set(displayLabel, (gapCountByLabel.get(displayLabel)||0) + qty);
        });
      }

      lines.push(`${title}`);
      const scopeLabel = (()=>{
        if(scopeType === 'install') return 'Install new section';
        if(scopeType !== 'replace') return 'Repair existing section';
        if(!isWrought) return 'Remove & replace section';

        const lengthValue = formatFtValue(s.length);
        const lengthLabel = lengthValue || numOrDash(s.length);
        const heightLabel = normalizeLabelText(s.height || '').trim();
        const heightPhrase = heightLabel ? `${heightLabel} tall` : '';
        const styleRaw = normalizeLabelText(s.style || '').trim();
        const styleLabel = styleRaw ? styleRaw.toLowerCase() : '';
        const replaceDescriptor = [heightPhrase, 'wrought iron fence'].filter(Boolean).join(' ').trim() || 'wrought iron fence';
        const installDescriptor = [heightPhrase, styleLabel ? `${styleLabel} wrought iron fence` : 'wrought iron fence']
          .filter(Boolean).join(' ').trim() || 'wrought iron fence';

        const railSizes = new Set();
        const railsArr = Array.isArray(s.rails) ? s.rails.slice(0, s.railsCount || s.rails.length) : [];
        if(railsArr.length){
          railsArr.forEach(r=>{
            const size = normalizeSize(r?.size);
            if(size) railSizes.add(size);
            if(r?.stacked){
              const size2 = normalizeSize(r?.size2);
              if(size2) railSizes.add(size2);
            }
          });
        } else if(s.railSize){
          const size = normalizeSize(s.railSize);
          if(size) railSizes.add(size);
          if(s.railStacked && s.railSize2){
            const size2 = normalizeSize(s.railSize2);
            if(size2) railSizes.add(size2);
          }
        }
        const picketSize = normalizeSize(s.picketSize || '');
        const sizeParts = [];
        if(railSizes.size){
          sizeParts.push(`${joinParts(Array.from(railSizes))} rails`);
        }
        if(picketSize){
          sizeParts.push(`${picketSize} pickets`);
        }
        const sizeDetail = sizeParts.length ? ` with ${joinParts(sizeParts)}` : '';

        const gateCount = walkGateAddCount(s);
        const gateDetail = gateCount ? ` with ${gateCount} walk gate${gateCount === 1 ? '' : 's'}` : '';
        const useExistingPostsForReplacement = shouldUseExistingPostsForReplacement(s);
        const postDetail = useExistingPostsForReplacement ? ' using existing posts' : '';

        return `Replace ${lengthLabel} linear ft of ${replaceDescriptor}. Remove, haul away and dispose of the existing fence. Install new ${installDescriptor}${sizeDetail}${gateDetail}${postDetail}.`;
      })();
      lines.push(`- Scope: ${scopeLabel}`);
      const woodFinish = s.woodFinish || 'None';
      const woodStyle = s.woodStyle || '';
      const woodHeight = s.woodHeight || s.height;
      const woodPostLabel = (post)=>{
        if(!post) return '-';
        if(/round steel/i.test(post)) return 'Round Steel (2 3/8\")';
        return post;
      };

      const skipStyleDetails = isWood && isRepair;
      if(!skipStyleDetails){
        lines.push(`- Style: ${isWood ? woodStyle : s.style}`);
        lines.push(`- Height: ${isWood ? woodHeight : s.height}`);
        lines.push(`- Rails: ${railsDesc}`);
        if(isWood && isInstall){
          lines.push(`- Rail length: ${woodRailLengthFt} ft`);
        }
        lines.push(`- Picket: ${isWood ? (s.woodPicketWidth || '-') : picket}`);
        lines.push(`- Puppy Pickets: ${isWood ? 'N/A' : s.puppy}`);
        if(isWood){
          const woodPosts = woodPostLabel(s.woodPost);
          lines.push(`- Wood type: ${s.woodType || 'Cedar'}`);
          lines.push(`- Finish: ${woodFinish}`);
          lines.push(`- Posts: ${woodPosts}`);
          const woodAddOns = [];
          if(s.woodAddKickBoard){
            const stackLabel = s.woodKickBoardStack ? `${s.woodKickBoardStack}×` : '';
            const sizeLabel = s.woodKickBoardSize || '2x6';
            woodAddOns.push(`Kick board (${stackLabel}${sizeLabel})`);
          }
          if(s.woodAddTopCap){
            const sizeLabel = s.woodTopCapSize || '2x6';
            woodAddOns.push(`Top cap (${sizeLabel})`);
          }
          if(s.woodAddTrim){
            const trimLabel = s.woodTrimType || 'Trim';
            woodAddOns.push(`Trim (${trimLabel})`);
          }
          if(woodAddOns.length){
            lines.push(`- Wood add-ons: ${woodAddOns.join('; ')}`);
          }
          const woodSummaryParts = [
            `Style: ${woodStyle || '-'}`,
            `Height: ${woodHeight || '-'}`,
            `Picket: ${s.woodPicketWidth || '-'}`,
            `Rails: ${railsDesc}`,
            isInstall ? `Rail length: ${woodRailLengthFt} ft` : '',
            `Wood type: ${s.woodType || 'Cedar'}`,
            `Finish: ${woodFinish}`,
            `Posts: ${woodPosts}`,
            woodAddOns.length ? `Add-ons: ${woodAddOns.join('; ')}` : ''
          ].filter(Boolean);
          woodSectionSummaries.push(`- ${title}: ${woodSummaryParts.join('; ')}`);
        } else {
          const paintingLabel = effectiveWroughtPaintingSelection(s);
          lines.push(`- Painting: ${paintingLabel}`);
          if(paintingLabel !== 'None'){
            const currentColor = s.paintingCurrentColor || WROUGHT_CURRENT_COLOR_OPTIONS[0];
            const targetColor = s.paintingTargetColor || WROUGHT_PAINT_COLOR_OPTIONS[0];
            const paintCoats = paintCoatCountForSection(s);
            lines.push(`- Current fence color: ${currentColor}`);
            lines.push(`- Paint color: ${targetColor}`);
            if(paintCoats > 1){
              lines.push('- Paint coats: 2 (color change)');
            }
          }
          if(paintingLabel === 'Paint Section' || paintingLabel === 'Prime and Paint'){
            const application = s.paintingApplication || 'By Hand';
            lines.push(`- Paint application: ${application}`);
            if(paintingLabel === 'Paint Section' && s.paintingPrepExtra){
              lines.push('- Prep needs: More than usual prep');
            }
          }
        }
      }
      const braceLine = braceLineParts.length ? `- Diagonal brace additions: ${braceLineParts.join('; ')} (4 ft each)` : '';
      if(braceLine && !isRepair){
        lines.push(braceLine);
      }

      if(isInstall && installInfo){
        lines.push(`- Post spacing: ${installInfo.spacingFt} ft`);
        lines.push(`- Panel attachment: ${installInfo.attachment}`);
        lines.push(`- Panel fabrication: ${installInfo.panelFabrication}`);
        if(installInfo.useExistingPosts){
          lines.push('- Use existing posts: yes (no new post set or anchoring)');
        } else {
          lines.push(`- Posts to set: ${installInfo.postsTotal} (${s.postSize})`);
          const postMethod = normalizePostInstallMethod(installInfo.postInstallMethod);
          if(postMethod === 'anchored'){
            lines.push(`- Post setting method: ${postInstallMethodLabel(postMethod)} (1x ${POST_ANCHOR_PLATE_LABEL} + 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post)`);
          } else {
            lines.push(`- Post setting method: ${postInstallMethodLabel(postMethod)} (set in concrete 36" deep)`);
          }
        }
        if(installInfo.finialStyle){
          lines.push(`- Finials: ${installInfo.finialStyle}`);
        }
        if(Array.isArray(installInfo.autoCaps) && installInfo.autoCaps.length){
          const capParts = installInfo.autoCaps.map(cap=>`${cap.count} × ${cap.material} ${cap.style} (${cap.postSize})`);
          lines.push(`- Post caps: ${capParts.join('; ')}`);
        }
        if(scopeType === 'replace' && installInfo.lengthFt > 0){
          lines.push(`- Remove existing section (${installInfo.lengthFt} lf) and haul away (sub paid $${money(installInfo.removalCost)})`);
        }
      }

      lines.push(`- Length: ${numOrDash(s.length)} ft`);
      if (s.hardscape > 0) lines.push(`- Over hardscape: ${s.hardscape} lf`);
      if (s.trim > 0)      lines.push(`- Trim: ${s.trim} lf`);
      if (!isInstall && s.digOut > 0)    lines.push(`- Dig out: ${s.digOut} lf`);

      const i = (v)=> (parseInt(v||0,10) || 0);
      let picketReplaceCount = 0;
      let weldRedoCount = 0;
      let puppyPicketReplaceCount = 0;
      let replaceCounts = zeroPostCounts();
      let realignCounts = zeroPostCounts();
      let realignCutWeld = 0;
      let realignCutWeldCounts = zeroPostCounts();
      if(isRepair){
        const repairLines = [];
        if(isWood){
          picketReplaceCount = i(s.woodRepairPicketReplace);
          const picketInstallCount = i(s.woodRepairPicketInstall);
          const railReplaceCount = i(s.woodRepairRailReplace);
          const railInstallCount = i(s.woodRepairRailInstall);
          const postReplaceCount = i(s.woodRepairPostReplace);
          const woodRealignCounts = countWoodRealignMethods(s.woodPostRealignments);
          const postInstallCount = i(s.woodRepairPostInstall);
          const panelReplaceCount = i(s.woodRepairPanelReplace);
          const gateCount = i(s.woodRepairWalkGateCount);
          const topCapLf = parseFloat(s.woodRepairTopCapReplaceLf || 0) || 0;
          const trimLf = parseFloat(s.woodRepairTrimReplaceLf || 0) || 0;
          const kickLf = parseFloat(s.woodRepairKickReplaceLf || 0) || 0;
          if(picketReplaceCount > 0) repairLines.push(`  - Pickets to replace: ${picketReplaceCount}`);
          if(picketInstallCount > 0) repairLines.push(`  - Pickets to install: ${picketInstallCount}`);
          if(railReplaceCount > 0) repairLines.push(`  - Rails to replace: ${railReplaceCount}`);
          if(railInstallCount > 0) repairLines.push(`  - Rails to install: ${railInstallCount}`);
          if(postReplaceCount > 0) repairLines.push(`  - Posts to replace: ${postReplaceCount}`);
          if(woodRealignCounts.dig > 0) repairLines.push(`  - Posts to realign (dig/straighten): ${woodRealignCounts.dig}`);
          if(woodRealignCounts.cutWeld > 0) repairLines.push(`  - Posts to realign (cut & weld): ${woodRealignCounts.cutWeld}`);
          if(postInstallCount > 0) repairLines.push(`  - Posts to install: ${postInstallCount}`);
          if(panelReplaceCount > 0){
            const panelCalc = s._woodPanelCalc || calcWoodPanelReplacement(s, panelReplaceCount);
            if(panelCalc) s._woodPanelCalc = panelCalc;
            repairLines.push(`  - Panels to replace: ${panelReplaceCount}`);
          }
          if(gateCount > 0) repairLines.push(`  - Walk gates to repair: ${gateCount}`);
          if(topCapLf > 0) repairLines.push(`  - Top cap to replace: ${topCapLf} lf`);
          if(trimLf > 0) repairLines.push(`  - Trim to replace: ${trimLf} lf`);
          if(kickLf > 0) repairLines.push(`  - Kick board to replace: ${kickLf} lf`);
        } else {
          picketReplaceCount = i(s.wiPickets);
          weldRedoCount = i(s.weldRedos);
          puppyPicketReplaceCount = hasPuppyPickets(s.puppy) ? i(s.puppyPicketReplace) : 0;
          replaceCounts = countPostGroups(s.postReplacements);
          realignCounts = countPostGroups(s.postRealignments);
          realignCutWeld = countRealignCutWeld(s.postRealignments);
          realignCutWeldCounts = countPostGroupsByMethod(s.postRealignments, 'cut-weld');
          if(picketReplaceCount > 0) repairLines.push(`  - Pickets to replace: ${picketReplaceCount}`);
          if(puppyPicketReplaceCount > 0){
            const detailSuffix = puppyPicketDetail ? ` (${puppyPicketDetail})` : '';
            repairLines.push(`  - Puppy pickets to replace: ${puppyPicketReplaceCount}${detailSuffix}`);
          }
          if(weldRedoCount > 0) repairLines.push(`  - Weld redos: ${weldRedoCount}`);
          if(sectionPatchTotal > 0) repairLines.push(`  - Rail patches: ${sectionPatchTotal}`);
          if(sectionReplTotal > 0) repairLines.push(`  - Full rail replacements: ${sectionReplTotal}`);
          const gapLineParts = [];
          gapCountByLabel.forEach((qty,label)=>{ gapLineParts.push(`${qty} × ${label}`); });
          const gapSummary = (sectionGapTotal > 0 && gapLineParts.length)
            ? ` (${gapLineParts.join('; ')})`
            : '';
          if(sectionGapTotal > 0) repairLines.push(`  - Full rail gap fillers: ${sectionGapTotal}${gapSummary}`);
          if(replaceCounts.posts2x2 > 0) repairLines.push(`  - 2x2 posts to replace: ${replaceCounts.posts2x2}`);
          if(replaceCounts.posts3x3 > 0) repairLines.push(`  - 3x3 posts to replace: ${replaceCounts.posts3x3}`);
          if(replaceCounts.posts1p5 > 0) repairLines.push(`  - 1 1/2" x 1 1/2" posts to replace: ${replaceCounts.posts1p5}`);
          if(replaceCounts.posts4x4 > 0) repairLines.push(`  - 4x4 posts to replace: ${replaceCounts.posts4x4}`);
          if(realignCounts.posts2x2 > 0) repairLines.push(`  - 2x2 posts to realign: ${realignCounts.posts2x2}`);
          if(realignCounts.posts3x3 > 0) repairLines.push(`  - 3x3 posts to realign: ${realignCounts.posts3x3}`);
          if(realignCutWeld > 0){
            const cutWeldSizeParts = [];
            if(realignCutWeldCounts.posts2x2 > 0) cutWeldSizeParts.push(`${realignCutWeldCounts.posts2x2} × 2x2`);
            if(realignCutWeldCounts.posts3x3 > 0) cutWeldSizeParts.push(`${realignCutWeldCounts.posts3x3} × 3x3`);
            if(realignCutWeldCounts.posts1p5 > 0) cutWeldSizeParts.push(`${realignCutWeldCounts.posts1p5} × 1 1/2" x 1 1/2"`);
            if(realignCutWeldCounts.posts4x4 > 0) cutWeldSizeParts.push(`${realignCutWeldCounts.posts4x4} × 4x4`);
            const cutWeldSizeDetail = cutWeldSizeParts.length ? ` (${cutWeldSizeParts.join('; ')})` : '';
            repairLines.push(`  - Posts to realign (cut & weld): ${realignCutWeld}${cutWeldSizeDetail}`);
          }
          if(braceTotalQty > 0){
            const braceSummary = braceLineParts.length ? ` (${braceLineParts.join('; ')})` : '';
            repairLines.push(`  - Diagonal brace additions: ${braceTotalQty}${braceSummary}`);
          }
        }
        if(repairLines.length){
          lines.push(`- Repairs:`);
          repairLines.forEach(line=>lines.push(line));
        }
      }

      // NEW: Finials
      const finArr = isRepair && isWrought && Array.isArray(s.finials) ? s.finials : [];
      const finCount = finArr.reduce((acc,f)=> acc + (parseInt(f?.qty||0,10) || 0), 0);
      if(finCount){
        lines.push(`- Finial replacements: ${finCount}`);
        finArr.forEach(f=>{
          const q = parseInt(f?.qty||0,10) || 0; if(!q) return;
          lines.push(`  - ${q} × ${f.material} ${f.style} on ${f.picketSize} pickets`);
        });
      }

      const panelPuppyInsertInfo = (!isWood && isRepair)
        ? collectPanelPuppyInsertInfo(s.panels, s.picketSize)
        : { total: 0, sizes: new Map() };
      const puppyInsertArr = isRepair && isWrought && Array.isArray(s.puppyInserts) ? s.puppyInserts : [];
      const puppyInsertCount = puppyInsertArr.reduce((acc,item)=> acc + (parseInt(item?.qty||0,10) || 0), 0)
        + (panelPuppyInsertInfo.total || 0);
      if(puppyInsertCount){
        const insertSizeMap = new Map();
        puppyInsertArr.forEach(item=>{
          const qty = parseInt(item?.qty||0,10) || 0;
          if(!qty) return;
          const sizeLabel = normalizePuppyInsertSize(item?.picketSize);
          insertSizeMap.set(sizeLabel, (insertSizeMap.get(sizeLabel)||0) + qty);
        });
        panelPuppyInsertInfo.sizes.forEach((qty, sizeLabel)=>{
          if(!qty) return;
          insertSizeMap.set(sizeLabel, (insertSizeMap.get(sizeLabel)||0) + qty);
        });
        lines.push(`- Puppy picket inserts: ${puppyInsertCount}`);
        insertSizeMap.forEach((qty, sizeLabel)=>{
          lines.push(`  - ${qty} × ${sizeLabel} pickets (includes 25 plugs per insert)`);
        });
      }

      function processPanels(list, heading, source, extra={}){
        if(!Array.isArray(list) || list.length === 0) return;
        const prepared = [];
        const defaultRail = (Array.isArray(s.rails) && s.rails[0] && s.rails[0].size) || s.railSize || SEED.railSize[0];
        const installFabricationMode = source === 'install'
          ? normalizeWroughtPanelFabrication(extra.installInfo?.panelFabrication || s.wroughtPanelFabrication)
          : WROUGHT_PANEL_FABRICATION_OPTIONS[0];
        let installCustomCount = 0;
        let installPrefabCount = 0;
        list.forEach(p=>{
          if(!p) return;
          const qty = parseInt(p.qty,10) || 0;
          if(qty <= 0) return;
          const widthRaw = parseInt(p.widthIn,10) || 0;
          const widthIn = Math.max(12, widthRaw);
          const railSize = p.railSize || defaultRail;
          const picketSize = p.picketSize || s.picketSize || SEED.picketSize[0];
          const height = p.height || s.height;
          let style = p.style || s.style || '';
          if(source === 'install' && extra.style){ style = extra.style; }
          const hasFinials = /Finials/i.test(style);
          const finialStyle = hasFinials
            ? (p.finialStyle || extra.finialStyle || SEED.finialStyles[0])
            : '';
          prepared.push({ qty, widthIn, railSize, picketSize, height, style, finialStyle });
        });
        if(!prepared.length) return;
        lines.push(heading);
        prepared.forEach(entry=>{
          const { qty, widthIn, railSize, picketSize, height, style, finialStyle } = entry;
          const feet = feetFromHeightStr(height);
          const eligible = isPrefabEligible(widthIn, railSize, picketSize);
          const orderedFromTmi = source === 'install' && !eligible && isOrderedTmiPanelFabrication(installFabricationMode);
          const stickLengthFt = source === 'install'
            ? wroughtCustomStickLengthFt(s.wroughtCustomStickLength)
            : 12;
          const hasFinials = /Finials/i.test(style);
          const finStyleLabel = hasFinials ? (finialStyle || SEED.finialStyles[0]) : '';
          const finialNote = hasFinials && finStyleLabel ? ` (finials: ${finStyleLabel})` : '';
          const locationLabel = eligible
            ? 'prefab eligible'
            : orderedFromTmi
              ? 'ordered custom (TMI, powder coated)'
              : 'build on site';
          const desc = `${height}, ${style}${finialNote}, rails ${railSize}, pickets ${picketSize} (${locationLabel})`;
          lines.push(`  - ${qty} × ${widthIn}" wide panel — ${desc}`);
          const attachment = (source === 'install') ? (extra.attachment || 'Welding') : 'Welding';
          const usesBrackets = attachment === 'Brackets';
          let onsitePanelHours = 0;
          const panelLinearFt = (qty * widthIn) / 12;
          const panelInstallLfPerCrewDay = Math.max(1, Number(WROUGHT_INSTALL_PRODUCTION.panelInstallLfPerCrewDay || 250) || 250);
          const crewDayHours = Math.max(0.25, Number(CREW_SETTINGS.maxDayHours || 13) || 13);
          const isCrewPacedInstallPanel = source === 'install' && (eligible || orderedFromTmi);
          if(eligible){
            onsitePanelHours = source === 'install'
              ? (panelLinearFt * (crewDayHours / panelInstallLfPerCrewDay))
              : (qty * 0.5);
          } else if(orderedFromTmi){
            onsitePanelHours = panelLinearFt * (crewDayHours / panelInstallLfPerCrewDay);
          } else {
            onsitePanelHours = qty * 1.5;
          }
          if(isCrewPacedInstallPanel){
            const panelCrewManHours = onsitePanelHours * ONSITE_CREW_SIZE;
            wroughtInstallPanelCrewHours += onsitePanelHours;
            wroughtInstallPanelLf += panelLinearFt;
            manHours += panelCrewManHours;
            helperHours += panelCrewManHours;
          } else {
            manHours += onsitePanelHours;
            if(!usesBrackets){
              welderHours += onsitePanelHours;
              weldedPanelHours += onsitePanelHours;
            }else{
              helperHours += onsitePanelHours;
              bracketPanelHours += onsitePanelHours;
            }
          }
          if(eligible){
            totals.panelsPrefab += qty;
            if(source === 'install'){
              totals.panelsInstallPrefab += qty;
              installPrefabCount += qty;
            }
            if(source === 'repair' && !isWood){
              const styleLabel = normalizeLabelText(style);
              const railLabel = normalizeSize(railSize);
              const picketLabel = normalizeSize(picketSize);
              const key = JSON.stringify({
                style: styleLabel.toLowerCase(),
                rail: railLabel.toLowerCase(),
                picket: picketLabel.toLowerCase()
              });
              const prev = totals.prefabPanelTypesRepair.get(key) || { count: 0, style: styleLabel, rail: railLabel, picket: picketLabel };
              prev.count += qty;
              totals.prefabPanelTypesRepair.set(key, prev);
            }
          } else {
            totals.panelsCustom += qty;
            if(source === 'install'){
              totals.panelsInstallCustom += qty;
              installCustomCount += qty;
              if(orderedFromTmi){
                totals.panelsInstallCustomTmi += qty;
              } else {
                totals.panelsInstallCustomOnSite += qty;
              }
            }
          }
          if(!s._panelCalc) s._panelCalc = [];
          s._panelCalc.push({
            qty,
            feet,
            eligible,
            style,
            picketSize,
            railSize,
            height,
            widthIn,
            stickLengthFt,
            finialStyle,
            source,
            attachment,
            panelFabrication: !eligible && source === 'install' ? installFabricationMode : WROUGHT_PANEL_FABRICATION_ON_SITE
          });
          if(source === 'install' && extra.installInfo){
            if(!extra.installInfo.panels) extra.installInfo.panels = [];
            extra.installInfo.panels.push({
              ...entry,
              attachment: extra.attachment || 'Welding',
              eligible,
              panelFabrication: eligible ? 'Prefab' : installFabricationMode
            });
          }
          if(hasFinials){
            addMat(materials, `finials - Cast Iron - ${finStyleLabel} (${picketSize})`, qty*25);
          }
          if(source === 'install' && attachment === 'Brackets'){
            addMat(materials, 'panel mount bracket', qty * 4);
          }
        });
        if(source === 'install' && extra.installInfo){
          extra.installInfo.customPanels = (extra.installInfo.customPanels || 0) + installCustomCount;
          extra.installInfo.prefabPanels = (extra.installInfo.prefabPanels || 0) + installPrefabCount;
        }
      }

      // PANEL REPLACEMENTS (per-row)
      const panelArr = isRepair && isWrought && Array.isArray(s.panels) ? s.panels : [];
      processPanels(panelArr, '- Panel replacements:', 'repair');

      if(installInfo && installInfo.spanCount > 0){
        const widthCounts = {};
        installInfo.panelWidths.forEach(w=>{
          widthCounts[w] = (widthCounts[w]||0) + 1;
        });
        const installStyle = (()=>{
          let base = s.style || '';
          const puppyVal = s.puppy || '';
          if(/Finials/i.test(puppyVal) && !/Finials/i.test(base)){
            base = base ? `${base} (${puppyVal})` : puppyVal;
          }
          return base || s.style || '';
        })();
        const installPanels = Object.entries(widthCounts).map(([width, qty])=>({
          qty,
          widthIn: parseInt(width,10) || 0,
          height: s.height,
          style: installStyle,
          railSize: (Array.isArray(s.rails) && s.rails[0] && s.rails[0].size) || s.railSize || SEED.railSize[0],
          picketSize: s.picketSize,
          finialStyle: installInfo.finialStyle
        }));
        processPanels(installPanels, '- Panel installation:', 'install', {
          attachment: installInfo.attachment,
          finialStyle: installInfo.finialStyle,
          style: installStyle,
          installInfo
        });
        if(installInfo.customPanels > 0){
          if(isOrderedTmiPanelFabrication(installInfo.panelFabrication)){
            lines.push(`- Custom panels ordered from TMI (powder coated, $${money(WROUGHT_TMI_CUSTOM_PANEL_COST)} each): ${installInfo.customPanels}`);
          } else {
            lines.push(`- Custom panels fabricated on site: ${installInfo.customPanels}`);
          }
        }
      }

      // NEW: Caps
      const capArr = isRepair && isWrought && Array.isArray(s.caps) ? s.caps : [];
      const capCount = capArr.reduce((acc,c)=> acc + (parseInt(c?.qty||0,10) || 0), 0);
      if(capCount){
        lines.push(`- Post cap replacements: ${capCount}`);
        capArr.forEach(c=>{
          const q = parseInt(c?.qty||0,10) || 0; if(!q) return;
          lines.push(`  - ${q} × ${c.material} ${c.style} caps for ${c.postSize} posts`);
        });
      }

      if(installInfo){
        s._installCalc = installInfo;
      }

      // Walk gate details
      const wg  = (isRepair && isWrought) ? i(s.walkGates) : 0;
      const wgr = (isRepair && isWrought) ? i(s.walkGatesRealign) : 0;
      const wgh = (isRepair && isWrought) ? i(s.walkGatesHardware) : 0;
      const wgb = (isRepair && isWrought) ? i(s.walkGatesRebuild) : 0;
      if (isRepair && (wg || wgr || wgh || wgb)){
        lines.push(`- Walk gates: ${wg}`);
        if (wgr) lines.push(`  - Realign: ${wgr}`);
        if (wgh) lines.push(`  - Hardware replacements: ${wgh} (Latch: ${s.walkLatch||'-'}, Hinges: ${s.walkHinges||'-'})`);
        if (wgb) lines.push(`  - Rebuild: ${wgb} (Frame: ${s.walkRebuildFrame}, Pickets: ${s.walkRebuildPicket}, Latch: ${s.walkRebuildLatch}, Hinges: ${s.walkRebuildHinges})`);
      }

      // Add walk gate into existing fence
      const wga = walkGateAddCount(s);
      if (wga){
        const gateTypeLabel = walkGateAddType(s);
        const gatePostLabel = walkGateAddPostLabel(s);
        const gateFrameLabel = walkGateAddFrameLabel(s);
        const gatePicketLabel = walkGateAddPicketLabel(s);
        const gateLatchLabel = walkGateAddLatchLabel(s);
        const gateHingeLabel = walkGateAddHingeLabel(s);
        lines.push(`- Add walk gate(s): ${wga} — ${gateTypeLabel}`);
        if(fenceType === 'wood'){
          lines.push(`  - Post type: ${gatePostLabel}; Frame: ${gateFrameLabel}; Picket width: ${gatePicketLabel}; Hardware: ${gateLatchLabel} + ${gateHingeLabel}`);
        } else {
          lines.push(`  - Post: ${gatePostLabel}; Frame: ${gateFrameLabel}; Pickets: ${gatePicketLabel}; Latch: ${gateLatchLabel}; Hinges: ${gateHingeLabel}`);
        }
      }

      const driveGateChainReplace = (isRepair && isWrought) ? i(s.driveGateChainReplace) : 0;
      if(driveGateChainReplace){
        lines.push(`- Sliding drive gate chains to replace: ${driveGateChainReplace}`);
        totals.driveGateChainReplacements += driveGateChainReplace;
        addMat(materials, 'Sliding drive gate chain', driveGateChainReplace);
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const qtySentence = driveGateChainReplace > 1 ? ` Quantity: ${driveGateChainReplace}.` : '';
        const desc = `${labelPrefix}Replace sliding drive gate chain.${qtySentence}`;
        addServiceLine('Sliding Drive Gate Repairs', desc);
      }

      // Drive gate operator replacement
      const dgo = isWrought ? i(s.driveGateOperatorReplace) : 0;
      if(dgo){
        const rawType = (s.driveGateOperatorType || DRIVE_GATE_OPERATOR_TYPES[0] || '').trim();
        const rawPower = (s.driveGateOperatorPower || DRIVE_GATE_POWER_TYPES[0] || '').trim();
        const typeLabel = rawType || DRIVE_GATE_OPERATOR_TYPES[0] || 'Drive';
        const powerLabel = rawPower || DRIVE_GATE_POWER_TYPES[0] || '';
        const operatorModel = getDriveGateOperatorLabel(typeLabel);
        const gateLabel = typeLabel === 'Drive'
          ? `drive gate${dgo===1?'':'s'}`
          : `${typeLabel} gate${dgo===1?'':'s'}`;
        lines.push(`- Drive gate operator replacement: ${dgo} — ${gateLabel}`);
        lines.push(`  - Operator: ${operatorModel}`);
        if(powerLabel){ lines.push(`  - Power: ${powerLabel}`); }
        totals.driveGateOperators += dgo;
        const prevTypeCount = totals.driveGateOperatorTypes.get(typeLabel) || 0;
        totals.driveGateOperatorTypes.set(typeLabel, prevTypeCount + dgo);
        if(powerLabel){
          const prevPowerCount = totals.driveGateOperatorPowers.get(powerLabel) || 0;
          totals.driveGateOperatorPowers.set(powerLabel, prevPowerCount + dgo);
        }
        const comboKey = `${typeLabel}|||${powerLabel}`;
        const prevCombo = totals.driveGateOperatorCombos.get(comboKey) || 0;
        totals.driveGateOperatorCombos.set(comboKey, prevCombo + dgo);
        addMat(materials, operatorModel, dgo);
        if(powerLabel === 'New Wiring'){
          addMat(materials, 'Drive gate power run (new wiring)', dgo);
        } else if(powerLabel === 'Solar'){
          addMat(materials, 'Solar gate power kit', dgo);
        }
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const operatorLabel = describeCount(dgo, operatorModel, `${operatorModel}s`);
        const powerSentence = powerLabel ? `Power: ${powerLabel}.` : '';
        let desc = `${labelPrefix}Replace ${operatorLabel} for ${gateLabel}. Include removal, haul away, and disposal of the old operator. ${powerSentence}`.trim();
        if(powerLabel === 'Existing Wiring'){
          desc += ' Price includes reuse of existing wiring currently connected to the gate operator. Existing wiring is assumed to be in good working condition. Any troubleshooting, repair, or replacement/rerouting of wiring (including new wire pulls/trenching/conduit) is not included and will be quoted as an additional service if required.';
        }
        addServiceLine('Drive Gate Operator Replacement', desc);
      }

      // Drive gate operator installation
      const dgi = isWrought ? i(s.driveGateOperatorInstall) : 0;
      if(dgi){
        const rawType = (s.driveGateOperatorInstallType || DRIVE_GATE_OPERATOR_TYPES[0] || '').trim();
        const rawPower = (s.driveGateOperatorInstallPower || DRIVE_GATE_POWER_TYPES_INSTALL[0] || '').trim();
        const typeLabel = rawType || DRIVE_GATE_OPERATOR_TYPES[0] || 'Drive';
        const powerLabel = rawPower || DRIVE_GATE_POWER_TYPES_INSTALL[0] || '';
        const platformNeeded = !!s.driveGateOperatorInstallPlatform;
        const operatorModel = getDriveGateOperatorLabel(typeLabel);
        const gateLabel = typeLabel === 'Drive'
          ? `drive gate${dgi===1?'':'s'}`
          : `${typeLabel} gate${dgi===1?'':'s'}`;
        lines.push(`- Drive gate operator installation: ${dgi} — ${gateLabel}`);
        lines.push(`  - Operator: ${operatorModel}`);
        if(powerLabel){ lines.push(`  - Power: ${powerLabel}`); }
        if(platformNeeded){ lines.push(`  - Platform: build operator platform`); }
        totals.driveGateOperatorInstalls += dgi;
        const prevTypeCount = totals.driveGateOperatorInstallTypes.get(typeLabel) || 0;
        totals.driveGateOperatorInstallTypes.set(typeLabel, prevTypeCount + dgi);
        if(powerLabel){
          const prevPowerCount = totals.driveGateOperatorInstallPowers.get(powerLabel) || 0;
          totals.driveGateOperatorInstallPowers.set(powerLabel, prevPowerCount + dgi);
        }
        const comboKey = `${typeLabel}|||${powerLabel}|||${platformNeeded ? 'platform' : 'no-platform'}`;
        const prevCombo = totals.driveGateOperatorInstallCombos.get(comboKey) || 0;
        totals.driveGateOperatorInstallCombos.set(comboKey, prevCombo + dgi);
        if(platformNeeded){
          totals.driveGateOperatorInstallPlatforms += dgi;
        }
        addMat(materials, operatorModel, dgi);
        if(powerLabel === 'New Wiring'){
          addMat(materials, 'Drive gate power run (new wiring)', dgi);
        } else if(powerLabel === 'Solar'){
          addMat(materials, 'Solar gate power kit', dgi);
        }
        if(platformNeeded){
          addRailSticks('2x2"', dgi);
          addMat(materials, 'Maximizer bags of concrete', dgi);
        }
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const operatorLabel = describeCount(dgi, operatorModel, `${operatorModel}s`);
        const powerSentence = powerLabel ? `Power: ${powerLabel}.` : '';
        const platformSentence = platformNeeded ? 'Include fabrication of a 2x2 steel operator platform set in concrete.' : '';
        const desc = `${labelPrefix}Install ${operatorLabel} for ${gateLabel}. ${powerSentence} ${platformSentence}`.trim();
        addServiceLine('Drive Gate Operator Installation', desc);
      }

      if(isInstall && (fenceType === 'wrought iron' || fenceType === 'wood')){
        const wallLength = parseFloat(s.retainingWallLength || 0) || 0;
        const wallHeight = parseFloat(s.retainingWallHeight || 0) || 0;
        if(wallLength > 0 && wallHeight > 0){
          lines.push(`- Retaining wall: ${wallLength}ft long × ${wallHeight}ft tall ($35/sq ft, $1,500 minimum). In-House 4 pours the wall only (includes wall materials & labor; post materials separate) and Jesus' crew installs the fence. Posts on the wall are set during the pour—no extra concrete bags needed.`);
        }
      }

      if (s.notes) lines.push(`- Notes: ${s.notes}`);
      lines.push('');

      totals.length       += i(s.length);
      totals.hardscape    += i(s.hardscape);
      totals.trim         += i(s.trim);
      if(isRepair){
        totals.digOut       += i(s.digOut);
        totals.finials      += finCount;
        totals.puppyInserts += puppyInsertCount;
        if(puppyInsertCount > 0){
          puppyInsertArr.forEach(item=>{
            const qty = parseInt(item?.qty||0,10) || 0;
            if(!qty) return;
            const sizeLabel = normalizePuppyInsertSize(item?.picketSize);
            totals.puppyInsertSizes.set(sizeLabel, (totals.puppyInsertSizes.get(sizeLabel)||0) + qty);
            addMat(materials, `puppy picket insert (${sizeLabel})`, qty);
            addMat(materials, `picket plugs (${sizeLabel})`, qty * 25);
          });
          panelPuppyInsertInfo.sizes.forEach((qty, sizeLabel)=>{
            if(!qty) return;
            totals.puppyInsertSizes.set(sizeLabel, (totals.puppyInsertSizes.get(sizeLabel)||0) + qty);
            addMat(materials, `puppy picket insert (${sizeLabel})`, qty);
            addMat(materials, `picket plugs (${sizeLabel})`, qty * 25);
          });
        }
        if(!isWood){
          totals.wiPickets    += picketReplaceCount;
          if(picketReplaceCount > 0){
            const picketSizeNormalized = normalizeSize(s.picketSize);
            if(picketSizeNormalized) totals.wiPicketSizes.add(picketSizeNormalized);
          }
          if(puppyPicketReplaceCount > 0){
            totals.puppyPickets += puppyPicketReplaceCount;
            const detailLabel = puppyPicketDetail || normalizeLabelText(s.puppyPicketSize || 'puppy picket');
            const labelKey = detailLabel || 'puppy picket';
            totals.puppyPicketDetails.set(labelKey, (totals.puppyPicketDetails.get(labelKey)||0) + puppyPicketReplaceCount);
          }
          totals.weldRedos    += weldRedoCount;
          totals.wiPatches    += sectionPatchTotal;
          if(sectionPatchTotal > 0){
            sectionPatchSizes.forEach(size=> totals.wiPatchSizes.add(size));
          }
          totals.wiRails      += sectionReplTotal;
          if(sectionReplTotal > 0){
            sectionReplSizes.forEach(size=> totals.wiRailReplaceSizes.add(size));
          }
          totals.wiRailGaps   += sectionGapTotal;
          if(sectionGapTotal > 0){
            sectionGapSizes.forEach(size=> totals.wiRailGapSizes.add(size));
          }
          addPostCounts(totals.postsReplace, replaceCounts);
          addPostCounts(totals, replaceCounts);
          totals.postsRealign2x2 += realignCounts.posts2x2;
          totals.postsRealign3x3 += realignCounts.posts3x3;
          totals.postsRealignCutWeld += realignCutWeld;
          addPostCounts(totals.postsRealignCutWeldBySize, realignCutWeldCounts);
        }
        totals.walkGates   += wg;
        totals.walkRealign += wgr;
        totals.walkHardware+= wgh;
        totals.walkRebuild += wgb;
        totals.caps        += capCount;
      }
      const gateTypeLabel = walkGateAddType(s);
      if(isWood){
        totals.woodWalkGateAdds += wga;
        if(isInstall){
          totals.woodWalkGateAddsInstall += wga;
        } else {
          totals.woodWalkGateAddsRepair += wga;
        }
        if(walkGateTypeIsDouble(gateTypeLabel)){
          totals.woodWalkGateAddsDouble += wga;
        } else {
          totals.woodWalkGateAddsSingle += wga;
        }
      } else {
        totals.walkGateAdds += wga;
        if(isInstall){
          totals.walkGateAddsInstall += wga;
        } else {
          totals.walkGateAddsRepair += wga;
        }
        if(walkGateTypeIsDouble(gateTypeLabel)){
          totals.walkGateAddsDouble += wga;
        } else {
          totals.walkGateAddsSingle += wga;
        }
      }
    });

    if(woodInstallPlan.removalLf > 0){
      const removalHaulCostPerLf = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.removalHaulCostPerLf || 3.9) || 0);
      const removalHaulMinimum = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.removalHaulMinimum || 100) || 0);
      woodInstallPlan.removalSubLf = woodInstallPlan.removalLf;
      woodInstallPlan.removalSubCost = Math.max(removalHaulMinimum, woodInstallPlan.removalLf * removalHaulCostPerLf);
    }

    const walkHardwareSummary = summarizeWalkHardware(state.sections);
    const prefabReplacementCount = Math.max(0, totals.panelsPrefab - (totals.panelsInstallPrefab || 0));
    const prefabReplacementDetail = summarizePrefabPanelTypes(totals.prefabPanelTypesRepair);

    if (woodSectionSummaries.length){
      lines.push('WOOD SECTION DETAILS');
      woodSectionSummaries.forEach(line=> lines.push(line));
    }

    if (state.sections.length){
      const t = totals;
      lines.push(`TOTALS`);
      lines.push(`- Sections: ${state.sections.length}`);
      lines.push(`- Length: ${t.length} ft`);
      if (t.hardscape)     lines.push(`- Over hardscape: ${t.hardscape} lf`);
      if (t.trim)          lines.push(`- Trim: ${t.trim} lf`);
      if (t.digOut)        lines.push(`- Dig out: ${t.digOut} lf`);
      if (t.replaceSections) lines.push(`- Sections to replace: ${t.replaceSections}`);
      if (t.installSections) lines.push(`- New sections to install: ${t.installSections}`);
      const removalCrewLf = Math.max(0, parseFloat(woodInstallPlan.removalLf || 0) || 0);
      const removalTotalLf = Math.max(0, (t.removalLf || 0) + removalCrewLf);
      if (removalTotalLf > 0){
        const removalSubLfBase = Math.max(0, removalTotalLf - removalCrewLf);
        const removalSubLfWood = Math.max(0, parseFloat(woodInstallPlan.removalSubLf || 0) || 0);
        const removalSubLf = removalSubLfWood > 0
          ? (removalSubLfWood + removalSubLfBase)
          : removalSubLfBase;
        const removalSubCost = Math.max(0, Number(t.removalCost || 0) || 0) + Math.max(0, Number(woodInstallPlan.removalSubCost || 0) || 0);
        if(removalSubLf > 0 && removalSubCost > 0 && removalCrewLf > 0){
          lines.push(`- Removal & haul away: ${formatFtValue(removalTotalLf)} lf (${formatFtValue(removalCrewLf)} lf crew labor included; sub paid $${money(removalSubCost)} for ${formatFtValue(removalSubLf)} lf)`);
        } else if(removalSubCost > 0){
          lines.push(`- Removal & haul away: ${formatFtValue(removalTotalLf)} lf (sub paid $${money(removalSubCost)})`);
        } else {
          lines.push(`- Removal & haul away: ${formatFtValue(removalTotalLf)} lf (crew labor included)`);
        }
      }
      if (t.finials)        lines.push(`- Finials to replace: ${t.finials}`);
      if (t.puppyInserts)   lines.push(`- Puppy picket inserts: ${t.puppyInserts}`);
      if (t.caps)           lines.push(`- Post caps to replace: ${t.caps}`);
      if (t.wiPickets)      lines.push(`- Pickets to replace: ${t.wiPickets}`);
      if (t.puppyPickets){
        const detailParts = [];
        if(t.puppyPicketDetails && typeof t.puppyPicketDetails.forEach === 'function'){
          t.puppyPicketDetails.forEach((count, label)=>{
            if(count>0){ detailParts.push(`${count} × ${label}`); }
          });
        }
        const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
        lines.push(`- Puppy pickets to replace: ${t.puppyPickets}${detail}`);
      }
      if (t.weldRedos)      lines.push(`- Weld redos: ${t.weldRedos}`);
      if (t.wiPatches)      lines.push(`- Rail patches: ${t.wiPatches}`);
      if (t.wiRails)        lines.push(`- Full rail replacements: ${t.wiRails}`);
      if (t.wiRailGaps)     lines.push(`- Full rail gap fillers: ${t.wiRailGaps}`);
      const postSummary = (label, counts)=>{
        const parts = [];
        if(counts.posts1p5) parts.push(`${counts.posts1p5} × 1 1/2" x 1 1/2"`);
        if(counts.posts2x2) parts.push(`${counts.posts2x2} × 2x2`);
        if(counts.posts3x3) parts.push(`${counts.posts3x3} × 3x3`);
        if(counts.posts4x4) parts.push(`${counts.posts4x4} × 4x4`);
        if(parts.length) lines.push(`- ${label}: ${parts.join(', ')}`);
      };
      postSummary('Posts to replace', t.postsReplace || zeroPostCounts());
      postSummary('Posts to set in concrete (new sections)', t.postsInstallConcrete || zeroPostCounts());
      postSummary('Posts to anchor (new sections)', t.postsInstallAnchored || zeroPostCounts());
      if (t.postsRealign2x2) lines.push(`- 2x2 posts to realign: ${t.postsRealign2x2}`);
      if (t.postsRealign3x3) lines.push(`- 3x3 posts to realign: ${t.postsRealign3x3}`);
      if (t.postsRealignCutWeld) lines.push(`- Posts to realign (cut & weld): ${t.postsRealignCutWeld}`);
      if (t.walkGates)     lines.push(`- Walk gates: ${t.walkGates}`);
      if (t.walkRealign)   lines.push(`- Walk gates to realign: ${t.walkRealign}`);
      if (walkHardwareSummary.total) {
        const detail = walkHardwareSummary.details.length ? ` (${walkHardwareSummary.details.join('; ')})` : '';
        lines.push(`- Walk gate hardware replacements: ${walkHardwareSummary.total}${detail}`);
      }
      if (t.walkRebuild)   lines.push(`- Walk gates to rebuild: ${t.walkRebuild}`);
      if (t.walkGateAdds)  lines.push(`- Walk gates to add: ${t.walkGateAdds}`);
      if (t.walkGateAddsSingle){
        const gateLabel = t.walkGateAddsSingle === 1 ? 'walk gate' : 'walk gates';
        lines.push(`- Add ${t.walkGateAddsSingle} single swing ${gateLabel} into the existing fence`);
      }
      if (t.walkGateAddsDouble) lines.push(`- Double swing gates to add: ${t.walkGateAddsDouble}`);
      if (t.woodWalkGateAdds) lines.push(`- Wood walk gates to add: ${t.woodWalkGateAdds}`);
      if (t.woodWalkGateAddsSingle) lines.push(`- Wood single swing walk gates to add: ${t.woodWalkGateAddsSingle}`);
      if (t.woodWalkGateAddsDouble) lines.push(`- Wood double swing gates to add: ${t.woodWalkGateAddsDouble}`);
      if (t.driveGateOperators){
        const comboParts = [];
        if(t.driveGateOperatorCombos && typeof t.driveGateOperatorCombos.forEach === 'function'){
          t.driveGateOperatorCombos.forEach((count, key)=>{
            if(count<=0) return;
            const [type, power] = String(key||'').split('|||');
            const typeLabel = (type || 'Drive').trim() || 'Drive';
            const powerLabel = (power || 'Power TBD').trim() || 'Power TBD';
            comboParts.push(`${typeLabel} / ${powerLabel}: ${count}`);
          });
        }
        const comboDetail = comboParts.length ? ` (${comboParts.join('; ')})` : '';
        lines.push(`- Drive gate operators to replace: ${t.driveGateOperators}${comboDetail}`);
      }
      if (t.driveGateOperatorInstalls){
        const comboParts = [];
        if(t.driveGateOperatorInstallCombos && typeof t.driveGateOperatorInstallCombos.forEach === 'function'){
          t.driveGateOperatorInstallCombos.forEach((count, key)=>{
            if(count<=0) return;
            const [type, power, platform] = String(key||'').split('|||');
            const typeLabel = (type || 'Drive').trim() || 'Drive';
            const powerLabel = (power || 'Power TBD').trim() || 'Power TBD';
            const platformLabel = platform === 'platform' ? 'platform' : '';
            comboParts.push(`${typeLabel} / ${powerLabel}${platformLabel ? ` / ${platformLabel}` : ''}: ${count}`);
          });
        }
        const comboDetail = comboParts.length ? ` (${comboParts.join('; ')})` : '';
        lines.push(`- Drive gate operators to install: ${t.driveGateOperatorInstalls}${comboDetail}`);
      }
      if (t.driveGateChainReplacements){
        lines.push(`- Sliding drive gate chains to replace: ${t.driveGateChainReplacements}`);
      }
      if (prefabReplacementCount) {
        const detailSuffix = prefabReplacementDetail ? ` (${prefabReplacementDetail})` : '';
        lines.push(`- Prefab panel replacements: ${prefabReplacementCount}${detailSuffix}`);
      }
      if (t.panelsCustom) lines.push(`- Panels requiring custom fabrication: ${t.panelsCustom}`);
      if (t.panelsInstallPrefab) lines.push(`- New prefab panels: ${t.panelsInstallPrefab}`);
      if (t.panelsInstallCustomShop) lines.push(`- New custom panels (shop fabricated): ${t.panelsInstallCustomShop}`);
      if (t.panelsInstallCustomOnSite) lines.push(`- New custom panels (fabricated on site): ${t.panelsInstallCustomOnSite}`);
      if (t.panelsInstallCustomTmi) lines.push(`- New custom panels (ordered from TMI): ${t.panelsInstallCustomTmi}`);
      if (t.panelsInstallCustom && !t.panelsInstallCustomShop && !t.panelsInstallCustomOnSite && !t.panelsInstallCustomTmi){
        lines.push(`- New custom panels: ${t.panelsInstallCustom}`);
      }
      if (t.powderCoatPanels) lines.push(`- Panels to powder coat: ${t.powderCoatPanels}`);
      if (t.powderCoatPosts) lines.push(`- Posts to powder coat: ${t.powderCoatPosts}`);
    }


    const installSectionsOnly = state.sections.filter(s=> (s?.scopeType || 'repair') === 'install');
    const replacementSectionsOnly = state.sections.filter(s=> (s?.scopeType || 'repair') === 'replace');

    const replacementGroups = groupSectionsByFenceType(replacementSectionsOnly);
    replacementGroups.forEach((sections, type)=>{
      const detail = buildInstallServiceDescription(sections, true);
      addServiceLine(`${fenceTypeLabel(type)} Fence Replacement`, detail || fenceTypeDefaultDetail(type, true));
    });

    const installGroups = groupSectionsByFenceType(installSectionsOnly);
    installGroups.forEach((sections, type)=>{
      const detail = buildInstallServiceDescription(sections, false);
      const serviceTitle = type === 'wood'
        ? buildWoodInstallationServiceLineTitle(sections)
        : `${fenceTypeLabel(type)} Fence Installation`;
      addServiceLine(serviceTitle, detail || fenceTypeDefaultDetail(type, false));
    });

    const paintingSummary = state.sections.reduce((acc, s)=>{
      const fenceType = (s.fenceType || '').toLowerCase();
      if(fenceType && fenceType !== 'wrought iron') return acc;
      const paintingMode = effectiveWroughtPaintingSelection(s);
      const len = parseInt(s.length||0,10) || 0;
      if(len > 0){
        const hardscape = parseInt(s.hardscape||0,10) || 0;
        const trim = parseInt(s.trim||0,10) || 0;
        const coatCount = paintCoatCountForSection(s);
        if(paintingMode === 'Paint Section'){
          acc.full.len += len;
          acc.full.hardscape += hardscape;
          acc.full.trim += trim;
          if(coatCount > 1){
            acc.full.colorChangeLen += len;
          }
        } else if (paintingMode === 'Prime and Paint'){
          acc.primePaint.len += len;
          acc.primePaint.hardscape += hardscape;
          acc.primePaint.trim += trim;
          if(coatCount > 1){
            acc.primePaint.colorChangeLen += len;
          }
        } else if (paintingMode === 'Spot Paint Welds'){
          acc.spot += len;
        }
      }
      return acc;
    }, {
      full: { len: 0, hardscape: 0, trim: 0, colorChangeLen: 0 },
      primePaint: { len: 0, hardscape: 0, trim: 0, colorChangeLen: 0 },
      spot: 0
    });

    if (paintingSummary.full.len || paintingSummary.primePaint.len || paintingSummary.spot){
      const hasSectionPaintScope = paintingSummary.full.len > 0 || paintingSummary.primePaint.len > 0;
      const paintingMethodSet = new Set();
      state.sections.forEach(s=>{
        const fenceType = (s.fenceType || '').toLowerCase();
        if(fenceType && fenceType !== 'wrought iron') return;
        const paintingMode = effectiveWroughtPaintingSelection(s);
        if(isAnyWroughtPaintMode(paintingMode)){
          const method = String(s.paintingApplication || 'By Hand').trim();
          if(method) paintingMethodSet.add(method);
        }
      });
      const methodOrder = ['By Hand', 'Spray'];
      const methodLabels = methodOrder.filter(m => paintingMethodSet.has(m));
      paintingMethodSet.forEach(m=>{
        if(!methodLabels.includes(m)) methodLabels.push(m);
      });
      let methodNote = '';
      if(methodLabels.length){
        const methodText = methodLabels.length === 1 ? methodLabels[0] : methodLabels.join(' and ');
        methodNote = `Paint application method${methodLabels.length > 1 ? 's' : ''}: ${methodText}.`;
        if(methodLabels.includes('By Hand')){
          methodNote += ' By hand allows a thicker coat of paint to be applied, which is great for protection, and leaves a more textured finish from the gloves.';
        }
      }
      const currentColorCounts = new Map();
      const targetColorCounts = new Map();
      state.sections.forEach(s=>{
        const fenceType = (s.fenceType || '').toLowerCase();
        if(fenceType && fenceType !== 'wrought iron') return;
        const paintingMode = effectiveWroughtPaintingSelection(s);
        if(isAnyWroughtPaintMode(paintingMode)){
          const currentColor = normalizeLabelText(s.paintingCurrentColor || WROUGHT_CURRENT_COLOR_OPTIONS[0]) || WROUGHT_CURRENT_COLOR_OPTIONS[0];
          const targetColor = normalizeLabelText(s.paintingTargetColor || WROUGHT_PAINT_COLOR_OPTIONS[0]) || WROUGHT_PAINT_COLOR_OPTIONS[0];
          currentColorCounts.set(currentColor, (currentColorCounts.get(currentColor) || 0) + 1);
          targetColorCounts.set(targetColor, (targetColorCounts.get(targetColor) || 0) + 1);
        }
      });
      const singleCurrentColor = currentColorCounts.size === 1 ? Array.from(currentColorCounts.keys())[0] : '';
      const singleTargetColor = targetColorCounts.size === 1 ? Array.from(targetColorCounts.keys())[0] : '';
      const summarizeColorCounts = (map)=>{
        const parts = [];
        map.forEach((count, label)=>{
          if(!label) return;
          parts.push(count > 1 ? `${count} × ${label}` : label);
        });
        return parts.join('; ');
      };
      let colorNote = '';
      if(singleCurrentColor && singleTargetColor){
        colorNote = `Current fence color: ${singleCurrentColor}. Paint color: ${singleTargetColor}.`;
      }else{
        const currentMix = summarizeColorCounts(currentColorCounts);
        const targetMix = summarizeColorCounts(targetColorCounts);
        if(currentMix){
          colorNote += `Current fence color mix: ${currentMix}.`;
        }
        if(targetMix){
          colorNote += `${colorNote ? ' ' : ''}Paint color mix: ${targetMix}.`;
        }
      }
      const paintColorPhrase = singleTargetColor
        ? `${singleTargetColor} oil-based paint`
        : 'the selected oil-based paint color';
      const colorChangeTotalLen =
        (paintingSummary.full.colorChangeLen || 0) +
        (paintingSummary.primePaint.colorChangeLen || 0);
      let coatRuleNote = '';
      if(colorChangeTotalLen > 0){
        const coatParts = [];
        if(paintingSummary.full.colorChangeLen > 0){
          coatParts.push(`paint section ${paintingSummary.full.colorChangeLen} lf`);
        }
        if(paintingSummary.primePaint.colorChangeLen > 0){
          coatParts.push(`prime and paint ${paintingSummary.primePaint.colorChangeLen} lf`);
        }
        const coatDetail = coatParts.length ? ` (${coatParts.join('; ')})` : '';
        coatRuleNote = `Two paint coats are included where the selected paint color differs from the current fence color${coatDetail}.`;
      }

      const segments = [];
      if(paintingSummary.full.len){
        let detail = `Scrape and brush off loose rust and debris, then apply ${paintColorPhrase} to approximately ${paintingSummary.full.len} linear feet of fence`;
        const extras = [];
        if(paintingSummary.full.hardscape) extras.push(`${paintingSummary.full.hardscape} lf over hardscape`);
        if(paintingSummary.full.trim) extras.push(`${paintingSummary.full.trim} lf of trim detail`);
        if(extras.length) detail += ` (${extras.join(', ')})`;
        segments.push(detail);
      }
      if(paintingSummary.primePaint.len){
        let detail = `Prime with red oxide primer, then apply ${paintColorPhrase} to approximately ${paintingSummary.primePaint.len} linear feet of fence`;
        const extras = [];
        if(paintingSummary.primePaint.hardscape) extras.push(`${paintingSummary.primePaint.hardscape} lf over hardscape`);
        if(paintingSummary.primePaint.trim) extras.push(`${paintingSummary.primePaint.trim} lf of trim detail`);
        if(extras.length) detail += ` (${extras.join(', ')})`;
        detail += ` with two mobilizations: prime on day one and return after cure for the finish coat`;
        segments.push(detail);
      }
      if(paintingSummary.spot){
        if(hasSectionPaintScope){
          segments.push(`Spot prep and apply ${paintColorPhrase} to weld areas along ${paintingSummary.spot} linear feet`);
        } else {
          segments.push(`Spot paint weld touch-up after installation along ${paintingSummary.spot} linear feet`);
        }
      }
      let desc = segments.join('; ') + '.';
      if(hasSectionPaintScope && colorNote){
        desc += ` ${colorNote}`;
      }
      if(hasSectionPaintScope && coatRuleNote){
        desc += ` ${coatRuleNote}`;
      }
      if(hasSectionPaintScope && methodNote){
        desc += ` ${methodNote}`;
      }
      const paintingLineTitle = hasSectionPaintScope ? 'Surface Preparation & Painting' : 'Weld Touch-Up Paint';
      addServiceLine(paintingLineTitle, desc);
    }

    const woodRepairSections = state.sections.filter(s=> ((s.fenceType||'').toLowerCase() === 'wood') && ((s.scopeType||'repair') === 'repair'));
    if(woodRepairSections.length){
      const methodLabel = (list, val)=>{
        const match = list.find(item=>item.value === val);
        return match ? match.label : (val || '');
      };
      woodRepairSections.forEach((s, idx)=>{
        const parts = [];
        const labelPrefix = s.label ? `${s.label}: ` : '';
        const railSize = s.woodRailSize || '';
        const picketWidth = s.woodPicketWidth || '';
        const woodHeightFt = feetFromStr(s.woodHeight || '');
        const sectionLengthFt = parseFloat(s.length||0) || 0;
        const useOverlapCount = woodStyleUsesOverlapPickets(s.woodStyle || '');
        const addCount = (count, singular, plural)=>{
          const n = parseInt(count||0,10) || 0;
          if(!n) return '';
          const label = n === 1 ? singular : (plural || `${singular}s`);
          return `${n} ${label}`;
        };
        const picketReplaceCount = parseInt(s.woodRepairPicketReplace||0,10) || 0;
        const picketInstallCount = parseInt(s.woodRepairPicketInstall||0,10) || 0;
        const railReplaceCount = parseInt(s.woodRepairRailReplace||0,10) || 0;
        const railInstallCount = parseInt(s.woodRepairRailInstall||0,10) || 0;
        const postReplaceCount = parseInt(s.woodRepairPostReplace||0,10) || 0;
        const postRealignCounts = countWoodRealignMethods(s.woodPostRealignments);
        const postInstallCount = parseInt(s.woodRepairPostInstall||0,10) || 0;
        const panels = parseInt(s.woodRepairPanelReplace||0,10) || 0;
        const walkGates = parseInt(s.woodRepairWalkGateCount||0,10) || 0;
        const strengthen = parseInt(s.woodRepairGateStrengthen||0,10) || 0;
        const replaceGate = parseInt(s.woodRepairGateReplace||0,10) || 0;
        const topCapLf = parseFloat(s.woodRepairTopCapReplaceLf||0) || 0;
        const trimLf = parseFloat(s.woodRepairTrimReplaceLf||0) || 0;
        const kickLf = parseFloat(s.woodRepairKickReplaceLf||0) || 0;
        const kickStack = parseInt(s.woodRepairKickReplaceStack||0,10) || 1;

        const picketReplace = picketWidth
          ? addCount(picketReplaceCount, `${picketWidth} picket`, `${picketWidth} pickets`)
          : addCount(picketReplaceCount, 'picket', 'pickets');
        if(picketReplace){
          parts.push(`Replace ${picketReplace}`);
          const perPicketMinutes = useOverlapCount ? 10 : 5;
          const hours = (picketReplaceCount * perPicketMinutes) / 60;
          totals.woodPicketReplace += picketReplaceCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const picketInstall = picketWidth
          ? addCount(picketInstallCount, `${picketWidth} picket`, `${picketWidth} pickets`)
          : addCount(picketInstallCount, 'picket', 'pickets');
        if(picketInstall){
          parts.push(`Install ${picketInstall}`);
          const perPicketMinutes = useOverlapCount ? 10 : 5;
          const hours = (picketInstallCount * perPicketMinutes) / 60;
          totals.woodPicketInstall += picketInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const railDescriptor = woodRailDescriptor(s);
        const railReplace = addCount(railReplaceCount, railDescriptor, `${railDescriptor}s`);
        if(railReplace){
          addServiceLine('Rail Replacement', `${labelPrefix}Replace ${railReplace}`);
          addMat(materials, woodRailMaterialLabel(s), railReplaceCount);
          const hours = (railReplaceCount * 20) / 60;
          totals.woodRailReplace += railReplaceCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const railInstall = addCount(railInstallCount, railSize ? `${railSize} rail` : 'rail', railSize ? `${railSize} rails` : 'rails');
        if(railInstall){
          parts.push(`Install ${railInstall}`);
          const hours = (railInstallCount * 10) / 60;
          totals.woodRailInstall += railInstallCount;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        const postReplace = addCount(postReplaceCount, 'post', 'posts');
        if(postReplace){
          const tie = (s.woodRepairPostReplaceTie || defaultTieForWoodPost(s.woodPost) || '').trim();
          const cap = (s.woodRepairPostReplaceCap || '').trim();
          const tieLabel = tie && !isNoTiesSelection(tie) ? tie : '';
          const extras = [tieLabel ? `Simpson ${tieLabel}` : '', cap ? `cap: ${cap}` : ''].filter(Boolean).join(', ');
          parts.push(`Replace ${postReplace}${extras ? ` (${extras})` : ''}`);
          const perPostHours = (woodHeightFt >= 8) ? 1.5 : 1;
          const hours = postReplaceCount * perPostHours * 2; // two-person task
          if(woodHeightFt >= 8){ totals.woodPostReplace8 += postReplaceCount; }
          else { totals.woodPostReplace6 += postReplaceCount; }
          woodHelperHours += hours;
          woodManHours += hours;
          woodRequiresTwoPerson = woodRequiresTwoPerson || postReplaceCount > 0;
        }
        if(postRealignCounts.dig){
          const realign = addCount(postRealignCounts.dig, 'post realignment', 'post realignments');
          parts.push(`${realign} via dig, straighten, and add concrete`);
          const perPostHours = (45/60);
          totals.woodPostRealignDig += postRealignCounts.dig;
          const hours = postRealignCounts.dig * perPostHours;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(postRealignCounts.cutWeld){
          const realign = addCount(postRealignCounts.cutWeld, 'post realignment', 'post realignments');
          parts.push(`${realign} via cut & weld`);
          const perPostHours = (20/60);
          totals.woodPostRealignCutWeld += postRealignCounts.cutWeld;
          const hours = postRealignCounts.cutWeld * perPostHours;
          woodWelderHours += hours;
          woodHelperHours += hours;
          woodManHours += hours * 2;
          woodRequiresTwoPerson = true;
        }
        const postInstall = addCount(postInstallCount, 'post installation', 'post installations');
        if(postInstall){
          const method = methodLabel(WOOD_POST_INSTALL_METHODS, s.woodRepairPostInstallMethod);
          const tie = (s.woodRepairPostInstallTie || defaultTieForWoodPost(s.woodPost) || '').trim();
          const tieLabel = tie && !isNoTiesSelection(tie) ? tie : '';
          const extras = [method, tieLabel ? `Simpson ${tieLabel}` : ''].filter(Boolean).join('; ');
          parts.push(`${postInstall}${extras ? ` (${extras})` : ''}`);
          const hours = postInstallCount * (45/60);
          totals.woodPostInstall += postInstallCount;
          addWoodMethodCount(totals.woodPostInstallMethods, s.woodRepairPostInstallMethod, postInstallCount);
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(panels>0){
          const panelCalc = s._woodPanelCalc || calcWoodPanelReplacement(s, panels);
          if(panelCalc) s._woodPanelCalc = panelCalc;
          const panelStyleRaw = String(s.woodStyle || '').trim();
          const panelStyle = panelStyleRaw ? `wood ${panelStyleRaw.toLowerCase()} panel` : 'wood panel';
          const panelAddOns = [];
          if(panelCalc && panelCalc.kick) panelAddOns.push('kick board');
          if(panelCalc && panelCalc.topCap) panelAddOns.push('top cap');
          if(panelCalc && panelCalc.trim) panelAddOns.push('trim');
          const addOnText = panelAddOns.length ? ` with ${joinParts(panelAddOns)}` : '';
          parts.push(`Replace ${panels}x ${panelStyle}${addOnText}`);
          parts.push('Remove and haul away the existing panel(s)');
          const hours = panels * 1.5;
          totals.woodPanels += panels;
          if(panelCalc){
            if(panelCalc.panelLf > 0){
              const disposalLf = panelCalc.panelLf;
              totals.removalLf += disposalLf;
              totals.removalCost += disposalLf * 3.9;
            }
            if(panelCalc.totalRails > 0){
              addMat(materials, woodRailMaterialLabel(s), panelCalc.totalRails);
            }
            if(panelCalc.totalPickets > 0){
              addMat(materials, woodPicketMaterialLabel(s), panelCalc.totalPickets);
            }
            if(panelCalc.topCap){
              const lengthLabel = formatFtValue(panelCalc.widthFt || 8) || '8';
              addMat(materials, `wood top cap (${panelCalc.topCap.size}, ${lengthLabel} ft)`, panels);
            }
            if(panelCalc.trim){
              panelCalc.trim.sizes.forEach(size=>{
                const lengthLabel = formatFtValue(panelCalc.widthFt || 8) || '8';
                addMat(materials, `wood trim (${size}, ${lengthLabel} ft)`, panels);
              });
            }
            if(panelCalc.kick){
              const stack = panelCalc.kick.stack || 1;
              const lengthLabel = formatFtValue(panelCalc.widthFt || 8) || '8';
              addMat(materials, `wood kick board (${panelCalc.kick.size}, ${lengthLabel} ft)`, panels * stack);
            }
          }
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(walkGates>0){
          const tasks = [];
          if(s.woodRepairWalkGateHinges) tasks.push('replace hinges');
          if(s.woodRepairWalkGateLatch) tasks.push('replace latch');
          if(s.woodRepairWalkGateWood) tasks.push('repair wood around gate');
          const taskLabel = tasks.length ? ` (${tasks.join(', ')})` : '';
          parts.push(`Repair ${walkGates} walk gate${walkGates===1?'':'s'}${taskLabel}`);
          if(s.woodRepairWalkGateHinges){
            addMat(materials, 'wood walk gate hinge', walkGates);
          }
          if(s.woodRepairWalkGateLatch){
            addMat(materials, 'wood walk gate latch', walkGates);
          }
          if(s.woodRepairWalkGateWood){
            const picketWidthIn = parseWoodInches(s.woodPicketWidth, 5.5);
            const useOverlapCount = woodStyleUsesOverlapPickets(s.woodStyle || '');
            const picketsPerGate = woodPicketCountForWidth(60, picketWidthIn, useOverlapCount);
            if(picketsPerGate > 0){
              addMat(materials, woodPicketMaterialLabel(s), picketsPerGate * walkGates);
            }
            addMat(materials, woodGate2x4MaterialLabel(s), walkGates * 4);
          }
          const hours = walkGates * 2;
          totals.woodGateRepair += walkGates;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(strengthen>0){
          parts.push(`Strengthen ${strengthen} walk gate${strengthen===1?'':'s'} with additional 2x4 framing`);
          addMat(materials, woodGate2x4MaterialLabel(s), strengthen * 2);
          const hours = strengthen * 1;
          totals.woodGateStrengthen += strengthen;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(replaceGate>0){
          parts.push(`Replace ${replaceGate} walk gate${replaceGate===1?'':'s'} with new build and hardware`);
          addMat(materials, 'wood walk gate hinge', replaceGate);
          addMat(materials, 'wood walk gate latch', replaceGate);
          const picketWidthIn = parseWoodInches(s.woodPicketWidth, 5.5);
          const useOverlapCount = woodStyleUsesOverlapPickets(s.woodStyle || '');
          const picketsPerGate = woodPicketCountForWidth(60, picketWidthIn, useOverlapCount);
          if(picketsPerGate > 0){
            addMat(materials, woodPicketMaterialLabel(s), picketsPerGate * replaceGate);
          }
          addMat(materials, woodGate2x4MaterialLabel(s), replaceGate * 5);
          if(s.woodAddTopCap){
            const size = s.woodTopCapSize || '2x6';
            addMat(materials, `wood top cap (${size})`, replaceGate);
          }
          if(s.woodAddTrim){
            const trimSizes = splitWoodTrimSizes(s.woodTrimType || 'Trim');
            trimSizes.forEach(size=>{
              addMat(materials, `wood trim (${size})`, replaceGate);
            });
          }
          if(s.woodAddKickBoard){
            const size = s.woodKickBoardSize || '2x6';
            addMat(materials, `wood kick board (${size})`, replaceGate);
          }
          const hours = replaceGate * 3;
          totals.woodGateReplace += replaceGate;
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(topCapLf>0){
          const size = s.woodRepairTopCapReplaceSize || s.woodTopCapSize || '2x6';
          parts.push(`Replace ${topCapLf} lf of top cap (${size})`);
          const hours = topCapLf * ((30/60)/16);
          totals.woodTopCapLf += topCapLf;
          addWoodBoardReplaceLf(woodBoardReplaceLf.topCap, size, topCapLf);
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(trimLf>0){
          const size = s.woodRepairTrimReplaceSize || s.woodTrimType || '';
          parts.push(`Replace ${trimLf} lf of trim${size ? ` (${size})` : ''}`);
          const hours = trimLf * ((10/60)/8);
          totals.woodTrimLf += trimLf;
          const trimSizes = splitWoodTrimSizes(size || '');
          trimSizes.forEach(trimSize=>{
            addWoodBoardReplaceLf(woodBoardReplaceLf.trim, trimSize, trimLf);
          });
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(kickLf>0){
          const size = s.woodRepairKickReplaceSize || s.woodKickBoardSize || '';
          const stack = kickStack > 0 ? kickStack : 1;
          parts.push(`Replace ${kickLf} lf of kick board (${size}, ${stack} board stack)`);
          const hours = kickLf * stack * ((60/60)/8);
          totals.woodKickLf += kickLf;
          addWoodBoardReplaceLf(woodBoardReplaceLf.kick, size, kickLf * stack);
          woodHelperHours += hours;
          woodManHours += hours;
        }
        if(parts.length){
          addServiceLine('Wood Fence Repairs', `${labelPrefix}${parts.join('; ')}.`);
        }
        if(s.woodRepairStain && s.woodRepairStain !== 'none'){
          const stainSelection = parseWoodStainSelection(s.woodRepairStain);
          if(stainSelection.side !== 'none'){
            const sideLabelMap = { outside: 'outside', inside: 'inside', both: 'both sides' };
            const sideLabel = sideLabelMap[stainSelection.side] || stainSelection.side;
            const heightFt = Math.max(0, woodHeightFt || feetFromStr(s.height));
            const sidesMultiplier = stainSelection.side === 'both' ? 2 : 1;
            const normalizedLengthFt = Math.max(0, sectionLengthFt);
            const hasTopCap = !!s.woodAddTopCap || topCapLf > 0;
            const parseBoardHeightInches = (size, fallbackInches = 0)=>{
              const match = String(size || '').match(/x\s*(\d+(?:\.\d+)?)/i);
              const inches = match ? parseFloat(match[1]) : NaN;
              if(isFinite(inches) && inches > 0){
                return inches;
              }
              const fallback = parseFloat(fallbackInches);
              return isFinite(fallback) && fallback > 0 ? fallback : 0;
            };
            const normalizeBoardStack = (value)=>{
              const stack = parseInt(value, 10) || 0;
              return stack > 0 ? stack : 1;
            };
            let kickBoardHeightInches = 0;
            let kickBoardStackCount = 0;
            if(s.woodAddKickBoard){
              kickBoardHeightInches = parseBoardHeightInches(s.woodKickBoardSize, 6);
              kickBoardStackCount = normalizeBoardStack(s.woodKickBoardStack);
            } else if(kickLf > 0){
              const repairKickSize = s.woodRepairKickReplaceSize || s.woodKickBoardSize;
              const repairKickStack = s.woodRepairKickReplaceStack || s.woodKickBoardStack;
              kickBoardHeightInches = parseBoardHeightInches(repairKickSize, 6);
              kickBoardStackCount = normalizeBoardStack(repairKickStack);
            }
            const kickBoardVerticalInches = kickBoardHeightInches * kickBoardStackCount;
            const kickBoardSqftPerLfPerSide = kickBoardVerticalInches > 0
              ? (kickBoardVerticalInches / 12)
              : 0;
            const addOnSqftPerLfPerSide = (hasTopCap ? 0.5 : 0) + kickBoardSqftPerLfPerSide;
            const stainSqftBase = normalizedLengthFt * heightFt * sidesMultiplier;
            const stainSqftAddOn = normalizedLengthFt * sidesMultiplier * addOnSqftPerLfPerSide;
            const stainSqft = Math.max(0, Math.round(stainSqftBase + stainSqftAddOn));
            if(stainSelection.wash !== 'none'){
              hasWoodWashSelection = true;
            }
            const stainBrand = normalizeWoodStainBrand(s.woodRepairStainBrand);
            if(stainSqft > 0){
              totals.woodStainSqft += stainSqft;
              woodStainSqftByBrand.set(stainBrand, (woodStainSqftByBrand.get(stainBrand) || 0) + stainSqft);
              const lfPerHour = sidesMultiplier === 2 ? 25 : 50;
              const baseHours = lfPerHour > 0 ? normalizedLengthFt / lfPerHour : 0;
              const topCapHours = hasTopCap ? normalizedLengthFt * (0.5/60) : 0;
              const hours = baseHours + topCapHours;
              woodManHours += hours * 2;
              woodHelperHours += hours;
              woodStainHours += hours;
              woodRequiresTwoPerson = true;
            }
            if(stainSelection.wash !== 'none' && normalizedLengthFt > 0){
              const baseWashRate = sidesMultiplier === 2 ? 50 : 100;
              const baseWashHours = baseWashRate > 0 ? normalizedLengthFt / baseWashRate : 0;
              const washMultiplier = stainSelection.wash === 'hail' ? 2 : 1;
              const washHours = baseWashHours * washMultiplier;
              woodWashHours += washHours;
              woodHelperHours += washHours;
              woodManHours += washHours;
              woodWashDetails.push({
                sectionLabel: s.label || `Section ${idx + 1}`,
                sideLabel,
                lengthFt: normalizedLengthFt,
                washType: stainSelection.wash
              });
            }
            hasWoodStaining = true;
            const sectionLabel = s.label || `Section ${idx + 1}`;
            woodStainDetails.push({ sectionLabel, sideLabel, lengthFt: normalizedLengthFt, sqft: stainSqft });
            woodStainServiceDetails.push({
              side: stainSelection.side,
              sideLabel,
              lengthFt: normalizedLengthFt,
              heightFt,
              sqft: stainSqft,
              washType: stainSelection.wash,
              stainBrand
            });
          }
        }
      });
    }

    const formatWoodStainLength = (value)=>{
      const numeric = parseFloat(value);
      const safe = isFinite(numeric) ? numeric : 0;
      const rounded = Math.round(safe * 10) / 10;
      return formatFtValue(rounded) || '0';
    };
    const buildWoodStainServiceSummary = (details)=>{
      if(!Array.isArray(details) || !details.length) return '';
      const lengthBySide = { both: 0, outside: 0, inside: 0 };
      const otherSideLengths = new Map();
      const heightValues = new Set();
      const brandSet = new Set();
      const oversprayDisclaimer = 'We will use commercially reasonable efforts to minimize overspray onto adjacent structures, landscaping, and surrounding areas; however, we do not warrant or guarantee that overspray, drips, or incidental transfer will be fully avoided. Customer acknowledges and agrees that stain on ground surfaces within approximately two (2) feet on either side of the fence is reasonably expected as part of the work.';
      let totalSqft = 0;
      let hasWash = false;
      let hasStainOnly = false;
      details.forEach(detail=>{
        const sideKey = String(detail.side || '').trim().toLowerCase();
        const lengthFt = parseFloat(detail.lengthFt) || 0;
        const heightFt = parseFloat(detail.heightFt) || 0;
        const sqft = parseFloat(detail.sqft) || 0;
        const washType = String(detail.washType || 'none').trim().toLowerCase();
        const brand = normalizeWoodStainBrand(detail.stainBrand);
        if(lengthFt > 0){
          if(Object.prototype.hasOwnProperty.call(lengthBySide, sideKey)){
            lengthBySide[sideKey] += lengthFt;
          } else if(sideKey){
            otherSideLengths.set(sideKey, (otherSideLengths.get(sideKey) || 0) + lengthFt);
          }
        }
        if(heightFt > 0){
          heightValues.add(Math.round(heightFt * 100) / 100);
        }
        if(sqft > 0){
          totalSqft += sqft;
        }
        if(brand){
          brandSet.add(brand);
        }
        if(washType !== 'none'){
          hasWash = true;
        } else {
          hasStainOnly = true;
        }
      });
      const heightList = Array.from(heightValues);
      let fenceLabel = 'wood fence';
      if(heightList.length === 1){
        const heightLabel = formatFtValue(heightList[0]);
        if(heightLabel){
          fenceLabel = `${heightLabel} ft tall wood fence`;
        }
      }
      const sideParts = [];
      if(lengthBySide.both > 0){
        sideParts.push(`both sides of about ${formatWoodStainLength(lengthBySide.both)} linear ft of ${fenceLabel}`);
      }
      if(lengthBySide.outside > 0){
        sideParts.push(`just the outside of about ${formatWoodStainLength(lengthBySide.outside)} linear ft of ${fenceLabel}`);
      }
      if(lengthBySide.inside > 0){
        sideParts.push(`just the inside of about ${formatWoodStainLength(lengthBySide.inside)} linear ft of ${fenceLabel}`);
      }
      otherSideLengths.forEach((length, side)=>{
        const safeSide = side.replace(/[^a-z0-9\s-]/gi, '').trim() || 'selected side';
        sideParts.push(`${safeSide} of about ${formatWoodStainLength(length)} linear ft of ${fenceLabel}`);
      });
      const actionLead = hasWash ? (hasStainOnly ? 'Wash where needed and stain' : 'Wash and stain') : 'Stain';
      const actionVerb = hasWash ? (hasStainOnly ? 'wash where needed and stain' : 'wash and stain') : 'stain';
      const sentences = [];
      if(sideParts.length){
        sentences.push(`${actionLead} ${joinParts(sideParts)}.`);
      }
      const orderedBrands = [];
      WOOD_STAIN_BRANDS.forEach(brand=>{
        if(brandSet.has(brand)) orderedBrands.push(brand);
      });
      brandSet.forEach(brand=>{
        if(!orderedBrands.includes(brand)) orderedBrands.push(brand);
      });
      let brandPhrase = '';
      if(orderedBrands.length === 1){
        brandPhrase = `${orderedBrands[0]} oil based stain`;
      } else if(orderedBrands.length > 1){
        brandPhrase = `${joinParts(orderedBrands)} oil based stain brands`;
      }
      if(totalSqft > 0){
        const sqftLabel = Math.round(totalSqft);
        sentences.push(`About ${sqftLabel} sq ft total to ${actionVerb}${brandPhrase ? `, using ${brandPhrase}` : ''}.`);
      } else if(brandPhrase){
        sentences.push(`Using ${brandPhrase}.`);
      }
      const summary = sentences.join(' ').trim();
      if(!summary){
        return oversprayDisclaimer;
      }
      return `${summary}\n\n${oversprayDisclaimer}`;
    };
    const woodStainServiceSummary = buildWoodStainServiceSummary(woodStainServiceDetails);
    if(woodStainServiceSummary){
      const hasHailWash = woodStainServiceDetails.some(detail=>String(detail.washType || '').toLowerCase() === 'hail');
      const hasAnyWash = woodStainServiceDetails.some(detail=>String(detail.washType || '').toLowerCase() !== 'none');
      const serviceName = hasAnyWash
        ? (hasHailWash ? 'Wood Fence Wash Hail & Stain' : 'Wood Fence Wash & Stain')
        : 'Wood Fence Staining';
      addServiceLine(serviceName, woodStainServiceSummary);
    }

    if(hasWoodStaining){
      const setupHours = 1;
      woodStainHours += setupHours;
      woodHelperHours += setupHours;
      woodManHours += setupHours * 2;
      const minCrewHours = 2;
      if(woodStainHours < minCrewHours){
        const addedHours = minCrewHours - woodStainHours;
        woodStainHours += addedHours;
        woodHelperHours += addedHours;
        woodManHours += addedHours * 2;
      }
    }

    manHours += woodManHours;
    helperHours += woodHelperHours;
    welderHours += woodWelderHours;
    const stainHours = woodStainHours;
    const washHours = woodWashHours;
    const hasWoodWash = washHours > 0;

    if (totals.digOut > 0){
      addServiceLine('Dig Out Encroaching Soil', `Remove built-up soil along ${totals.digOut} linear feet to expose fence bottom rails. If any additional repairs are exposed, we can let you know and get you a quote for the additional repairs.`);
    }
    const picketCount = parseInt(totals.wiPickets, 10) || 0;
    const puppyPicketCount = parseInt(totals.puppyPickets, 10) || 0;
    if (picketCount > 0 || puppyPicketCount > 0){
      const picketSegments = [];
      if(picketCount > 0){
        const picketPlural = picketCount === 1 ? '' : 's';
        const picketSizes = Array.from(totals.wiPicketSizes || []).filter(Boolean);
        let picketDesc = '';
        if(picketSizes.length === 1){
          const size = picketSizes[0];
          picketDesc = `Cut out ${picketCount}x rusted ${size} picket${picketPlural} and weld in ${picketCount}x new ${size} steel picket${picketPlural}.`;
        } else {
          const sizeSuffix = picketSizes.length > 1 ? ` (${joinParts(picketSizes)})` : '';
          picketDesc = `Cut out ${picketCount}x rusted picket${picketPlural}${sizeSuffix} and weld in ${picketCount}x new steel picket${picketPlural}${sizeSuffix}.`;
        }
        picketSegments.push(picketDesc);
      }
      if(puppyPicketCount > 0){
        const detailParts = [];
        if(totals.puppyPicketDetails && typeof totals.puppyPicketDetails.forEach === 'function'){
          totals.puppyPicketDetails.forEach((count, label)=>{
            if(count>0){ detailParts.push(`${count} × ${label}`); }
          });
        }
        const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
        const puppyLabel = describeCount(puppyPicketCount, 'puppy picket', 'puppy pickets');
        picketSegments.push(`Replace ${puppyLabel}${detail}.`);
      }
      addServiceLine('Replace Damaged Pickets', picketSegments.join(' '));
    }
    if (totals.weldRedos > 0){
      const weldLabel = describeCount(totals.weldRedos, 'weld', 'welds');
      addServiceLine('Redo Broken Welds', `Clean and re-weld ${weldLabel} where the steel is intact (no new material needed).`);
    }
    if (totals.wiPatches > 0){
      const rustedPortionText = totals.wiPatches === 1
        ? '1x rusted portion'
        : `${totals.wiPatches}x rusted portions`;
      const patchSizes = Array.from(totals.wiPatchSizes || []).filter(Boolean);
      let patchDesc = '';
      if(patchSizes.length === 1){
        patchDesc = `Cut out ${rustedPortionText} of ${patchSizes[0]} rail steel and weld in new steel.`;
      } else {
        const sizeSuffix = patchSizes.length > 1 ? ` (${joinParts(patchSizes)})` : '';
        patchDesc = `Cut out ${rustedPortionText} of rail steel${sizeSuffix} and weld in new steel.`;
      }
      addServiceLine('Rail Patch Repairs', patchDesc);
    }
    if (totals.wiRails > 0){
      const railCount = parseInt(totals.wiRails, 10) || 0;
      const railLabel = railCount === 1 ? 'old rail' : 'old rails';
      const railVerb = railCount === 1 ? 'is' : 'are';
      const railNeedVerb = railCount === 1 ? 'needs' : 'need';
      const replaceSizes = Array.from(totals.wiRailReplaceSizes || []).filter(Boolean);
      const sizeSuffix = replaceSizes.length ? ` (${joinParts(replaceSizes)})` : '';
      addServiceLine(
        'Full Rail Replacement',
        `Cut out ${railCount}x ${railLabel}${sizeSuffix} that ${railVerb} rusted through and ${railNeedVerb} to be replaced. Weld in new rail steel.`
      );
    }
    if (totals.wiRailGaps > 0){
      const gapCount = parseInt(totals.wiRailGaps, 10) || 0;
      const gapLabel = describeCount(gapCount, 'full rail gap filler', 'full rail gap fillers');
      const gapSizes = Array.from(totals.wiRailGapSizes || []).filter(Boolean);
      const sizeText = gapSizes.length ? ` using ${joinParts(gapSizes)} rail material` : ' using matching rail material';
      addServiceLine('Full Rail Gap Filler', `Add ${gapLabel}${sizeText} to close open spans and match the existing fence.`);
    }
    const replaceServiceCounts = totals.postsReplace || zeroPostCounts();
    if (replaceServiceCounts.posts2x2 > 0 || replaceServiceCounts.posts3x3 > 0 || replaceServiceCounts.posts1p5 > 0 || replaceServiceCounts.posts4x4 > 0){
      const parts = [];
      if(replaceServiceCounts.posts2x2 > 0) parts.push(describeCount(replaceServiceCounts.posts2x2, '2x2 post', '2x2 posts'));
      if(replaceServiceCounts.posts3x3 > 0) parts.push(describeCount(replaceServiceCounts.posts3x3, '3x3 post', '3x3 posts'));
      if(replaceServiceCounts.posts1p5 > 0) parts.push(describeCount(replaceServiceCounts.posts1p5, '1 1/2" x 1 1/2" post', '1 1/2" x 1 1/2" posts'));
      if(replaceServiceCounts.posts4x4 > 0) parts.push(describeCount(replaceServiceCounts.posts4x4, '4x4 post', '4x4 posts'));
      const partText = joinParts(parts);
      if(partText) addServiceLine('Replace Fence Posts', `Set new ${partText} in concrete and tie into existing panels.`);
    }
    if (totals.postsRealign2x2 > 0 || totals.postsRealign3x3 > 0){
      const parts = [];
      if(totals.postsRealign2x2 > 0) parts.push(describeCount(totals.postsRealign2x2, '2x2 post', '2x2 posts'));
      if(totals.postsRealign3x3 > 0) parts.push(describeCount(totals.postsRealign3x3, '3x3 post', '3x3 posts'));
      const partText = joinParts(parts);
      if(partText) addServiceLine('Realign Leaning Posts', `Plumb and secure ${partText} without replacement.`);
    }
    if (totals.postsRealignCutWeld > 0){
      const cutWeldCounts = totals.postsRealignCutWeldBySize || zeroPostCounts();
      const cutWeldParts = [];
      if(cutWeldCounts.posts2x2 > 0) cutWeldParts.push(describeCount(cutWeldCounts.posts2x2, '2x2 post', '2x2 posts'));
      if(cutWeldCounts.posts3x3 > 0) cutWeldParts.push(describeCount(cutWeldCounts.posts3x3, '3x3 post', '3x3 posts'));
      if(cutWeldCounts.posts1p5 > 0) cutWeldParts.push(describeCount(cutWeldCounts.posts1p5, '1 1/2" x 1 1/2" post', '1 1/2" x 1 1/2" posts'));
      if(cutWeldCounts.posts4x4 > 0) cutWeldParts.push(describeCount(cutWeldCounts.posts4x4, '4x4 post', '4x4 posts'));
      const cutWeldText = cutWeldParts.length
        ? joinParts(cutWeldParts)
        : describeCount(totals.postsRealignCutWeld, 'post', 'posts');
      addServiceLine(
        'Realign Leaning Posts (Cut & Weld)',
        `Realign ${cutWeldText} via cut and weld.`
      );
    }
    if (totals.finials > 0){
      addServiceLine('Finial Replacement', `Install ${describeCount(totals.finials, 'new finial', 'new finials')} to restore decorative picket tops.`);
    }
    if (totals.puppyInserts > 0){
      const sizeParts = [];
      if(totals.puppyInsertSizes && typeof totals.puppyInsertSizes.forEach === 'function'){
        totals.puppyInsertSizes.forEach((count, size)=>{
          if(count>0){ sizeParts.push(`${count} × ${size}`); }
        });
      }
      const sizeNote = sizeParts.length ? ` (${sizeParts.join(', ')})` : '';
      addServiceLine('Install Puppy Picket Inserts', `Install ${describeCount(totals.puppyInserts, 'puppy picket insert', 'puppy picket inserts')}${sizeNote} to close spacing near the bottom of the fence for small pets.`);
    }
    if (totals.caps > 0){
      addServiceLine('Post Cap Replacement', `Install ${describeCount(totals.caps, 'new post cap', 'new post caps')} to protect posts and match the existing style.`);
    }
    if (totals.diagonalBraces > 0){
      const braceDesc = describeCount(totals.diagonalBraces, 'diagonal brace', 'diagonal braces');
      const braceSizeLabels = [];
      if(totals.diagonalBraceSizes && typeof totals.diagonalBraceSizes.forEach === 'function'){
        totals.diagonalBraceSizes.forEach((count, size)=>{
          const qty = parseInt(count,10) || 0;
          if(qty <= 0) return;
          const cleanSize = normalizeLabelText(size || '');
          braceSizeLabels.push(cleanSize ? `${cleanSize} picket steel` : 'picket steel');
        });
      }
      const uniqueBraceLabels = Array.from(new Set(braceSizeLabels)).filter(Boolean);
      const sizeDetail = uniqueBraceLabels.length ? ` using ${joinParts(uniqueBraceLabels)}` : '';
      addServiceLine('Add Diagonal Braces', `Fabricate and install ${braceDesc}${sizeDetail} to close gaps near the bottom of the fence.`);
    }
    if (prefabReplacementCount > 0){
      const typeSuffix = prefabReplacementDetail ? ` (${prefabReplacementDetail})` : '';
      addServiceLine('Install Prefab Panels', `Swap in ${describeCount(prefabReplacementCount, 'prefabricated panel', 'prefabricated panels')}${typeSuffix} and secure them to existing posts.`);
    }
    const customSwapCount = Math.max(0, totals.panelsCustom - (totals.panelsInstallCustom || 0));
    if (customSwapCount > 0){
      addServiceLine('Build Custom Panels', `Fabricate and install ${describeCount(customSwapCount, 'custom panel', 'custom panels')} on site to match the wrought iron design.`);
    }
    if (totals.panelsInstallCustomOnSite > 0){
      addServiceLine('Build Custom Panels', `Fabricate and install ${describeCount(totals.panelsInstallCustomOnSite, 'new custom panel', 'new custom panels')} on site to match the wrought iron design.`);
    }
    if (totals.panelsInstallCustomTmi > 0){
      addServiceLine('Install Ordered Custom Panels', `Order ${describeCount(totals.panelsInstallCustomTmi, 'custom powder-coated panel', 'custom powder-coated panels')} from TMI ($${money(WROUGHT_TMI_CUSTOM_PANEL_COST)} each) and install them on site like prefab panels.`);
    }
    if (totals.panelsInstallCustomShop > 0){
      addServiceLine('Shop Fabrication', `Fabricate ${describeCount(totals.panelsInstallCustomShop, 'new custom panel', 'new custom panels')} in the shop with a ${ONSITE_CREW_SIZE}-person crew (1 hour per panel, cutting and welding included) and install on site.`);
    }
    if (totals.powderCoatPanels > 0 || totals.powderCoatPosts > 0){
      const powderParts = [];
      if(totals.powderCoatPanels > 0){
        powderParts.push(describeCount(totals.powderCoatPanels, 'panel', 'panels'));
      }
      if(totals.powderCoatPosts > 0){
        powderParts.push(describeCount(totals.powderCoatPosts, 'post', 'posts'));
      }
      addServiceLine('Powder Coating', `Powder coat ${joinParts(powderParts)} before installation.`);
    }
    if (totals.walkRealign > 0){
      addServiceLine('Realign Walk Gates', `Adjust and plumb ${describeCount(totals.walkRealign, 'walk gate', 'walk gates')} for smooth swing and latch.`);
    }
    if (walkHardwareSummary.total > 0){
      const detail = walkHardwareSummary.details.length ? ` (${walkHardwareSummary.details.join('; ')})` : '';
      addServiceLine('Replace Walk Gate Hardware', `Install new latch and hinge hardware on ${describeCount(walkHardwareSummary.total, 'walk gate', 'walk gates')}${detail}.`);
    }
    if (totals.walkRebuild > 0){
      addServiceLine('Rebuild Walk Gates', `Rebuild ${describeCount(totals.walkRebuild, 'walk gate', 'walk gates')} with new frame and pickets to match the fence.`);
    }
    if (totals.walkGateAddsSingle > 0){
      addServiceLine('Add Single Walk Gate', `Cut in and install ${describeCount(totals.walkGateAddsSingle, 'single swing walk gate', 'single swing walk gates')} complete with posts, frame, and hardware.`);
    }
    if (totals.walkGateAddsDouble > 0){
      addServiceLine('Add Double Walk Gate', `Cut in and install ${describeCount(totals.walkGateAddsDouble, 'double swing gate', 'double swing gates')} complete with posts, frame, and hardware.`);
    }
    if (totals.woodWalkGateAdds > 0){
      const detailParts = [];
      if(totals.woodWalkGateAddsSingle > 0){
        detailParts.push(`${totals.woodWalkGateAddsSingle} single swing`);
      }
      if(totals.woodWalkGateAddsDouble > 0){
        detailParts.push(`${totals.woodWalkGateAddsDouble} double swing`);
      }
      const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
      addServiceLine('Fence Installation: Walk Gates', `Cut in and install ${describeCount(totals.woodWalkGateAdds, 'wood walk gate', 'wood walk gates')}${detail} complete with wood posts, frame, pickets, and hardware.`);
    }
    if (totals.wroughtReplaceSections > 0){
      addServiceLine('Remove Fence Sections', `Take down and haul away ${describeCount(totals.wroughtReplaceSections, 'existing fence section', 'existing fence sections')} prior to installation.`);
    }
    if (totals.wroughtInstallSections > 0){
      addServiceLine('Install New Fence Sections', `Install panels for ${describeCount(totals.wroughtInstallSections, 'new wrought iron fence section', 'new wrought iron fence sections')} and set posts per section using the selected method (concrete-set or anchored with 1x ${POST_ANCHOR_PLATE_LABEL} + 4x ${POST_ANCHOR_HARDWARE_LABEL}s per post).`);
    }

    const serviceLines = buildServiceLineOutput();
    renderServiceLineNotes(serviceLines);

    if(woodStainSqftByBrand.size){
      woodStainSqftByBrand.forEach((sqft, brand)=>{
        const woodStainBuckets = sqft > 0 ? Math.ceil(sqft / 750) : 0;
        if(woodStainBuckets > 0){
          addMat(materials, woodStainBucketMaterialLabel(brand), woodStainBuckets);
        }
      });
    }

    function addWoodPostReplacementMaterials(){
      state.sections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        const replaceCount = parseInt(s.woodRepairPostReplace || 0, 10) || 0;
        if(replaceCount <= 0) return;
        const heightFt = Math.max(0, feetFromStr(s.woodHeight || s.height));
        const railsPerPost = woodRailsForHeight(heightFt);
        const hasKickBoard = !!s.woodAddKickBoard;
        const kickStack = hasKickBoard ? Math.max(1, parseInt(s.woodKickBoardStack || 0, 10) || 1) : 0;
        const tiesPerPost = railsPerPost + kickStack;
        const totalTies = replaceCount * tiesPerPost;
        const rawPostLabel = s.woodPost || 'Wood post';
        const isRoundSteel = /round steel/i.test(rawPostLabel);
        const postLabel = isRoundSteel
          ? woodRoundSteelPostLabelForHeight(heightFt)
          : normalizeLabelText(rawPostLabel);
        addMat(materials, `${postLabel} posts`, replaceCount);
        const capLabel = normalizeLabelText(s.woodRepairPostReplaceCap || '');
        if(capLabel) addMat(materials, `${capLabel} post cap`, replaceCount);
        const tieSelection = (s.woodRepairPostReplaceTie || defaultTieForWoodPost(s.woodPost) || '');
        const tieLabel = normalizeLabelText(tieSelection);
        if(totalTies > 0 && tieLabel && !isNoTiesSelection(tieLabel)){
          addMat(materials, `Simpson ${tieLabel}`, totalTies);
          addMat(materials, 'lag screws', totalTies * 4);
        }
        const bagsPerPost = heightFt >= 8 ? 1.25 : 1;
        addMat(materials, 'Maximizer bags of concrete', replaceCount * bagsPerPost);
      });
    }

    addWoodPostReplacementMaterials();

    function addWoodPostInstallMaterials(){
      state.sections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        if((s.scopeType || 'repair') !== 'repair') return;
        const installCount = parseInt(s.woodRepairPostInstall || 0, 10) || 0;
        if(installCount <= 0) return;
        const heightFt = Math.max(0, feetFromStr(s.woodHeight || s.height));
        const railsPerPost = woodRailsForHeight(heightFt);
        const hasKickBoard = !!s.woodAddKickBoard;
        const kickStack = hasKickBoard ? Math.max(1, parseInt(s.woodKickBoardStack || 0, 10) || 1) : 0;
        const tiesPerPost = railsPerPost + kickStack;
        const totalTies = installCount * tiesPerPost;
        const rawPostLabel = s.woodPost || 'Wood post';
        const isRoundSteel = /round steel/i.test(rawPostLabel);
        const postLabel = isRoundSteel
          ? woodRoundSteelPostLabelForHeight(heightFt)
          : normalizeLabelText(rawPostLabel);
        addMat(materials, `${postLabel} posts`, installCount);
        const tieSelection = (s.woodRepairPostInstallTie || defaultTieForWoodPost(s.woodPost) || '');
        const tieLabel = normalizeLabelText(tieSelection);
        if(totalTies > 0 && tieLabel && !isNoTiesSelection(tieLabel)){
          addMat(materials, `Simpson ${tieLabel}`, totalTies);
          addMat(materials, 'lag screws', totalTies * 4);
        }
        const method = String(s.woodRepairPostInstallMethod || '').toLowerCase();
        if(method !== 'drive-posts'){
          const bagsPerPost = heightFt >= 8 ? 1.25 : 1;
          addMat(materials, 'Maximizer bags of concrete', installCount * bagsPerPost);
        }
      });
    }

    addWoodPostInstallMaterials();

    function addWoodPicketMaterials(){
      const picketCounts = {};
      state.sections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        if((s.scopeType || 'repair') !== 'repair') return;
        const replaceCount = parseInt(s.woodRepairPicketReplace || 0, 10) || 0;
        const installCount = parseInt(s.woodRepairPicketInstall || 0, 10) || 0;
        const total = replaceCount + installCount;
        if(total <= 0) return;
        const label = woodPicketMaterialLabel(s);
        picketCounts[label] = (picketCounts[label] || 0) + total;
      });
      Object.entries(picketCounts).forEach(([label, qty])=>{
        addMat(materials, label, qty);
      });
    }

    addWoodPicketMaterials();

    function addWoodBoardReplacementMaterials(){
      const addFromMap = (typeLabel, map) => {
        map.forEach((lf, size) => {
          const pieceLen = woodBoardPieceLength(typeLabel, size);
          if(pieceLen > 0){
            const pieces = Math.ceil(lf / pieceLen);
            if(pieces <= 0) return;
            addMat(materials, `wood ${typeLabel} (${size}, ${formatFtValue(pieceLen)} ft)`, pieces);
            return;
          }
          const lengthLabel = formatFtValue(lf);
          if(!lengthLabel) return;
          addMat(materials, `wood ${typeLabel} (${size}, ${lengthLabel} ft)`, 1);
        });
      };
      addFromMap('top cap', woodBoardReplaceLf.topCap);
      addFromMap('trim', woodBoardReplaceLf.trim);
      addFromMap('kick board', woodBoardReplaceLf.kick);
    }

    addWoodBoardReplacementMaterials();

    function addWoodInstallReplacementMaterials(){
      const RAILS_PER_POST = Math.max(1, parseInt(WOOD_INSTALL_PRODUCTION.railsPerPost, 10) || 3);
      const LAG_SCREWS_PER_TIE = 4;
      const POSTMASTER_SCREW_BOX_QTY = 170;
      const parseStack = (value)=>{
        const stack = parseInt(value, 10) || 0;
        return stack > 0 ? stack : 1;
      };
      const boardPieceLabel = (typeLabel, sizeLabel)=>{
        const pieceLen = woodBoardPieceLength(typeLabel, sizeLabel);
        const lengthLabel = formatFtValue(pieceLen > 0 ? pieceLen : 0);
        if(lengthLabel){
          return { label: `wood ${typeLabel} (${sizeLabel}, ${lengthLabel} ft)`, pieceLen };
        }
        return { label: `wood ${typeLabel} (${sizeLabel})`, pieceLen: 0 };
      };
      const trimCoveragePerPiece = (trimSize)=>{
        const normalized = normalizeLabelText(trimSize || '');
        if(normalized === '1x2') return 16;
        const pieceLen = woodBoardPieceLength('trim', normalized);
        return pieceLen > 0 ? pieceLen : 8;
      };
      const defaultPostSpacingFt = Math.max(0.1, Number(WOOD_INSTALL_PRODUCTION.postSpacingFt || 8) || 8);
      const removalPanelWidthFt = Math.max(0.1, Number(WOOD_INSTALL_PRODUCTION.removalPanelWidthFt || 8) || 8);
      const removalCrewCountSixFt = Math.max(1, Number(WOOD_INSTALL_PRODUCTION.removalCrewCountSixFt || 1) || 1);
      const removalMinutesPerPanelSixFt = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.removalMinutesPerPanelSixFt || 10) || 0);
      const removalCrewCountEightFt = Math.max(1, Number(WOOD_INSTALL_PRODUCTION.removalCrewCountEightFt || 2) || 2);
      const removalMinutesPerPanelEightFt = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.removalMinutesPerPanelEightFt || 7) || 0);
      const installSections = state.sections.filter(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return false;
        const scopeType = (s.scopeType || 'repair');
        return scopeType === 'install' || scopeType === 'replace';
      });

      installSections.forEach(s=>{
        if((s.fenceType || '').toLowerCase() !== 'wood') return;
        const scopeType = (s.scopeType || 'repair');
        if(scopeType !== 'install' && scopeType !== 'replace') return;
        const useExistingPostsForReplacement = shouldUseExistingPostsForReplacement(s);
        const postInstallMethod = normalizePostInstallMethod(s.postInstallMethod);
        const installPostSpacingFt = Math.max(0.1, woodInstallPostSpacingFt(s) || defaultPostSpacingFt);
        const replacementPostSpacingFt = woodReplacementPostSpacingFt(s);
        const sectionPostSpacingFt = useExistingPostsForReplacement ? replacementPostSpacingFt : installPostSpacingFt;
        const isRoundSteel = isRoundSteelPost(s.woodPost || '');

        const lengthFt = Math.max(0, parseFloat(s.length || 0) || 0);
        if(lengthFt <= 0) return;
        const spanCount = Math.max(1, Math.ceil(lengthFt / Math.max(0.1, sectionPostSpacingFt || defaultPostSpacingFt)));
        const postsTotal = spanCount + 1;
        const gateAddsForInstall = walkGateAddCount(s);
        const postsToSet = useExistingPostsForReplacement ? 0 : (postsTotal + gateAddsForInstall);
        const railLengthFt = woodInstallRailLengthFt(s);
        const use12FtRailsForExistingPosts = railLengthFt === 12;
        const railSectionsForLength = use12FtRailsForExistingPosts
          ? Math.max(1, Math.ceil(spanCount / 2))
          : (useExistingPostsForReplacement ? spanCount : postsTotal);
        const totalRails = (railSectionsForLength * RAILS_PER_POST) + (gateAddsForInstall * RAILS_PER_POST);
        const linearInches = lengthFt * 12;
        const useOverlapCount = woodStyleUsesOverlapPickets(s.woodStyle || '');
        const picketWidthIn = Math.max(0.1, parseWoodInches(s.woodPicketWidth, 5.5));
        const totalPickets = woodPicketCountForWidth(linearInches, picketWidthIn, useOverlapCount);
        const hasKickBoard = !!s.woodAddKickBoard;
        const kickStack = hasKickBoard ? parseStack(s.woodKickBoardStack) : 0;
        const heightFt = Math.max(0, feetFromStr(s.woodHeight || s.height));
        const isPostmaster = isPostmasterPost(s.woodPost || '');
        const isTallFence = heightFt >= 8;
        if(scopeType === 'replace'){
          const removalPanels = Math.max(1, Math.ceil(lengthFt / removalPanelWidthFt));
          const removalCrewCount = isTallFence ? removalCrewCountEightFt : removalCrewCountSixFt;
          const removalMinutesPerPanel = isTallFence ? removalMinutesPerPanelEightFt : removalMinutesPerPanelSixFt;
          const sectionRemovalManHours = removalPanels * removalCrewCount * (removalMinutesPerPanel / 60);
          woodInstallPlan.removalManHours += sectionRemovalManHours;
        }
        const boardOnBoardBuildMultiplier = /board on board/i.test(String(s.woodStyle || '')) ? 1.2 : 1;
        let topCapPiecesForSection = 0;

        addMat(materials, woodRailMaterialLabel(s, railLengthFt, true), totalRails);
        addMat(materials, woodPicketMaterialLabel(s), totalPickets);

        if(s.woodAddTopCap){
          const topCapSize = normalizeLabelText(s.woodTopCapSize || '2x6');
          const cfg = boardPieceLabel('top cap', topCapSize);
          const topCapPieces = cfg.pieceLen > 0 ? Math.ceil(lengthFt / cfg.pieceLen) : 0;
          if(topCapPieces > 0){
            addMat(materials, cfg.label, topCapPieces);
            topCapPiecesForSection += topCapPieces;
          }
        }

        if(hasKickBoard){
          const kickSize = normalizeLabelText(s.woodKickBoardSize || '2x6');
          const cfg = boardPieceLabel('kick board', kickSize);
          const totalKickLf = lengthFt * kickStack;
          const kickPieces = cfg.pieceLen > 0 ? Math.ceil(totalKickLf / cfg.pieceLen) : 0;
          if(kickPieces > 0){
            addMat(materials, cfg.label, kickPieces);
          }
        }

        if(s.woodAddTrim){
          const trimSizes = splitWoodTrimSizes(s.woodTrimType || '1x4');
          trimSizes.forEach(size=>{
            const trimSize = normalizeLabelText(size || '');
            if(!trimSize) return;
            const cfg = boardPieceLabel('trim', trimSize);
            const coveragePerPiece = trimCoveragePerPiece(trimSize);
            const trimPieces = coveragePerPiece > 0 ? Math.ceil(lengthFt / coveragePerPiece) : 0;
            if(trimPieces > 0){
              addMat(materials, cfg.label, trimPieces);
            }
          });
        }

        const nailsPerPicket = 2 * (RAILS_PER_POST + kickStack);
        const ringShankNails = totalPickets * nailsPerPicket;
        if(ringShankNails > 0){
          addMat(materials, 'ring shank nails', ringShankNails);
        }

        if(!useExistingPostsForReplacement){
          let postLabel = normalizeLabelText(s.woodPost || '') || 'Wood 4x4';
          if(isRoundSteel){
            postLabel = woodRoundSteelPostLabelForHeight(heightFt);
          }
          addMat(materials, `${postLabel} posts`, postsTotal);
          if(postInstallMethod === 'anchored'){
            addPostAnchorMaterials(materials, postsTotal);
          }
        }

        if(isRoundSteel){
          const tiesPerPost = RAILS_PER_POST + kickStack;
          const totalTies = postsTotal * tiesPerPost;
          if(totalTies > 0){
            if(!useExistingPostsForReplacement){
              addMat(materials, 'Simpson 1 piece ties', totalTies);
            }
            addMat(materials, 'lag screws', totalTies * LAG_SCREWS_PER_TIE);
          }
          if(!useExistingPostsForReplacement && postsTotal > 0){
            addMat(materials, 'Dome cap post cap', postsTotal);
          }
          if(!useExistingPostsForReplacement){
            const bagsPerPost = heightFt >= 8 ? 1.25 : 1;
            if(postInstallMethod !== 'anchored'){
              addMat(materials, 'Maximizer bags of concrete', postsTotal * bagsPerPost);
            }
          }
        }
        if(isPostmaster){
          const postmasterScrewBoxes = Math.ceil((totalRails * 6) / POSTMASTER_SCREW_BOX_QTY);
          if(postmasterScrewBoxes > 0){
            addMat(materials, 'postmaster screw boxes (170)', postmasterScrewBoxes);
          }
        }

        woodInstallPlan.sections += 1;
        woodInstallPlan.totalLf += lengthFt;
        woodInstallPlan.totalPosts += postsToSet;
        if(isTallFence){
          woodInstallPlan.totalTallPosts += postsToSet;
        }
        woodInstallPlan.totalBuildLfAdjusted += (lengthFt * boardOnBoardBuildMultiplier);
        woodInstallPlan.totalTopCapPieces += topCapPiecesForSection;
        woodInstallPlan.totalRails += totalRails;
        woodInstallPlan.totalPickets += totalPickets;
      });

      const maxCrewCount = Math.max(1, ONSITE_CREW_SIZE);
      const maxCrewDayHours = Math.max(0.25, CREW_SETTINGS.maxDayHours || 13);
      const layoutCrewHoursPerJob = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.layoutCrewHoursPerJob || 1) || 0);
      const digCrewHoursPerPostHand = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.digCrewHoursPerPostHand || 0.25) || 0);
      const digCrewHoursPerPostSkid = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.digCrewHoursPerPostSkid || (5 / 60)) || 0);
      const setCrewHoursPerPost = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.setCrewHoursPerPost || 0.125) || 0);
      const tallDigExtraCrewHoursPerPost = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.tallDigExtraCrewHoursPerPost || (10 / 60)) || 0);
      const tallSetExtraCrewHoursPerPost = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.tallSetExtraCrewHoursPerPost || (5 / 60)) || 0);
      const sameDayCureWaitCrewHours = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.sameDayCureWaitCrewHours || 2) || 0);
      const buildLfPerCrewDay = Math.max(0.01, Number(WOOD_INSTALL_PRODUCTION.buildLfPerCrewDay || 200) || 200);
      const removalHaulCostPerLf = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.removalHaulCostPerLf || 3.9) || 0);
      const removalHaulMinimum = Math.max(0, Number(WOOD_INSTALL_PRODUCTION.removalHaulMinimum || 100) || 0);
      const tallPostsToSet = Math.max(0, Number(woodInstallPlan.totalTallPosts || 0) || 0);

      if(woodInstallPlan.removalLf > 0){
        const removalManHours = Math.max(0, Number(woodInstallPlan.removalManHours || 0) || 0);
        woodInstallPlan.removalManHours = removalManHours;
        woodInstallPlan.removalCrewHours = removalManHours / maxCrewCount;
        woodInstallPlan.removalSubLf = woodInstallPlan.removalLf;
        const baseRemovalCost = woodInstallPlan.removalLf * removalHaulCostPerLf;
        woodInstallPlan.removalSubCost = Math.max(removalHaulMinimum, baseRemovalCost);
        totals.removalLf += woodInstallPlan.removalLf;
        totals.removalCost += woodInstallPlan.removalSubCost;
      }

      if(woodInstallPlan.totalPosts > 0){
        const layoutCrewHours = layoutCrewHoursPerJob;
        const digCrewHoursHand = (woodInstallPlan.totalPosts * digCrewHoursPerPostHand) + (tallPostsToSet * tallDigExtraCrewHoursPerPost);
        const setCrewHours = (woodInstallPlan.totalPosts * setCrewHoursPerPost) + (tallPostsToSet * tallSetExtraCrewHoursPerPost);
        let postCrewHoursCore = layoutCrewHours + digCrewHoursHand + setCrewHours;
        if(postCrewHoursCore > maxCrewDayHours){
          const digCrewHoursSkid = (woodInstallPlan.totalPosts * digCrewHoursPerPostSkid) + (tallPostsToSet * tallDigExtraCrewHoursPerPost);
          postCrewHoursCore = layoutCrewHours + digCrewHoursSkid + setCrewHours;
          woodInstallPlan.skidDays = Math.max(1, Math.ceil(postCrewHoursCore / maxCrewDayHours));
        }
        woodInstallPlan.postCrewHours = postCrewHoursCore;
        woodInstallPlan.postManHours = postCrewHoursCore * maxCrewCount;
      }

      if(woodInstallPlan.totalLf > 0 || woodInstallPlan.totalTopCapPieces > 0){
        const buildCrewHoursPerLf = maxCrewDayHours / buildLfPerCrewDay;
        const adjustedBuildLf = Math.max(0, Number(woodInstallPlan.totalBuildLfAdjusted || 0) || 0);
        const topCapManHours = Math.max(0, Number(woodInstallPlan.totalTopCapPieces || 0) || 0) * (10 / 60);
        const topCapCrewHours = topCapManHours / maxCrewCount;
        woodInstallPlan.buildCrewHours = (adjustedBuildLf * buildCrewHoursPerLf) + topCapCrewHours;
        woodInstallPlan.buildManHours = woodInstallPlan.buildCrewHours * maxCrewCount;
      }
      const sameDayWoodInstall = (
        woodInstallPlan.sections > 0 &&
        woodInstallPlan.totalPosts > 0 &&
        woodInstallPlan.totalPosts <= 4 &&
        woodInstallPlan.buildCrewHours > 0
      );
      if(sameDayWoodInstall && sameDayCureWaitCrewHours > 0){
        woodInstallPlan.cureWaitCrewHours = sameDayCureWaitCrewHours;
        woodInstallPlan.cureWaitManHours = sameDayCureWaitCrewHours * maxCrewCount;
        woodInstallPlan.postCrewHours += woodInstallPlan.cureWaitCrewHours;
        woodInstallPlan.postManHours += woodInstallPlan.cureWaitManHours;
      }

      const postPhaseCrewHours = woodInstallPlan.postCrewHours + woodInstallPlan.removalCrewHours;
      woodInstallPlan.postDays = postPhaseCrewHours > 0 ? Math.ceil(postPhaseCrewHours / maxCrewDayHours) : 0;
      woodInstallPlan.buildDays = woodInstallPlan.buildCrewHours > 0 ? Math.ceil(woodInstallPlan.buildCrewHours / maxCrewDayHours) : 0;
      if(woodInstallPlan.skidDays > 0){
        addMat(materials, 'Skid steer rental', woodInstallPlan.skidDays);
      }
    }

    addWoodInstallReplacementMaterials();

    // ==== Materials aggregation ====
    let paintLenTotal = 0;
    let paintGallons = 0;
    let paintCans = 0;
    let primerGallons = 0;
    let primerCans = 0;

    const replacePostCounts = totals.postsReplace || zeroPostCounts();
    const wroughtPostReplacements = (
      (replacePostCounts.posts1p5 || 0) +
      (replacePostCounts.posts2x2 || 0) +
      (replacePostCounts.posts3x3 || 0) +
      (replacePostCounts.posts4x4 || 0)
    );
    const concreteRealignCount = totals.postsRealign2x2 + totals.postsRealign3x3;
    const weldRepairHours = (
      totals.wiPickets*12 +
      totals.puppyPickets*12 +
      totals.diagonalBraces*20 +
      totals.wiPatches*20 +
      totals.wiRails*45 +
      totals.wiRailGaps*20 +
      totals.weldRedos*5
    )/60;
    manHours += weldRepairHours;
    welderHours += weldRepairHours;
    const concreteRealignHelperManHours = concreteRealignCount * (30/60);
    if(concreteRealignHelperManHours > 0){
      manHours += concreteRealignHelperManHours;
      helperHours += concreteRealignHelperManHours;
    }
    const wroughtRemovalCrewCountPerPanel = Math.max(1, Number(WROUGHT_INSTALL_PRODUCTION.removalCrewCountPerPanel || 1) || 1);
    const wroughtRemovalMinutesPerPanel = Math.max(0, Number(WROUGHT_INSTALL_PRODUCTION.removalMinutesPerPanel || 10) || 0);
    const wroughtRemovalManHours = Math.max(0, wroughtInstallRemovalPanels) * wroughtRemovalCrewCountPerPanel * (wroughtRemovalMinutesPerPanel / 60);
    if(wroughtRemovalManHours > 0){
      manHours += wroughtRemovalManHours;
      helperHours += wroughtRemovalManHours;
    }
    let postReplacementCrewManHours = 0;
    let postReplacementWelderHours = 0;
    if(wroughtPostReplacements > 0){
      // Post replacement workflow per post:
      // Helpers handle pull/clean/set plus panel cut-off and loading
      // removed post/concrete into the truck bed.
      // Welder time is only for welding panels back to the new post.
      // Multiple posts can run in parallel with a full crew, so elapsed
      // time scales in scheduling while total man-hours remain additive.
      const crewManHoursPerPost = 85/60;
      const welderHoursPerPost = 20/60;
      postReplacementCrewManHours = wroughtPostReplacements * crewManHoursPerPost;
      postReplacementWelderHours = wroughtPostReplacements * welderHoursPerPost;
      manHours += postReplacementCrewManHours + postReplacementWelderHours;
      helperHours += postReplacementCrewManHours;
      welderHours += postReplacementWelderHours;
    }
    const installPostCounts = totals.postsInstall || zeroPostCounts();
    const wallPostCountsForLabor = totals.retainingWallPosts || zeroPostCounts();
    const installPostsNeedingCrew = (
      Math.max(0, (installPostCounts.posts1p5 || 0) - (wallPostCountsForLabor.posts1p5 || 0)) +
      Math.max(0, (installPostCounts.posts2x2 || 0) - (wallPostCountsForLabor.posts2x2 || 0)) +
      Math.max(0, (installPostCounts.posts3x3 || 0) - (wallPostCountsForLabor.posts3x3 || 0)) +
      Math.max(0, (installPostCounts.posts4x4 || 0) - (wallPostCountsForLabor.posts4x4 || 0))
    );
    let postInstallManHours = 0;
    let cureManHours = 0;
    if(installPostsNeedingCrew > 0){
      const maxCrewDayHours = Math.max(0.25, CREW_SETTINGS.maxDayHours || 13);
      const layoutCrewHoursPerJob = Math.max(0, Number(WROUGHT_INSTALL_PRODUCTION.layoutCrewHoursPerJob || 1) || 0);
      const digCrewHoursPerPostHand = Math.max(0, Number(WROUGHT_INSTALL_PRODUCTION.digCrewHoursPerPostHand || 0.25) || 0);
      const digCrewHoursPerPostSkid = Math.max(0, Number(WROUGHT_INSTALL_PRODUCTION.digCrewHoursPerPostSkid || (5 / 60)) || 0);
      const setCrewHoursPerPost = Math.max(0, Number(WROUGHT_INSTALL_PRODUCTION.setCrewHoursPerPost || 0.125) || 0);
      const layoutCrewHours = layoutCrewHoursPerJob;
      const digCrewHoursHand = installPostsNeedingCrew * digCrewHoursPerPostHand;
      const setCrewHours = installPostsNeedingCrew * setCrewHoursPerPost;
      let crewHours = layoutCrewHours + digCrewHoursHand + setCrewHours;
      if(crewHours > maxCrewDayHours){
        const digCrewHoursSkid = installPostsNeedingCrew * digCrewHoursPerPostSkid;
        crewHours = layoutCrewHours + digCrewHoursSkid + setCrewHours;
        const skidDays = Math.max(1, Math.ceil(crewHours / maxCrewDayHours));
        addMat(materials, 'Skid steer rental', skidDays);
      }
      postInstallManHours = crewHours * ONSITE_CREW_SIZE;
      manHours += postInstallManHours;
      helperHours += postInstallManHours;
    }
    // Do not apply a per-post concrete cure wait to wrought post installs.
    // Wood same-day cure wait is handled separately in woodInstallPlan.
    const cutWeldWelderHours = totals.postsRealignCutWeld * (20/60);
    const cutWeldHelperHours = totals.postsRealignCutWeld * (20/60);
    if(totals.postsRealignCutWeld > 0){
      manHours += cutWeldWelderHours + cutWeldHelperHours;
      helperHours += cutWeldHelperHours;
      welderHours += cutWeldWelderHours;
    }
    const gateRepairHours = totals.walkRealign * 1 + totals.walkHardware * 1 + totals.walkRebuild * 3;
    manHours += gateRepairHours;
    welderHours += gateRepairHours;
    // Dig out: 5 minutes per LF
    const digHours = totals.digOut * (5/60);
    manHours += digHours;
    helperHours += digHours;
    // Finials: 0.5 minutes each
    const finialHours = totals.finials * (0.5/60);
    manHours += finialHours;
    welderHours += finialHours;
    // Caps: 20 seconds each
    const capHours = totals.caps * (20/60);
    manHours += capHours;
    helperHours += capHours;
    const puppyInsertWelderHours = totals.puppyInserts * 0.5; // 30 minutes each
    const puppyInsertHelperHours = totals.puppyInserts * (5/60); // 5 minutes each
    const puppyInsertManHours = puppyInsertWelderHours + puppyInsertHelperHours;
    manHours += puppyInsertManHours;
    welderHours += puppyInsertWelderHours;
    helperHours += puppyInsertHelperHours;
    const wroughtAddedGateHours = (totals.walkGateAddsSingle * 2) + (totals.walkGateAddsDouble * 3);
    if(wroughtAddedGateHours > 0){
      manHours += wroughtAddedGateHours;
      welderHours += wroughtAddedGateHours;
    }
    const woodAddedGateHours = (totals.woodWalkGateAddsSingle * 2) + (totals.woodWalkGateAddsDouble * 3);
    if(woodAddedGateHours > 0){
      manHours += woodAddedGateHours;
      helperHours += woodAddedGateHours;
    }
    // Sliding drive gate chain replacement: 1 crew hour each
    const driveGateChainCrewHours = totals.driveGateChainReplacements * 1;
    let driveGateChainManHours = 0;
    if(driveGateChainCrewHours > 0){
      driveGateChainManHours = driveGateChainCrewHours * ONSITE_CREW_SIZE;
      manHours += driveGateChainManHours;
      helperHours += driveGateChainManHours;
    }
    let driveGateOperatorHours = 0;
    if(totals.driveGateOperatorTypes && typeof totals.driveGateOperatorTypes.forEach === 'function'){
      totals.driveGateOperatorTypes.forEach((count, label)=>{
        const qty = parseInt(count,10) || 0;
        if(qty <= 0) return;
        const normalized = String(label||'').toLowerCase();
        const perHours = normalized.includes('double') ? 5 : 3;
        driveGateOperatorHours += qty * perHours;
      });
    } else {
      driveGateOperatorHours = totals.driveGateOperators * 3;
    }
    manHours += driveGateOperatorHours;
    helperHours += driveGateOperatorHours;

    let driveGateOperatorInstallHours = 0;
    if(totals.driveGateOperatorInstallTypes && typeof totals.driveGateOperatorInstallTypes.forEach === 'function'){
      totals.driveGateOperatorInstallTypes.forEach((count, label)=>{
        const qty = parseInt(count,10) || 0;
        if(qty <= 0) return;
        const normalized = String(label||'').toLowerCase();
        const perHours = normalized.includes('double') ? 5 : 3;
        driveGateOperatorInstallHours += qty * perHours;
      });
    } else {
      driveGateOperatorInstallHours = totals.driveGateOperatorInstalls * 3;
    }
    if(totals.driveGateOperatorInstallPlatforms > 0){
      driveGateOperatorInstallHours += totals.driveGateOperatorInstallPlatforms * 2;
    }
    manHours += driveGateOperatorInstallHours;
    helperHours += driveGateOperatorInstallHours;

    // posts
    const posts2x2ByLenCalc = {};
    state.sections.forEach(s=>{
      const hft = feetFromStr(s.height);
      const postLen = Math.max(8, hft + 3);
      const customPostLen = Math.max(1, hft + 3);
      const scopeType = s.scopeType || 'repair';
      const isInstallScope = scopeType === 'install' || scopeType === 'replace';
      const isWroughtSection = (s.fenceType || '').toLowerCase() === 'wrought iron';
      const hasCustomInstallPanels = (parseInt(s._installCalc?.customPanels || 0, 10) || 0) > 0;
      const isCustomInstallSection = isInstallScope && isWroughtSection && hasCustomInstallPanels;
      const installStickLengthFt = isCustomInstallSection
        ? wroughtCustomStickLengthFt(s.wroughtCustomStickLength)
        : 12;
      const addRawSticksForPosts = (kind, count, stickLengthFt = 12, useCustomDepth = false)=>{
        const qty = Math.max(0, parseInt(count, 10) || 0);
        if(qty <= 0) return;
        const cutLengthFt = useCustomDepth ? customPostLen : postLen;
        const piecesPerStick = Math.max(1, Math.floor(wroughtCustomStickLengthFt(stickLengthFt) / Math.max(1, cutLengthFt)));
        const sticks = Math.ceil(qty / piecesPerStick);
        addSteelRawSticks(kind, sticks, stickLengthFt);
      };

      const repCounts = countPostGroups(s.postReplacements);
      addRawSticksForPosts('raw1p5', repCounts.posts1p5 || 0, 12);
      const nReplace = repCounts.posts2x2 || 0;
      if(nReplace>0){ posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + nReplace; }
      addRawSticksForPosts('raw3x3', repCounts.posts3x3 || 0, 12);
      addRawSticksForPosts('raw4x4', repCounts.posts4x4 || 0, 12);

      const installPostCounts = s._installCalc?.postCounts || {};
      const nInstall1p5 = parseInt(installPostCounts.posts1p5 || 0,10) || 0;
      addRawSticksForPosts('raw1p5', nInstall1p5, installStickLengthFt, isCustomInstallSection);

      const nInstall2x2 = parseInt(s._installCalc?.postCounts?.posts2x2 || 0,10) || 0;
      if(nInstall2x2>0){
        if(isCustomInstallSection){
          addRawSticksForPosts('raw2x2', nInstall2x2, installStickLengthFt, true);
        } else {
          posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + nInstall2x2;
        }
      }
      const nInstall3x3 = parseInt(installPostCounts.posts3x3 || 0,10) || 0;
      addRawSticksForPosts('raw3x3', nInstall3x3, installStickLengthFt, isCustomInstallSection);
      const nInstall4x4 = parseInt(installPostCounts.posts4x4 || 0,10) || 0;
      addRawSticksForPosts('raw4x4', nInstall4x4, installStickLengthFt, isCustomInstallSection);

      const isWoodSection = (s.fenceType || '').toLowerCase() === 'wood';
      const addG = !isWoodSection ? walkGateAddCount(s) : 0;
      const gatePostSize = (s.walkAddPostSize||'').trim();
      const gateStickLengthFt = isCustomInstallSection ? installStickLengthFt : 12;
      if(addG>0 && gatePostSize === '1 1/2" x 1 1/2"'){
        addRawSticksForPosts('raw1p5', addG, gateStickLengthFt, isCustomInstallSection);
      }
      if(addG>0 && gatePostSize === '2x2'){
        if(isCustomInstallSection){
          addRawSticksForPosts('raw2x2', addG, gateStickLengthFt, true);
        } else {
          posts2x2ByLenCalc[postLen] = (posts2x2ByLenCalc[postLen]||0) + addG;
        }
      }
      if(addG>0 && gatePostSize === '3x3'){
        addRawSticksForPosts('raw3x3', addG, gateStickLengthFt, isCustomInstallSection);
      }
      if(addG>0 && gatePostSize === '4x4'){
        addRawSticksForPosts('raw4x4', addG, gateStickLengthFt, isCustomInstallSection);
      }
    });
    Object.keys(posts2x2ByLenCalc).sort((a,b)=>parseInt(a,10)-parseInt(b,10)).forEach(len=>{
      addMat(materials, `2x2x${len} posts`, posts2x2ByLenCalc[len]);
    });

    // Concrete (exclude posts set within retaining walls)
    const wallPostCounts = totals.retainingWallPosts || zeroPostCounts();
    const installAnchoredCounts = totals.postsInstallAnchored || zeroPostCounts();
    const posts1p5NeedingConcrete = Math.max(0, totals.posts1p5 - (wallPostCounts.posts1p5 || 0) - (installAnchoredCounts.posts1p5 || 0));
    const posts2x2NeedingConcrete = Math.max(0, totals.posts2x2 - (wallPostCounts.posts2x2 || 0) - (installAnchoredCounts.posts2x2 || 0));
    const posts3x3NeedingConcrete = Math.max(0, totals.posts3x3 - (wallPostCounts.posts3x3 || 0) - (installAnchoredCounts.posts3x3 || 0));
    const posts4x4NeedingConcrete = Math.max(0, totals.posts4x4 - (wallPostCounts.posts4x4 || 0) - (installAnchoredCounts.posts4x4 || 0));
    const anchoredInstallPostsNeedingHardware = (
      Math.max(0, (installAnchoredCounts.posts1p5 || 0) - (wallPostCounts.posts1p5 || 0)) +
      Math.max(0, (installAnchoredCounts.posts2x2 || 0) - (wallPostCounts.posts2x2 || 0)) +
      Math.max(0, (installAnchoredCounts.posts3x3 || 0) - (wallPostCounts.posts3x3 || 0)) +
      Math.max(0, (installAnchoredCounts.posts4x4 || 0) - (wallPostCounts.posts4x4 || 0))
    );
    const concreteBagsCalc = posts2x2NeedingConcrete + posts3x3NeedingConcrete + posts1p5NeedingConcrete + posts4x4NeedingConcrete + Math.ceil((totals.postsRealign2x2 + totals.postsRealign3x3) * 0.5) + totals.walkRealign + totals.walkGateAddsRepair;
    if(anchoredInstallPostsNeedingHardware > 0){
      addPostAnchorMaterials(materials, anchoredInstallPostsNeedingHardware);
    }

    // Gate bits + gate materials
    const latchCounts = {};
    const hingeCounts = {};
    state.sections.forEach(s=>{
      const hw = parseInt(s.walkGatesHardware||0,10) || 0;
      const rb = parseInt(s.walkGatesRebuild||0,10) || 0;
      if(hw>0){
        if(s.walkLatch) latchCounts[s.walkLatch] = (latchCounts[s.walkLatch]||0) + hw;
        if(s.walkHinges) hingeCounts[s.walkHinges] = (hingeCounts[s.walkHinges]||0) + hw;
      }
      if(rb>0){
        if(s.walkRebuildLatch) latchCounts[s.walkRebuildLatch] = (latchCounts[s.walkRebuildLatch]||0) + rb;
        if(s.walkRebuildHinges) hingeCounts[s.walkRebuildHinges] = (hingeCounts[s.walkRebuildHinges]||0) + rb;
        const frame = s.walkRebuildFrame || '';
        const pick  = s.walkRebuildPicket || '';
        const fN = normalizeSize(frame);
        const pN = normalizeSize(pick);
        if(fN === '1\"' && (pN === '1/2\"' || pN === '5/8\"')){
          const gateDescParts = [];
          if((s.walkRebuildFrame||'').trim()){ gateDescParts.push(`frame ${s.walkRebuildFrame.trim()}`); }
          if((s.walkRebuildPicket||'').trim()){ gateDescParts.push(`pickets ${s.walkRebuildPicket.trim()}`); }
          const gateDesc = gateDescParts.length ? ` (${gateDescParts.join(', ')})` : '';
          addMat(materials, `prefab gate panel${gateDesc}`, rb);
          addRailSticks(frame, rb * 2);
        } else {
          addRailSticks(frame, rb * 2);
          addPicketSticks(pick, rb * 2);
        }
      }
      const addG = walkGateAddCount(s);
      if(addG>0){
        const isWoodSection = (s.fenceType || '').toLowerCase() === 'wood';
        if(isWoodSection){
          const scopeType = String(s.scopeType || 'repair').toLowerCase();
          const isInstallScope = scopeType === 'install' || scopeType === 'replace';
          const postInstallMethod = normalizePostInstallMethod(s.postInstallMethod);
          const shouldAnchorGatePosts = isInstallScope && postInstallMethod === 'anchored';
          const gateType = walkGateAddType(s);
          const leafCount = walkGateTypeIsDouble(gateType) ? 2 : 1;
          const frameSize = walkGateAddFrameLabel(s);
          const picketWidth = walkGateAddPicketLabel(s);
          const framePiecesPerLeaf = 5;
          const totalFramePieces = addG * leafCount * framePiecesPerLeaf;
          addMat(materials, walkGateAddLatchLabel(s), addG);
          addMat(materials, walkGateAddHingeLabel(s), addG);
          addMat(materials, woodGateFrameMaterialLabel(s, frameSize), totalFramePieces);

          const picketWidthIn = parseWoodInches(picketWidth, parseWoodInches(s.woodPicketWidth, 5.5));
          const useOverlapCount = woodStyleUsesOverlapPickets(s.woodStyle || '');
          const picketsPerLeaf = woodPicketCountForWidth(60, picketWidthIn, useOverlapCount);
          if(picketsPerLeaf > 0){
            addMat(materials, woodPicketMaterialLabelWithWidth(s, picketWidth), picketsPerLeaf * addG * leafCount);
          }

          const postType = walkGateAddPostLabel(s);
          const heightFt = Math.max(0, feetFromStr(s.woodHeight || s.height));
          if(isRoundSteelPost(postType)){
            const postLabel = woodRoundSteelPostLabelForHeight(heightFt);
            addMat(materials, `${postLabel} posts`, addG);
            const kickStack = s.woodAddKickBoard ? Math.max(1, parseInt(s.woodKickBoardStack || 0, 10) || 1) : 0;
            const tiesPerPost = 3 + kickStack;
            const totalTies = addG * tiesPerPost;
            if(totalTies > 0){
              addMat(materials, 'Simpson 1 piece ties', totalTies);
              addMat(materials, 'lag screws', totalTies * 4);
            }
            addMat(materials, 'Dome cap post cap', addG);
            if(shouldAnchorGatePosts){
              addPostAnchorMaterials(materials, addG);
            } else {
              const bagsPerPost = heightFt >= 8 ? 1.25 : 1;
              addMat(materials, 'Maximizer bags of concrete', addG * bagsPerPost);
            }
          } else if(isPostmasterPost(postType)){
            addMat(materials, 'Postmaster posts', addG);
            if(shouldAnchorGatePosts){
              addPostAnchorMaterials(materials, addG);
            }
          } else {
            addMat(materials, 'Wood 4x4 posts', addG);
            if(shouldAnchorGatePosts){
              addPostAnchorMaterials(materials, addG);
            }
          }

          if(s.woodAddTopCap){
            const size = normalizeLabelText(s.woodTopCapSize || '2x6');
            addMat(materials, `wood top cap (${size})`, addG * leafCount);
          }
          if(s.woodAddTrim){
            const trimSizes = splitWoodTrimSizes(s.woodTrimType || '1x4');
            trimSizes.forEach(size=>{
              addMat(materials, `wood trim (${size})`, addG * leafCount);
            });
          }
          if(s.woodAddKickBoard){
            const size = normalizeLabelText(s.woodKickBoardSize || '2x6');
            const stack = Math.max(1, parseInt(s.woodKickBoardStack || 0, 10) || 1);
            addMat(materials, `wood kick board (${size})`, addG * leafCount * stack);
          }
        } else {
          const latch = walkGateAddLatchLabel(s);
          const hinges = walkGateAddHingeLabel(s);
          if(latch) latchCounts[latch] = (latchCounts[latch]||0) + addG;
          if(hinges) hingeCounts[hinges] = (hingeCounts[hinges]||0) + addG;
          const gateType = walkGateAddType(s);
          const perGateRail = walkGateTypeIsDouble(gateType) ? 4 : 2;
          const sectionRails = sectionRailSizes(s);
          const frame = walkGateAddFrameLabel(s);
          const railsToCount = sectionRails.length ? sectionRails : (frame ? [frame] : []);
          railsToCount.forEach(size=>{
            addRailSticks(size, addG * perGateRail);
          });
        }
      }
    });

    // Add latches/hinges
    Object.keys(latchCounts).forEach(k=> addMat(materials, k, latchCounts[k]));
    const hingeLabel = (k)=> k==='Door Hinges' ? 'Pair of Door Hinges'
                            : k==='Bat Wing Hinges' ? 'Pair of Bat Wing Hinges'
                            : k==='Auto Close Hinges' ? 'Pair of Auto Close Hinges'
                            : k;
    Object.keys(hingeCounts).forEach(k=> addMat(materials, hingeLabel(k), hingeCounts[k]));

    addMat(materials, 'Maximizer bags of concrete', concreteBagsCalc);

    // WI picket sticks from replacements
    const picketBySizeCalc = {};
    state.sections.forEach(s=>{
      const scopeType = s.scopeType || 'repair';
      const isRepair = scopeType !== 'install' && scopeType !== 'replace';
      const isWrought = (s.fenceType || '').toLowerCase() === 'wrought iron';
      const need = parseInt(s.wiPickets||0,10) || 0;
      if(need){
        let ph = parseInt(s.picketHeight||0,10) || 0; // inches
        if (ph <= 0) {
          const hf = feetFromStr(s.height);
          if (hf > 0) ph = hf * 12;
        }
        if (ph <= 0) ph = 54;
        const perStick = Math.max(1, Math.floor(144 / ph));
        const sticks = Math.ceil(need / perStick);
        const size = normalizeSize(s.picketSize);
        picketBySizeCalc[size] = (picketBySizeCalc[size]||0) + sticks;
      }
      if(isRepair && isWrought && hasPuppyPickets(s.puppy)){
        const puppyNeed = parseInt(s.puppyPicketReplace||0,10) || 0;
        if(puppyNeed){
          let ph = parseInt(s.puppyPicketHeight||0,10) || 0;
          if (ph <= 0) {
            ph = parseInt(s.picketHeight||0,10) || 0;
          }
          if (ph <= 0) {
            const hf = feetFromStr(s.height);
            if (hf > 0) ph = hf * 12;
          }
          if (ph <= 0) ph = 54;
          const perStick = Math.max(1, Math.floor(144 / ph));
          const sticks = Math.ceil(puppyNeed / perStick);
          const size = normalizeSize(s.puppyPicketSize || s.picketSize);
          picketBySizeCalc[size] = (picketBySizeCalc[size]||0) + sticks;
        }
      }
    });
    Object.entries(picketBySizeCalc).forEach(([size, qty])=>{
      addPicketSticks(size, qty);
    });

    Object.entries(diagonalBraceFeetBySize).forEach(([size, feetTotal])=>{
      const totalFeet = parseFloat(feetTotal) || 0;
      if(totalFeet <= 0) return;
      const sticks = Math.ceil(totalFeet / 12);
      if(sticks > 0){
        addPicketSticks(size, sticks);
      }
    });

    // Rails: patches & replacements → sticks
    const railStickBySizeMat = {};
    const patchBySizeMat = {};
    const replBySizeMat = {};
    const gapBySizeMat = {};
    function inc(map, key, delta){ if(!key) return; map[key] = (map[key]||0) + (delta||0); }

    state.sections.forEach(s=>{
      const rCount = s.railsCount || (s.rails||[]).length || 0;
      for(let i=0;i<rCount;i++){
        const r = (s.rails||[])[i] || {};
        const p = parseInt(r.patches||0,10) || 0;
        const rep = parseInt(r.replacements||0,10) || 0;
        if(p>0){
          inc(patchBySizeMat, normalizeSize(r.size), p);
          if(r.stacked) inc(patchBySizeMat, normalizeSize(r.size2), p);
        }
        if(rep>0){
          inc(replBySizeMat, normalizeSize(r.size), rep);
          if(r.stacked) inc(replBySizeMat, normalizeSize(r.size2), rep);
        }
      }
      const gapArr = Array.isArray(s.gapAdditions) ? s.gapAdditions : [];
      gapArr.forEach(item=>{
        const qty = parseInt(item?.qty||0,10) || 0;
        if(qty<=0) return;
        const normalized = normalizeSize(item?.size);
        inc(gapBySizeMat, normalized, qty);
      });
    });

    Object.entries(replBySizeMat).forEach(([size, rep])=>{
      if(rep>0) inc(railStickBySizeMat, size, rep);
    });

    Object.entries(gapBySizeMat).forEach(([size, gapCount])=>{
      if(gapCount>0) inc(railStickBySizeMat, size, gapCount);
    });

    Object.entries(patchBySizeMat).forEach(([size, pcount])=>{
      const credits = replBySizeMat[size] || 0;
      const remaining = Math.max(0, (pcount||0) - credits);
      if(remaining>0){
        inc(railStickBySizeMat, size, Math.ceil(remaining/6));
      }
    });

    Object.keys(railStickBySizeMat).forEach(size=>{
      addRailSticks(size, railStickBySizeMat[size]);
    });

    // Paint estimates
    let totalLenPaint = 0;
    let totalLenPaintByCoat = 0;
    let totalLenPrimePaint = 0;
    let totalLenSpot  = 0;
    let totalLenSpotByCoat = 0;
    let finialSprayCanUnits = 0;
    state.sections.forEach(s=>{
      const paintingMode = effectiveWroughtPaintingSelection(s);
      const len = (parseInt(s.length||0,10) || 0);
      const coatCount = paintCoatCountForSection(s);
      if (paintingMode === 'Paint Section') {
        if(len > 0){
          totalLenPaint += len;
          totalLenPaintByCoat += (len * coatCount);
        }
      } else if (paintingMode === 'Prime and Paint') {
        if(len > 0){
          totalLenPaint += len;
          totalLenPaintByCoat += (len * coatCount);
          totalLenPrimePaint += len;
        }
      } else if (paintingMode === 'Spot Paint Welds') {
        if(len > 0){
          totalLenSpot += len;
          totalLenSpotByCoat += (len * coatCount);
        }
      }

      const isFullSectionPaint = isFullWroughtSectionPaintMode(paintingMode);
      if(!isFullSectionPaint) return;

      const styleHasFinials = /finials?/i.test(String(s.style || ''));
      if(!styleHasFinials) return;

      let panelCount = 0;
      if(len > 0){
        panelCount = Math.max(1, Math.ceil(len / 8));
      }else{
        const panelList = Array.isArray(s.panels) ? s.panels : [];
        panelCount = panelList.reduce((sum, panel)=> sum + (parseInt(panel?.qty || 0, 10) || 0), 0);
      }
      if(panelCount <= 0) return;

      const puppyHasFinials = /puppy.*finials?/i.test(String(s.puppy || ''));
      finialSprayCanUnits += panelCount * 0.5;
      if(puppyHasFinials){
        finialSprayCanUnits += panelCount * 0.5;
      }
    });
    paintLenTotal = totalLenPaint;
    paintGallons  = Math.ceil(totalLenPaintByCoat / 100);
    if (paintGallons > 0) paintCans += Math.ceil(paintGallons * 0.5);
    primerGallons = Math.ceil(totalLenPrimePaint / 100);
    if (primerGallons > 0) primerCans += Math.ceil(primerGallons * 0.5);
    if (totalLenSpot > 0) {
      const unitsSpot = Math.ceil(totalLenSpotByCoat / 100);
      paintCans += Math.max(1, Math.ceil(unitsSpot * 0.5));
    }
    if(finialSprayCanUnits > 0){
      paintCans += Math.ceil(finialSprayCanUnits);
    }
    if (paintGallons > 0) addMat(materials, 'gallons of gloss black paint', paintGallons);
    if (paintCans > 0)    addMat(materials, 'spray cans (gloss black)', paintCans);
    if (primerGallons > 0) addMat(materials, 'gallons of red oxide primer', primerGallons);
    if (primerCans > 0)    addMat(materials, 'spray cans (red oxide primer)', primerCans);

    // Finials (descriptive labels) for MATERIALS list
    state.sections.forEach(s=>{
      const arr = Array.isArray(s.finials) ? s.finials : [];
      arr.forEach(f=>{
        const q = parseInt(f?.qty||0,10) || 0; if(!q) return;
        const picketLabel = normalizeSize(f?.picketSize);
        addMat(materials, `finials - ${f.material} - ${f.style} (${picketLabel})`, q);
      });
    });
    // Caps (descriptive labels) for MATERIALS list
    state.sections.forEach(s=>{
      const arr = Array.isArray(s.caps) ? s.caps : [];
      arr.forEach(c=>{
        const q = parseInt(c?.qty||0,10) || 0; if(!q) return;
        addMat(materials, `caps - ${c.material} - ${c.style} (${c.postSize})`, q);
      });
    });

    // ===== Panel purchase vs build materials & direct costs =====
    let costPrefabPanels = 0;
    let costTmiCustomPanels = 0;
    state.sections.forEach(s=>{
      const lst = s._panelCalc || [];
      lst.forEach(p=>{
        const panelFabricationMode = normalizeWroughtPanelFabrication(p.panelFabrication);
        const orderedFromTmi = !p.eligible && isOrderedTmiPanelFabrication(panelFabricationMode);
        if(p.eligible || orderedFromTmi){
          let unit = 0;
          if(p.eligible){
            const price = PANEL_PRICE[pkey(p.feet, p.picketSize, p.style)];
            unit = (typeof price === 'number') ? price : 0;
            costPrefabPanels += p.qty * unit;
          } else {
            unit = WROUGHT_TMI_CUSTOM_PANEL_COST;
            costTmiCustomPanels += p.qty * unit;
          }
          const panelDescParts = [];
          if(p.height) panelDescParts.push(p.height);
          if(p.style) panelDescParts.push(p.style);
          const styleText = p.style || '';
          const hasFinialsInStyle = /Finials?/i.test(styleText);
          const isFlatTopStyle = /Flat Top/i.test(styleText);
          if(p.finialStyle && !hasFinialsInStyle && !isFlatTopStyle){
            panelDescParts.push(`(${p.finialStyle})`);
          }
          const picketLabel = p.picketSize ? `${p.picketSize} pickets` : '';
          const panelDesc = panelDescParts.length ? panelDescParts.join(' ') : 'wrought iron';
          const labelParts = [orderedFromTmi ? `TMI custom powder-coated fence panel ${panelDesc}` : `prefab fence panel ${panelDesc}`];
          if(picketLabel) labelParts.push(`(${picketLabel})`);
          addMat(materials, labelParts.join(' '), p.qty);
          // No extra raw steel for prefab-style install panels.
        } else {
          // Build on site: rails (2 per panel) and pickets per width
          const stickLengthFt = wroughtCustomStickLengthFt(p.stickLengthFt);
          const stickLengthIn = stickLengthFt * 12;
          const railPieces = 2 * p.qty;
          const railPiecesPerStick = Math.max(1, Math.floor(stickLengthIn / Math.max(1, p.widthIn)));
          const railSticks = Math.ceil(railPieces / railPiecesPerStick);
          addRailSticks(p.railSize, railSticks, stickLengthFt);

          const picketsPerPanel = picketCountForWidth(p.widthIn, p.picketSize);
          // assume picket height = selected panel height in inches (fallback 54)
          let ph = p.feet>0 ? p.feet*12 : 54;
          const perStick = Math.max(1, Math.floor(stickLengthIn / ph));
          const totalPickets = picketsPerPanel * p.qty;
          const picketSticks = Math.ceil(totalPickets / perStick);
          addPicketSticks(p.picketSize, picketSticks, stickLengthFt);
        }
      });
    });

    // ===== Costing =====
    let unpriced = false;
    const matBreak = [];
    let costMaterials = 0;

    if(totals.retainingWallCost > 0){
      costMaterials += totals.retainingWallCost;
      matBreak.push('  - Retaining wall installation (In-House 4 only): $'+money(totals.retainingWallCost)+' ($35/sq ft, $1,500 minimum, includes wall materials & labor; post materials separate)');
    }

    // PRICE_MISC line-items
    Object.entries(materials).forEach(([label, qty])=>{
      if(label === 'Skid steer rental'){
        const rentalDays = Math.max(0, Math.ceil(Number(qty) || 0));
        if(rentalDays <= 0) return;
        const dailyRate = Math.max(0, Number(PRICE_MISC['Skid steer rental'] || 500) || 500);
        const fullWeeks = Math.floor(rentalDays / 7);
        const remainingDays = rentalDays % 7;
        const remainingAsWeek = remainingDays >= 3;
        const totalWeeks = fullWeeks + (remainingAsWeek ? 1 : 0);
        const totalDailyDays = remainingAsWeek ? 0 : remainingDays;
        const c = (totalWeeks * SKID_STEER_WEEKLY_RATE) + (totalDailyDays * dailyRate);
        costMaterials += c;
        const breakdownParts = [];
        if(totalWeeks > 0){
          breakdownParts.push(`${totalWeeks} week${totalWeeks === 1 ? '' : 's'} @ $${money(SKID_STEER_WEEKLY_RATE)}`);
        }
        if(totalDailyDays > 0){
          breakdownParts.push(`${totalDailyDays} day${totalDailyDays === 1 ? '' : 's'} @ $${money(dailyRate)}`);
        }
        const breakdown = breakdownParts.length ? ` (${breakdownParts.join(' + ')})` : '';
        matBreak.push(`  - Skid steer rental: ${rentalDays} day${rentalDays === 1 ? '' : 's'} = $${money(c)}${breakdown}`);
        return;
      }
      if(Object.prototype.hasOwnProperty.call(PRICE_MISC, label)){
        const unit = PRICE_MISC[label] || 0;
        if(unit <= 0 && PRICE_MISC_UNPRICED_LABELS.has(label)){
          unpriced = true;
        }
        const c = qty * unit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
        return;
      }
      const woodPicketUnit = woodPicketUnitPriceFromLabel(label);
      if(woodPicketUnit !== null){
        const c = qty * woodPicketUnit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(woodPicketUnit)} = $${money(c)}`);
        return;
      }
      const woodRailUnit = woodRailUnitPriceFromLabel(label);
      if(woodRailUnit !== null){
        const unit = woodRailUnit || 0;
        if(unit <= 0) unpriced = true;
        const c = qty * unit;
        costMaterials += c;
        matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
        return;
      }
      const woodBoardCost = woodBoardCostFromLabel(label, qty);
      if(woodBoardCost !== null){
        const pieces = woodBoardCost.pieces || 0;
        const pieceCost = woodBoardCost.pieceCost || 0;
        const c = woodBoardCost.totalCost || 0;
        if(woodBoardCost.unpriced) unpriced = true;
        costMaterials += c;
        if(pieces > 0){
          matBreak.push(`  - ${label}: ${pieces} piece(s) x $${money(pieceCost)} = $${money(c)}`);
        } else {
          matBreak.push(`  - ${label}: ${qty} x $${money(0)} = $${money(0)}`);
        }
        return;
      }
      if(/^wood rail/i.test(label)){
        unpriced = true;
        matBreak.push(`  - ${label}: ${qty} x $${money(0)} = $${money(0)}`);
      }
    });

    if(costPrefabPanels > 0){
      costMaterials += costPrefabPanels;
      matBreak.push('  - Prefab fence panels: $'+money(costPrefabPanels));
    }
    if(costTmiCustomPanels > 0){
      const tmiQty = Math.max(0, parseInt(totals.panelsInstallCustomTmi || 0, 10) || 0);
      costMaterials += costTmiCustomPanels;
      if(tmiQty > 0){
        matBreak.push(`  - TMI custom powder-coated panels: ${tmiQty} x $${money(WROUGHT_TMI_CUSTOM_PANEL_COST)} = $${money(costTmiCustomPanels)}`);
      } else {
        matBreak.push('  - TMI custom powder-coated panels: $'+money(costTmiCustomPanels));
      }
    }

    if(paintGallons>0){
      const c = paintGallons * PRICE.paintGallon;
      costMaterials += c;
      matBreak.push('  - Paint (gallons): '+paintGallons+' x $'+money(PRICE.paintGallon)+' = $'+money(c));
    }
    if(paintCans>0){
      const c = paintCans * PRICE.paintCan;
      costMaterials += c;
      matBreak.push('  - Paint (spray cans): '+paintCans+' x $'+money(PRICE.paintCan)+' = $'+money(c));
    }
    if(primerGallons>0){
      const c = primerGallons * PRICE.primerGallon;
      costMaterials += c;
      matBreak.push('  - Red oxide primer (gallons): '+primerGallons+' x $'+money(PRICE.primerGallon)+' = $'+money(c));
    }
    if(primerCans>0){
      const c = primerCans * PRICE.primerCan;
      costMaterials += c;
      matBreak.push('  - Red oxide primer (spray cans): '+primerCans+' x $'+money(PRICE.primerCan)+' = $'+money(c));
    }

    const concreteBagsMat = (materials['Maximizer bags of concrete']||0);
    if(concreteBagsMat>0){
      const c = concreteBagsMat * PRICE.concrete;
      costMaterials += c;
      matBreak.push('  - Concrete (Maximizer): '+concreteBagsMat+' x $'+money(PRICE.concrete)+' = $'+money(c));
    }

    const posts2x2CountsCost = {};
    Object.keys(materials).forEach(k=>{
      const m = k.match(/^2x2x(\d+)\s+posts$/);
      if(m){ posts2x2CountsCost[m[1]] = (posts2x2CountsCost[m[1]]||0) + materials[k]; }
    });
    Object.entries(posts2x2CountsCost).forEach(([lenStr, qty])=>{
      const len = parseInt(lenStr,10) || 0;
      let unit = PRICE.post2x2[len];
      if(unit==null){
        const perFt = PRICE_FT['2x2\"']||0;
        unit = perFt * len;
      }
      const c = qty * (unit||0);
      if((unit||0)===0) unpriced = true;
      costMaterials += c;
      matBreak.push('  - 2x2x'+len+' posts: '+qty+' x $'+money(unit)+' = $'+money(c));
    });

    const rawSteelSizeByKind = {
      raw1p5: '1 1/2"',
      raw2x2: '2x2"',
      raw3x3: '3x3"',
      raw4x4: '4x4'
    };
    const addRawSteelCostBreakdown = (kind, perFtKey, displayLabel)=>{
      const byLength = steelStickTotals[kind] || {};
      Object.keys(byLength).sort((a,b)=>parseInt(a,10)-parseInt(b,10)).forEach(lenRaw=>{
        const qty = parseInt(byLength[lenRaw],10) || 0;
        if(qty <= 0) return;
        const stickLengthFt = wroughtCustomStickLengthFt(lenRaw);
        const perFt = PRICE_FT[perFtKey] || 0;
        if(perFt === 0) unpriced = true;
        const c = qty * stickLengthFt * perFt;
        costMaterials += c;
        matBreak.push(`  - ${displayLabel} raw steel sticks: ${qty} x ${stickLengthFt}ft x $${money(perFt)}/ft = $${money(c)}`);
      });
    };
    addRawSteelCostBreakdown('raw1p5', '1 1/2\"', '1.5x1.5');
    addRawSteelCostBreakdown('raw2x2', '2x2\"', '2x2');
    addRawSteelCostBreakdown('raw3x3', '3x3\"', '3x3');
    addRawSteelCostBreakdown('raw4x4', '4x4', '4x4');

    Object.keys(picketStickTotals).sort().forEach(key=>{
      const [lenRaw, size] = String(key).split('|');
      const normalizedSize = normalizeSize(size);
      const stickLengthFt = wroughtCustomStickLengthFt(lenRaw);
      const qty = picketStickTotals[key];
      const perFt = PRICE_FT[normalizedSize]||0;
      const c = qty * stickLengthFt * perFt;
      if(perFt===0) unpriced = true;
      costMaterials += c;
      matBreak.push(`  - ${stickLengthFt}ft picket sticks ${normalizedSize}: ${qty} x ${stickLengthFt}ft x $${money(perFt)}/ft = $${money(c)}`);
    });

    Object.keys(railStickTotals).sort().forEach(key=>{
      const [lenRaw, size] = String(key).split('|');
      const normalizedSize = normalizeSize(size);
      const stickLengthFt = wroughtCustomStickLengthFt(lenRaw);
      const qty = railStickTotals[key];
      const perFt = PRICE_FT[normalizedSize]||0;
      const c = qty * stickLengthFt * perFt;
      if(perFt===0) unpriced = true;
      costMaterials += c;
      matBreak.push(`  - ${stickLengthFt}ft rail sticks ${normalizedSize}: ${qty} x ${stickLengthFt}ft x $${money(perFt)}/ft = $${money(c)}`);
    });

    // NEW: Finials cost (flat $1.25 each via total of descriptive labels)
    const finialsPricedUnit = PRICE_MISC['replacement finial'] || 0;
    const finialsTotalForCost = Object.keys(materials).reduce((acc,k)=>{
      if(k.startsWith('finials - ')) return acc + (materials[k]||0);
      return acc;
    }, 0);
    if(finialsTotalForCost>0){
      const c = finialsTotalForCost * finialsPricedUnit;
      costMaterials += c;
      matBreak.push('  - Replacement finials: '+finialsTotalForCost+' x $'+money(finialsPricedUnit)+' = $'+money(c));
    }

    // NEW: Caps cost by size/style
    Object.entries(materials).forEach(([label, qty])=>{
      const m = label.match(CAP_LABEL_RE);
      if(!m) return;
      const style = m[2];
      const postSize = m[3];
      let unit = 0;
      // Normalize style to handle typos like "bal" -> "ball"
      const styleNorm = String(style||'').toLowerCase();
      const isBall = /ball/.test(styleNorm);
      if(postSize === '1 1/2" x 1 1/2"'){
        unit = isBall ? 4 : 1;
      } else if(postSize === '2x2'){
        unit = isBall ? 4 : 1.61;
      } else if(postSize === '3x3'){
        unit = isBall ? 7 : 2;
      } else if(postSize === '4x4'){
        unit = isBall ? 15 : 8;
      } else {
        unit = 0;
        unpriced = true;
      }
      const c = qty * unit;
      costMaterials += c;
      matBreak.push(`  - ${label}: ${qty} x $${money(unit)} = $${money(c)}`);
    });

    // Labor + totals
    let primePaintReturnHours = 0;
    let sprayBaseHours = 0;
    let sprayFinishHours = 0;
    const paintingHours = state.sections.reduce((acc, s)=>{
      const paintingMode = effectiveWroughtPaintingSelection(s);
      if(!isFullWroughtSectionPaintMode(paintingMode)) return acc;
      const len = parseInt(s.length||0,10) || 0;
      const method = s.paintingApplication || 'By Hand';
      const paintCoats = paintCoatCountForSection(s);
      let totalSectionHours = 0;
      if(method === 'Spray'){
        let panelCount = 0;
        if(Array.isArray(s.panels)){
          panelCount = s.panels.reduce((sum, panel)=>{
            const qty = parseInt(panel?.qty||0, 10) || 0;
            return sum + qty;
          }, 0);
        }
        if(panelCount <= 0 && len > 0){
          panelCount = Math.max(1, Math.ceil(len / 8));
        }
        if(panelCount > 0){
          totalSectionHours = panelCount / 4;
        }
      }else{
        if(!len) return acc;
        const railsPenalty = railPacePenalty(s.railsCount || (s.rails||[]).length || 0);
        const denom = styleFactor(s.style) - puppyAdj(s.puppy) - railsPenalty;
        const baseHours = (len/8) / Math.max(0.5, denom);
        const hardscapeHours = (parseInt(s.hardscape||0,10)||0) / 20;
        const trimHours = (parseInt(s.trim||0,10)||0) / 50;
        totalSectionHours = baseHours + hardscapeHours + trimHours;
      }
      if(totalSectionHours <= 0) return acc;
      if(paintingMode === 'Paint Section' && s.paintingPrepExtra){
        totalSectionHours *= 1.25;
      }
      if(method === 'Spray'){
        if(paintingMode === 'Prime and Paint'){
          sprayBaseHours += totalSectionHours;
        }else{
          sprayBaseHours += totalSectionHours * paintCoats;
        }
      }
      if (paintingMode === 'Prime and Paint'){
        primePaintReturnHours += totalSectionHours * paintCoats;
        if(method === 'Spray'){
          sprayFinishHours += totalSectionHours * paintCoats;
        }
        return acc + totalSectionHours;
      }
      return acc + (totalSectionHours * paintCoats);
    }, 0);
    manHours += paintingHours + primePaintReturnHours;
    helperHours += paintingHours + primePaintReturnHours;
    welderHours += sprayBaseHours + sprayFinishHours;

    let setupTeardownHoursPerPerson = 0;
    if(JOB_SETUP_TEARDOWN_HOURS > 0){
      const setupTeardownManHours = JOB_SETUP_TEARDOWN_HOURS * ONSITE_CREW_SIZE;
      setupTeardownHoursPerPerson = JOB_SETUP_TEARDOWN_HOURS;
      manHours += setupTeardownManHours;
      helperHours += setupTeardownManHours;
    }

    const hasPostReplacements = (()=>{
      const replaceCounts = totals.postsReplace || zeroPostCounts();
      const hasMetalPosts = (replaceCounts.posts1p5 || 0) > 0
        || (replaceCounts.posts2x2 || 0) > 0
        || (replaceCounts.posts3x3 || 0) > 0
        || (replaceCounts.posts4x4 || 0) > 0;
      const hasWoodPosts = (totals.woodPostReplace6 || 0) > 0 || (totals.woodPostReplace8 || 0) > 0;
      return hasMetalPosts || hasWoodPosts;
    })();
    if(hasPostReplacements){
      const minCrewHours = 3;
      const minManHours = minCrewHours * ONSITE_CREW_SIZE;
      if(manHours < minManHours){
        const addedHours = minManHours - manHours;
        manHours += addedHours;
        helperHours += addedHours;
      }
    }

    const jobAddress = mapAddressInput ? (mapAddressInput.value || '').trim() : lastEstimateAddress;
    const travelDayInfo = await computeTravelDayInfo(jobAddress);
    const travelHoursPerDay = travelDayInfo.included && isFinite(travelDayInfo.hoursPerDay)
      ? travelDayInfo.hoursPerDay
      : 0;
    const MAX_CREW_DAY_HOURS = CREW_SETTINGS.maxDayHours || 13;
    const onsiteHoursPerPerson = MAX_CREW_DAY_HOURS - travelHoursPerDay;
    // Guard against zero/negative onsite capacity if travel time exceeds the day cap.
    const HOURS_PER_PERSON = Math.max(0.25, onsiteHoursPerPerson);
    const primePaintScheduled = totalLenPrimePaint > 0;
    const hasInstallOrReplace = (totals.installSections > 0) || (totals.replaceSections > 0);
    const requiresTwoPersonCrew = hasInstallOrReplace || (totals.postsRealignCutWeld > 0) || woodRequiresTwoPerson || stainHours > 0 || woodInstallPlan.sections > 0;
    const minCrewBase = requiresTwoPersonCrew ? 2 : 1;
    const MAX_CREW_PER_DAY = Math.max(1, Math.min(CREW_SETTINGS.maxCrew, ONSITE_CREW_SIZE));
    const MIN_CREW_PER_DAY = Math.min(MAX_CREW_PER_DAY, Math.max(minCrewBase, CREW_SETTINGS.minCrew));
    const MAX_WELDERS = Math.max(0, Math.min(CREW_SETTINGS.maxWelders || MAX_CREW_PER_DAY, MAX_CREW_PER_DAY));
    // Wrought-iron repair work is capped at 2 concurrent welders.
    const MAX_BASE_WELDERS = hasWroughtRepair ? Math.min(MAX_WELDERS, 2) : MAX_WELDERS;
    const woodInstallDays = [];
    const woodInstallCombinedCrewHours =
      woodInstallPlan.postCrewHours +
      woodInstallPlan.removalCrewHours +
      woodInstallPlan.buildCrewHours;
    const woodInstallCanRunSameDayWithPosts = (
      woodInstallPlan.sections > 0 &&
      woodInstallPlan.buildCrewHours > 0 &&
      woodInstallPlan.totalPosts > 0 &&
      woodInstallPlan.totalPosts <= 4
    );
    const woodInstallCanRunSameDayWithExistingPosts = (
      woodInstallPlan.sections > 0 &&
      woodInstallPlan.buildCrewHours > 0 &&
      woodInstallPlan.totalPosts <= 0 &&
      woodInstallPlan.removalCrewHours > 0 &&
      woodInstallCombinedCrewHours <= (HOURS_PER_PERSON + 0.01)
    );
    const woodInstallCanRunSameDay = woodInstallCanRunSameDayWithPosts || woodInstallCanRunSameDayWithExistingPosts;
    const woodInstallNeedsReturnDay = (
      woodInstallPlan.buildCrewHours > 0 &&
      !woodInstallCanRunSameDay &&
      (woodInstallPlan.postCrewHours + woodInstallPlan.removalCrewHours) > 0.01
    );
    const appendWoodPhaseDays = (crewHours, kind)=>{
      let remainingCrewHours = Math.max(0, Number(crewHours || 0) || 0);
      while(remainingCrewHours > 0.01){
        const usedCrewHours = Math.min(remainingCrewHours, HOURS_PER_PERSON);
        woodInstallDays.push({
          crew: ONSITE_CREW_SIZE,
          welderCount: 0,
          stainerCount: 0,
          helperCount: ONSITE_CREW_SIZE,
          hours: ONSITE_CREW_SIZE * usedCrewHours,
          kind
        });
        remainingCrewHours = Math.max(0, remainingCrewHours - usedCrewHours);
      }
    };
    if(woodInstallCanRunSameDay){
      appendWoodPhaseDays(woodInstallCombinedCrewHours, 'wood-posts');
    } else {
      appendWoodPhaseDays(woodInstallPlan.postCrewHours + woodInstallPlan.removalCrewHours, 'wood-posts');
      appendWoodPhaseDays(woodInstallPlan.buildCrewHours, 'wood-build');
    }
    woodInstallPlan.removalDays = woodInstallDays.filter(day => day.kind === 'wood-posts').length;
    woodInstallPlan.postDays = woodInstallPlan.removalDays;
    const explicitBuildDays = woodInstallDays.filter(day => day.kind === 'wood-build').length;
    woodInstallPlan.buildDays = explicitBuildDays > 0
      ? explicitBuildDays
      : (woodInstallCanRunSameDay && woodInstallPlan.buildCrewHours > 0 ? 1 : 0);
    if(woodInstallDays.length){
      const woodInstallManHours = woodInstallDays.reduce((acc, day)=> acc + (Number(day.hours || 0) || 0), 0);
      manHours += woodInstallManHours;
    }
    const stainReturnHours = hasWoodWash ? stainHours : 0;
    const day2Hours = primePaintReturnHours + stainReturnHours;
    const helperHoursDay2 = day2Hours;
    const helperHoursDay1 = Math.max(0, helperHours - helperHoursDay2 - washHours);
    const washHoursDay1 = Math.max(0, washHours);
    const stainHoursDay1 = Math.max(0, hasWoodWash ? 0 : stainHours);
    const finishWelderHours = sprayFinishHours;
    const baseWelderHours = Math.max(0, welderHours - finishWelderHours);
    const baseStainHours = Math.min(stainHoursDay1, helperHoursDay1);
    const baseHelperHours = Math.max(0, helperHoursDay1 - baseStainHours);

    const washDays = [];
    let remainingWashHours = washHoursDay1;
    const MAX_WASHERS = Math.min(2, MAX_CREW_PER_DAY);
    while(remainingWashHours > 0.01){
      let washerCount = Math.ceil(remainingWashHours / HOURS_PER_PERSON);
      washerCount = Math.max(1, Math.min(washerCount, MAX_WASHERS));
      let crewCount = washerCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, washerCount));
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      const usedWashHours = Math.min(remainingWashHours, washerCount * HOURS_PER_PERSON);
      washDays.push({ crew: crewCount, welderCount: 0, stainerCount: 0, helperCount: crewCount, hours: usedWashHours });
      remainingWashHours = Math.max(0, remainingWashHours - usedWashHours);
      if(washerCount === 0 && crewCount === 0){
        break;
      }
    }

    const baseDays = [];
    let remainingWelderHours = baseWelderHours;
    let remainingHelperHours = baseHelperHours;
    let remainingStainHours = baseStainHours;
    while(remainingWelderHours > 0.01 || remainingHelperHours > 0.01 || remainingStainHours > 0.01){
      let welderCount = 0;
      if(remainingWelderHours > 0.01){
        const welderNeeded = Math.ceil(remainingWelderHours / HOURS_PER_PERSON);
        welderCount = Math.max(1, Math.min(welderNeeded, MAX_BASE_WELDERS, MAX_CREW_PER_DAY));
      }
      let stainerCount = 0;
      if(remainingStainHours > 0.01){
        const stainerNeeded = Math.ceil(remainingStainHours / HOURS_PER_PERSON);
        const maxStainers = Math.floor(Math.max(0, MAX_CREW_PER_DAY - welderCount) / 2);
        stainerCount = Math.min(stainerNeeded, maxStainers);
      }
      const welderCapacity = welderCount * HOURS_PER_PERSON;
      const helperHoursWelderCanCover = Math.max(0, welderCapacity - remainingWelderHours);
      let helperCount = 0;
      const helperHoursAfterWelder = Math.max(0, remainingHelperHours - helperHoursWelderCanCover);
      if(helperHoursAfterWelder > 0.01){
        const helperNeeded = Math.ceil(helperHoursAfterWelder / HOURS_PER_PERSON);
        helperCount = Math.min(helperNeeded, Math.max(0, MAX_CREW_PER_DAY - welderCount - stainerCount));
      }
      helperCount = Math.max(helperCount, stainerCount);
      helperCount = Math.min(helperCount, Math.max(0, MAX_CREW_PER_DAY - welderCount - stainerCount));
      let crewCount = welderCount + stainerCount + helperCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, welderCount + stainerCount));
      }
      if(crewCount <= 0){
        crewCount = Math.min(MAX_CREW_PER_DAY, MIN_CREW_PER_DAY);
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      helperCount = Math.min(helperCount, Math.max(0, crewCount - welderCount - stainerCount));
      if(welderCount + stainerCount + helperCount < crewCount){
        helperCount = crewCount - welderCount - stainerCount;
      }
      const usedWelderHours = Math.min(remainingWelderHours, welderCount * HOURS_PER_PERSON);
      const usedStainerHours = Math.min(remainingStainHours, stainerCount * HOURS_PER_PERSON);
      const usedHelperHours = Math.min(
        remainingHelperHours,
        helperHoursWelderCanCover + Math.max(0, helperCount - stainerCount) * HOURS_PER_PERSON
      );
      const usedHours = usedWelderHours + usedStainerHours + usedHelperHours;
      baseDays.push({ crew: crewCount, welderCount, stainerCount, helperCount, hours: usedHours });
      remainingWelderHours = Math.max(0, remainingWelderHours - welderCount * HOURS_PER_PERSON);
      const helperHoursHandledByWeldersFinal = Math.min(remainingHelperHours, helperHoursWelderCanCover);
      remainingStainHours = Math.max(0, remainingStainHours - stainerCount * HOURS_PER_PERSON);
      remainingHelperHours = Math.max(
        0,
        remainingHelperHours - helperHoursHandledByWeldersFinal - Math.max(0, (helperCount - stainerCount)) * HOURS_PER_PERSON
      );
      if(welderCount === 0 && stainerCount === 0 && helperCount === 0){
        break;
      }
    }

    const finishDays = [];
    let remainingFinishWelderHours = finishWelderHours;
    let remainingFinishHelperHours = helperHoursDay2;
    while(remainingFinishWelderHours > 0.01 || remainingFinishHelperHours > 0.01){
      let welderCount = 0;
      if(remainingFinishWelderHours > 0.01){
        const welderNeeded = Math.ceil(remainingFinishWelderHours / HOURS_PER_PERSON);
        welderCount = Math.max(1, Math.min(welderNeeded, MAX_WELDERS, MAX_CREW_PER_DAY));
      }
      const welderCapacity = welderCount * HOURS_PER_PERSON;
      const helperHoursWelderCanCover = Math.max(0, welderCapacity - remainingFinishWelderHours);
      let helperCount = 0;
      const helperHoursAfterWelder = Math.max(0, remainingFinishHelperHours - helperHoursWelderCanCover);
      if(helperHoursAfterWelder > 0.01){
        const helperNeeded = Math.ceil(helperHoursAfterWelder / HOURS_PER_PERSON);
        helperCount = Math.min(helperNeeded, Math.max(0, MAX_CREW_PER_DAY - welderCount));
      }
      let crewCount = welderCount + helperCount;
      if(crewCount < MIN_CREW_PER_DAY){
        crewCount = Math.min(MAX_CREW_PER_DAY, Math.max(MIN_CREW_PER_DAY, welderCount));
      }
      if(crewCount <= 0){
        crewCount = Math.min(MAX_CREW_PER_DAY, MIN_CREW_PER_DAY);
      }
      if(crewCount > MAX_CREW_PER_DAY){
        crewCount = MAX_CREW_PER_DAY;
      }
      helperCount = Math.min(helperCount, Math.max(0, crewCount - welderCount));
      if(welderCount + helperCount < crewCount){
        helperCount = crewCount - welderCount;
      }
      const usedFinishWelderHours = Math.min(remainingFinishWelderHours, welderCount * HOURS_PER_PERSON);
      const usedFinishHelperHours = Math.min(
        remainingFinishHelperHours,
        helperHoursWelderCanCover + helperCount * HOURS_PER_PERSON
      );
      finishDays.push({
        crew: crewCount,
        welderCount,
        stainerCount: 0,
        helperCount,
        hours: usedFinishWelderHours + usedFinishHelperHours
      });
      remainingFinishWelderHours = Math.max(0, remainingFinishWelderHours - welderCount * HOURS_PER_PERSON);
      const helperHoursHandledByWelders = Math.min(remainingFinishHelperHours, helperHoursWelderCanCover);
      remainingFinishHelperHours = Math.max(0, remainingFinishHelperHours - helperHoursHandledByWelders - helperCount * HOURS_PER_PERSON);
      if(welderCount === 0 && helperCount === 0){
        break;
      }
    }

    if(washDays.length && baseDays.length){
      const firstWash = washDays[0];
      const firstBase = baseDays[0];
      const washHoursToCombine = firstWash.hours || 0;
      const baseHours = firstBase.hours || 0;
      const baseCapacity = (firstBase.crew || 0) * HOURS_PER_PERSON;
      if(washHoursToCombine > 0
        && firstWash.crew <= firstBase.crew
        && (baseHours + washHoursToCombine) <= baseCapacity){
        baseDays[0] = { ...firstBase, hasWash: true, hours: baseHours + washHoursToCombine };
        washDays.shift();
      }
    }
    if(woodInstallDays.length && baseDays.length){
      const woodBuildDayIndex = woodInstallDays.map(day=> day.kind).lastIndexOf('wood-build');
      const targetDayIndex = woodBuildDayIndex >= 0 ? woodBuildDayIndex : (woodInstallDays.length - 1);
      while(baseDays.length > 0){
        const firstBase = baseDays[0];
        const targetDay = woodInstallDays[targetDayIndex];
        if(!targetDay) break;
        if((firstBase.welderCount || 0) > 0 || (firstBase.stainerCount || 0) > 0){
          break;
        }
        const targetCapacity = (targetDay.crew || 0) * HOURS_PER_PERSON;
        if(((targetDay.hours || 0) + (firstBase.hours || 0)) > targetCapacity){
          break;
        }
        woodInstallDays[targetDayIndex] = {
          ...targetDay,
          hasBase: true,
          hours: (targetDay.hours || 0) + (firstBase.hours || 0)
        };
        baseDays.shift();
      }
    }

    const crewSchedule = [];
    woodInstallDays.forEach(day => crewSchedule.push({ ...day }));
    washDays.forEach(day => crewSchedule.push({ ...day, kind: 'wash' }));
    baseDays.forEach(day => crewSchedule.push({ ...day, kind: primePaintScheduled ? 'prime' : 'base' }));
    finishDays.forEach(day => crewSchedule.push({ ...day, kind: 'finish' }));

    const crewLabelWithMix = (count) => {
      const crewCount = parseInt(count, 10) || 0;
      if(crewCount <= 0) return '';
      return `${crewCount}-man crew`;
    };

    const woodInstallRailLengths = woodInstallRailLengthsForSections(state.sections);
    const woodInstallRailLabel = woodInstallRailLabelFromLengths(woodInstallRailLengths);
    const woodInstallRailsAndPicketsLabel = `${woodInstallRailLabel} & pickets`;
    const returnSuffix = primePaintScheduled && hasWoodWash
      ? ' (return for finish coat & staining)'
      : (primePaintScheduled ? ' (return for finish coat)' : (hasWoodWash ? ' (return for staining)' : ''));
    const scheduleEntries = crewSchedule.map((day, idx) => {
      const crewLabel = crewLabelWithMix(day.crew);
      let suffix = '';
      if(day.kind === 'wood-posts'){
        const sameDayWoodBuild = woodInstallCanRunSameDay;
        const hasPostsToSet = woodInstallPlan.totalPosts > 0;
        const hasRemovalScope = woodInstallPlan.removalLf > 0;
        const returnWoodDayNote = woodInstallNeedsReturnDay
          ? `; return next day to install ${woodInstallRailsAndPicketsLabel}`
          : '';
        if(sameDayWoodBuild){
          if(hasRemovalScope && hasPostsToSet){
            suffix = ` (remove existing wood fence, set wood posts, allow concrete cure time, then install ${woodInstallRailsAndPicketsLabel})`;
          } else if(hasRemovalScope){
            suffix = ` (remove existing wood fence, then install ${woodInstallRailsAndPicketsLabel})`;
          } else if(hasPostsToSet){
            suffix = ` (set wood posts, allow concrete cure time, then install ${woodInstallRailsAndPicketsLabel})`;
          } else {
            suffix = ` (install ${woodInstallRailsAndPicketsLabel})`;
          }
        } else if(hasPostsToSet){
          suffix = hasRemovalScope
            ? ` (remove existing wood fence & set wood posts${returnWoodDayNote})`
            : ` (set wood posts${returnWoodDayNote})`;
        } else if(hasRemovalScope){
          suffix = ` (remove existing wood fence${returnWoodDayNote})`;
        } else if(returnWoodDayNote){
          suffix = ` (prep wood fence${returnWoodDayNote})`;
        }
      } else if(day.kind === 'wood-build'){
        const buildPrefix = woodInstallPlan.totalPosts > 4
          ? ` (return day: install ${woodInstallRailsAndPicketsLabel}`
          : ` (install ${woodInstallRailsAndPicketsLabel}`;
        suffix = day.hasBase
          ? `${buildPrefix} + remaining labor tasks)`
          : `${buildPrefix})`;
      } else if(day.kind === 'wash'){
        suffix = ' (pressure wash)';
      } else if(day.kind === 'finish'){
        suffix = returnSuffix;
      } else if(day.hasWash){
        suffix = primePaintScheduled
          ? ' (prime/repairs, then pressure wash)'
          : ' (repairs, then pressure wash)';
      } else if(primePaintScheduled){
        suffix = ' (prime/repairs)';
      }
      return {
        number: idx + 1,
        crewLabel,
        suffix,
      };
    });

    let estimatedOnsiteHours = ONSITE_CREW_SIZE > 0 ? manHours / ONSITE_CREW_SIZE : 0;
    const formatHours = (hours) => {
      if (!isFinite(hours) || hours <= 0) return '';
      const rounded = Math.round(hours * 10) / 10;
      const isWhole = Math.abs(rounded - Math.round(rounded)) < 0.05;
      return isWhole ? `${Math.round(rounded)} hours` : `${rounded.toFixed(1)} hours`;
    };
    const onsiteDayCount = Math.max(0, crewSchedule.filter(day => (day?.crew || 0) > 0).length);
    const formatOnsiteDays = (days) => {
      const wholeDays = parseInt(days, 10) || 0;
      if(wholeDays <= 0) return '';
      return wholeDays === 1 ? '1 day' : `${wholeDays} days`;
    };
    const buildOnsiteSummaryLabel = (hoursLabel) => {
      const daysLabel = formatOnsiteDays(onsiteDayCount);
      if(hoursLabel && daysLabel) return `${hoursLabel} onsite (${daysLabel})`;
      if(hoursLabel) return `${hoursLabel} onsite`;
      if(daysLabel) return `${daysLabel} onsite`;
      return '';
    };
    let estimatedOnsiteLabel = formatHours(estimatedOnsiteHours);
    const totalLaborHoursLabel = formatHours(manHours);

    const materialSortGroup = (label)=>{
      const normalized = String(label || '').toLowerCase();
      const isPaintRelated = /\bpaint\b|\bprimer\b/.test(normalized) || /^spray cans \(/.test(normalized);
      const isGateHardware = /\bhinge\b|\blatch\b/.test(normalized);
      if(isPaintRelated) return 0;
      if(isGateHardware) return 2;
      return 1;
    };
    const materialEntries = Object.keys(materials)
      .filter(label => materials[label] > 0)
      .sort((a, b) => {
        const groupDiff = materialSortGroup(a) - materialSortGroup(b);
        if(groupDiff !== 0) return groupDiff;
        return a.localeCompare(b);
      })
      .map(label => {
        const qty = materials[label];
        const woodBoardCost = woodBoardCostFromLabel(label, qty);
        const displayQty = (woodBoardCost && woodBoardCost.pieces > 0) ? woodBoardCost.pieces : qty;
        return { label, qty, displayQty };
      });

    if (materialEntries.length) {
      lines.push('');
      lines.push('MATERIALS');
      materialEntries.forEach(({ label, displayQty }) => {
        lines.push(`- ${displayQty}x ${label}`);
      });
    }

    const sub = [];
    sub.push("CREW");
    const formatClockMinutes = (totalMinutes)=>{
      const minutesPerDay = 24 * 60;
      let normalized = Math.round(totalMinutes) % minutesPerDay;
      if(normalized < 0){
        normalized += minutesPerDay;
      }
      const hours24 = Math.floor(normalized / 60);
      const mins = normalized % 60;
      const period = hours24 >= 12 ? 'PM' : 'AM';
      let hours12 = hours24 % 12;
      if(hours12 === 0){
        hours12 = 12;
      }
      return `${hours12}:${String(mins).padStart(2, '0')} ${period}`;
    };
    const oneWayTravelMinutes = travelDayInfo.included && isFinite(travelDayInfo.hoursPerDay)
      ? Math.max(0, (travelDayInfo.hoursPerDay * 60) / 2)
      : NaN;
    if(isFinite(oneWayTravelMinutes)){
      const arrivalAtEightMinutes = 8 * 60;
      const roundedOneWayTravelMinutes = Math.max(0, Math.round(oneWayTravelMinutes / 5) * 5);
      const departAtMinutes = arrivalAtEightMinutes - roundedOneWayTravelMinutes;
      const departAtLabel = formatClockMinutes(departAtMinutes);
      const compactDepartLabel = departAtLabel
        .replace(' AM', 'am')
        .replace(' PM', 'pm');
      sub.push(`Depart at ${compactDepartLabel}`);
    }else{
      sub.push('Depart at: set manually');
    }
    const crewOnsiteLineIndex = sub.length;
    sub.push(buildOnsiteSummaryLabel(estimatedOnsiteLabel));
    sub.push('');
    sub.push('PROCESS');
    const formatTaskHours = (hours)=>{
      if(!isFinite(hours) || hours <= 0) return '';
      const totalMinutes = Math.max(1, Math.round(hours * 60));
      const hrs = Math.floor(totalMinutes / 60);
      const mins = totalMinutes % 60;
      if(hrs > 0 && mins > 0) return `${hrs}h ${mins}m`;
      if(hrs > 0) return `${hrs}h`;
      return `${mins}m`;
    };
    const plural = (count, singular, pluralForm)=> count === 1 ? singular : (pluralForm || `${singular}s`);
    const rolePeakCount = (field)=>{
      if(!Array.isArray(crewSchedule) || !crewSchedule.length) return 0;
      return crewSchedule.reduce((max, day)=> Math.max(max, parseInt(day?.[field] || 0, 10) || 0), 0);
    };
    const peakStainers = rolePeakCount('stainerCount');
    const activeCrewMembers = getActiveCrewMembers();
    const helperLaneFullCrew = Math.max(1, ONSITE_CREW_SIZE);
    const crewNames = activeCrewMembers.slice(0, helperLaneFullCrew);
    const maxWeldersConfigured = Math.max(1, Math.min(2, CREW_SETTINGS.maxWelders || 2, crewNames.length || 1));
    const configuredLeadName = String((CREW_ROSTER && CREW_ROSTER.lead) || '').trim();
    const leadName = crewNames.includes(configuredLeadName) ? configuredLeadName : (crewNames[0] || 'Crew Lead');
    const configuredWelderNames = Array.isArray(CREW_ROSTER?.welders) ? CREW_ROSTER.welders.filter(Boolean) : [];
    const welderNames = (configuredWelderNames.length ? configuredWelderNames : crewNames.slice(0, 2))
      .filter(name=> crewNames.includes(name));
    if(!welderNames.length && crewNames.length){
      welderNames.push(crewNames[0]);
    }
    const shopFabricationCrewSize = Math.max(1, Math.min(ONSITE_CREW_SIZE, crewNames.length || ONSITE_CREW_SIZE));
    const formatNameList = (names)=>{
      const list = (Array.isArray(names) ? names : []).filter(Boolean);
      if(!list.length) return 'Crew';
      if(list.length === 1) return list[0];
      if(list.length === 2) return `${list[0]} and ${list[1]}`;
      return `${list.slice(0, -1).join(', ')}, and ${list[list.length - 1]}`;
    };
    const sameNameSet = (a, b)=>{
      const setA = new Set((Array.isArray(a) ? a : []).filter(Boolean));
      const setB = new Set((Array.isArray(b) ? b : []).filter(Boolean));
      if(!setA.size || setA.size !== setB.size) return false;
      for(const name of setA){
        if(!setB.has(name)) return false;
      }
      return true;
    };
    const pickCrewNames = (count, excluded=[])=>{
      const qty = Math.max(1, parseInt(count, 10) || 1);
      const used = new Set((Array.isArray(excluded) ? excluded : []).filter(Boolean));
      const available = crewNames.filter(name=> !used.has(name));
      if(available.length >= qty){
        return available.slice(0, qty);
      }
      const all = crewNames.slice();
      const picked = available.slice();
      for(let i=0;i<all.length && picked.length < qty;i++){
        if(!picked.includes(all[i])) picked.push(all[i]);
      }
      return picked.slice(0, qty);
    };
    const assignWelderLaneNames = (laneCount)=>{
      const qty = Math.max(1, parseInt(laneCount, 10) || 1);
      const names = [];
      for(let i=0;i<qty;i++){
        names.push(welderNames[i] || `Welder ${i + 1}`);
      }
      return names;
    };
    const personAvailableAt = {};
    crewNames.forEach(name=>{
      personAvailableAt[name] = 0;
    });
    const getPersonAvailableAt = (name)=>{
      const value = Number(personAvailableAt[name]);
      return isFinite(value) && value > 0 ? value : 0;
    };
    const reservePeopleUntil = (names, until)=>{
      const endTime = Math.max(0, Number(until) || 0);
      (Array.isArray(names) ? names : []).forEach(name=>{
        if(!name) return;
        personAvailableAt[name] = Math.max(getPersonAvailableAt(name), endTime);
      });
    };
    const scheduleWorkByAvailability = ({ names, totalHours, earliestStart = 0, latestEnd = null })=>{
      const roster = Array.from(new Set((Array.isArray(names) ? names : []).filter(Boolean)));
      const allocations = {};
      roster.forEach(name=>{
        allocations[name] = 0;
      });
      let remaining = Math.max(0, Number(totalHours) || 0);
      let cursor = Math.max(0, Number(earliestStart) || 0);
      const hasBoundedEnd = latestEnd !== null && latestEnd !== undefined && isFinite(Number(latestEnd));
      const boundedEnd = hasBoundedEnd ? Number(latestEnd) : null;
      let startedAt = null;

      if(!roster.length || remaining <= 0){
        return {
          startTime: cursor,
          endTime: cursor,
          elapsed: 0,
          workDone: 0,
          remainingHours: remaining,
          participants: [],
          allocations
        };
      }

      const releases = roster.map(name=>({ name, time: getPersonAvailableAt(name) }));
      while(remaining > 0.0001){
        const active = releases
          .filter(item=> item.time <= (cursor + 1e-9))
          .map(item=> item.name);
        if(!active.length){
          const nextRelease = Math.min(...releases.filter(item=> item.time > (cursor + 1e-9)).map(item=> item.time));
          if(!isFinite(nextRelease)) break;
          cursor = Math.max(cursor, nextRelease);
          if(boundedEnd !== null && cursor >= (boundedEnd - 1e-9)){
            cursor = boundedEnd;
            break;
          }
          continue;
        }

        if(startedAt === null) startedAt = cursor;
        let nextBoundary = Math.min(...releases.filter(item=> item.time > (cursor + 1e-9)).map(item=> item.time));
        if(!isFinite(nextBoundary)) nextBoundary = Infinity;
        if(boundedEnd !== null){
          nextBoundary = Math.min(nextBoundary, boundedEnd);
        }
        if(!(nextBoundary > (cursor + 1e-9))){
          if(boundedEnd !== null && cursor >= (boundedEnd - 1e-9)){
            cursor = boundedEnd;
            break;
          }
          break;
        }

        const span = nextBoundary - cursor;
        const capacity = active.length * span;
        if(capacity >= (remaining - 1e-9)){
          const eachWork = remaining / active.length;
          active.forEach(name=>{
            allocations[name] += eachWork;
          });
          cursor += eachWork;
          remaining = 0;
          break;
        }

        active.forEach(name=>{
          allocations[name] += span;
        });
        remaining -= capacity;
        cursor = nextBoundary;
        if(boundedEnd !== null && cursor >= (boundedEnd - 1e-9)){
          cursor = boundedEnd;
          break;
        }
      }

      if(startedAt === null) startedAt = cursor;
      const participants = roster.filter(name=> (allocations[name] || 0) > (1/120));
      const workDone = participants.reduce((sum, name)=> sum + (allocations[name] || 0), 0);
      return {
        startTime: startedAt,
        endTime: cursor,
        elapsed: Math.max(0, cursor - startedAt),
        workDone,
        remainingHours: Math.max(0, remaining),
        participants,
        allocations
      };
    };
    const reserveScheduledPeople = (schedule)=>{
      if(!schedule || !Array.isArray(schedule.participants) || !schedule.participants.length) return;
      reservePeopleUntil(schedule.participants, schedule.endTime);
    };
    const contributorSplitNote = (schedule, names)=>{
      if(!schedule || !Array.isArray(names) || names.length < 2) return '';
      const worked = names
        .map(name=> ({ name, hours: Number(schedule.allocations?.[name] || 0) }))
        .filter(item=> item.hours > (1/120));
      if(worked.length < 2) return '';
      const maxHours = Math.max(...worked.map(item=> item.hours));
      const minHours = Math.min(...worked.map(item=> item.hours));
      if((maxHours - minHours) < (5/60)) return '';
      return `; split: ${worked.map(item=> `${item.name} ${formatTaskHours(item.hours)}`).join(', ')}`;
    };
    const compactPostSummary = (counts)=>{
      if(!counts) return '';
      const parts = [];
      const post2x2 = parseInt(counts.posts2x2 || 0, 10) || 0;
      const post3x3 = parseInt(counts.posts3x3 || 0, 10) || 0;
      const post1p5 = parseInt(counts.posts1p5 || 0, 10) || 0;
      const post4x4 = parseInt(counts.posts4x4 || 0, 10) || 0;
      if(post2x2 > 0) parts.push(`${post2x2}x 2x2`);
      if(post3x3 > 0) parts.push(`${post3x3}x 3x3`);
      if(post1p5 > 0) parts.push(`${post1p5}x 1 1/2" x 1 1/2"`);
      if(post4x4 > 0) parts.push(`${post4x4}x 4x4`);
      return parts.join(', ');
    };
    const allocateTasksByLane = (groups, lanes)=>{
      const laneCount = Math.max(1, lanes || 1);
      const buckets = Array.from({ length: laneCount }, ()=>({ hours: 0, tasks: [] }));
      groups
        .filter(group=> isFinite(group?.hours) && group.hours > 0 && group?.label)
        .sort((a, b)=> b.hours - a.hours)
        .forEach(group=>{
          let laneIndex = 0;
          for(let i=1;i<buckets.length;i++){
            if(buckets[i].hours < buckets[laneIndex].hours){ laneIndex = i; }
          }
          buckets[laneIndex].hours += group.hours;
          buckets[laneIndex].tasks.push(group.label);
        });
      return buckets.filter(bucket=> bucket.tasks.length > 0);
    };
    let stageNumber = 1;
    const pushStage = (title, lines)=>{
      const cleanLines = (Array.isArray(lines) ? lines : []).filter(Boolean);
      if(!cleanLines.length) return;
      sub.push(`Stage ${stageNumber}:`);
      cleanLines.forEach(line=> sub.push(`- ${line}`));
      sub.push('');
      stageNumber += 1;
    };
    if(totals.panelsInstallCustomShop > 0 && shopFabricationLaborHours > 0){
      const shopFabricationTeam = crewNames.slice(0, shopFabricationCrewSize);
      const shopCrewLabel = shopFabricationTeam.length ? formatNameList(shopFabricationTeam) : formatNameList([leadName]);
      const shopPanelScope = describeCount(
        totals.panelsInstallCustomShop,
        'custom wrought iron panel',
        'custom wrought iron panels'
      );
      pushStage('Shop fabrication', [
        `${shopCrewLabel}: fabricate ${shopPanelScope} in the shop (${formatTaskHours(shopFabricationLaborHours)}).`
      ]);
    }
    const woodPostReplaceManHours = ((totals.woodPostReplace6 || 0) * 2) + ((totals.woodPostReplace8 || 0) * 3);
    const woodPostRealignDigManHours = (totals.woodPostRealignDig || 0) * (45/60);
    const woodPostCutWeldWelderHours = (totals.woodPostRealignCutWeld || 0) * (20/60);
    const woodPostCutWeldHelperHours = (totals.woodPostRealignCutWeld || 0) * (20/60);
    const woodPostInstallManHours = (totals.woodPostInstall || 0) * (45/60);
    const woodInstallRemovalManHours = Math.max(0, Number(woodInstallPlan.removalManHours || 0) || 0);
    const woodInstallPostManHours = Math.max(0, Number(woodInstallPlan.postManHours || 0) || 0);
    const woodInstallBuildManHours = Math.max(0, Number(woodInstallPlan.buildManHours || 0) || 0);
    const woodGateRepairManHours = (totals.woodGateRepair * 2) + (totals.woodGateStrengthen * 1) + (totals.woodGateReplace * 3);
    const stainManHours = stainHours * 2;
    const woodCoreRepairManHours = Math.max(
      0,
      woodManHours - (
        woodPostReplaceManHours +
        woodPostRealignDigManHours +
        woodPostCutWeldWelderHours +
        woodPostCutWeldHelperHours +
        woodPostInstallManHours +
        woodGateRepairManHours +
        woodAddedGateHours +
        stainManHours +
        washHours
      )
    );
    const postPanelTieInWelderHours = wroughtPostReplacements * (20/60);
    const hasByHandPaintScope = state.sections.some(section=>{
      const fenceType = (section.fenceType || '').toLowerCase();
      if(fenceType && fenceType !== 'wrought iron') return false;
      const isFullSectionPaint = isFullWroughtSectionPaintMode(effectiveWroughtPaintingSelection(section));
      if(!isFullSectionPaint) return false;
      const method = String(section.paintingApplication || 'By Hand').trim().toLowerCase();
      return method !== 'spray';
    });
    const consolidateByHandPaintProcessNotes =
      hasByHandPaintScope &&
      paintLenTotal > 0 &&
      (sprayBaseHours + sprayFinishHours) <= 0 &&
      washHours <= 0 &&
      stainHours <= 0;
    const paintPrepEligibleManHours = Math.max(0, paintingHours);
    const paintLaborTotalManHours = Math.max(0, paintingHours + primePaintReturnHours);
    const woodInstallScopeSections = state.sections.filter(section=>{
      if((section.fenceType || '').toLowerCase() !== 'wood') return false;
      const scopeType = section.scopeType || 'repair';
      if(scopeType !== 'install' && scopeType !== 'replace') return false;
      const lengthFt = Math.max(0, parseFloat(section.length || 0) || 0);
      return lengthFt > 0;
    });
    const woodInstallTotalLf = woodInstallScopeSections.reduce((sum, section)=>{
      return sum + Math.max(0, parseFloat(section.length || 0) || 0);
    }, 0);
    const woodInstallHeights = new Set();
    const woodInstallStyles = new Set();
    const woodInstallAdds = { kick: false, topCap: false, trim: false };
    woodInstallScopeSections.forEach(section=>{
      const heightLabel = normalizeLabelText(section.woodHeight || section.height || '');
      if(heightLabel) woodInstallHeights.add(heightLabel);
      const styleLabel = String(section.woodStyle || '').trim().toLowerCase();
      if(styleLabel) woodInstallStyles.add(styleLabel);
      if(section.woodAddKickBoard) woodInstallAdds.kick = true;
      if(section.woodAddTopCap) woodInstallAdds.topCap = true;
      if(section.woodAddTrim) woodInstallAdds.trim = true;
    });
    const woodInstallHeightPhrase = woodInstallHeights.size
      ? `${joinParts(Array.from(woodInstallHeights))} tall`
      : '';
    const woodInstallStylePhrase = woodInstallStyles.size
      ? joinParts(Array.from(woodInstallStyles))
      : '';
    const woodInstallDescriptor = [woodInstallHeightPhrase, woodInstallStylePhrase, 'wood fence']
      .filter(Boolean)
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim() || 'wood fence';
    const woodInstallLengthLabel = formatFtValue(woodInstallTotalLf);
    const woodInstallScopePhrase = woodInstallLengthLabel
      ? `install about ${woodInstallLengthLabel}ft of ${woodInstallDescriptor}`
      : `install ${woodInstallDescriptor}`;
    const woodInstallBuildItems = [woodInstallRailLabel, 'pickets'];
    if(woodInstallAdds.kick) woodInstallBuildItems.push('kick boards');
    if(woodInstallAdds.topCap) woodInstallBuildItems.push('top cap');
    if(woodInstallAdds.trim) woodInstallBuildItems.push('trim');
    const woodInstallBuildTaskPhrase = woodInstallLengthLabel
      ? `install ${joinParts(woodInstallBuildItems)} on about ${woodInstallLengthLabel}ft of ${woodInstallDescriptor}`
      : `install ${joinParts(woodInstallBuildItems)} on the wood fence`;
    const woodInstallReturnNextDay = woodInstallBuildManHours > 0 && woodInstallNeedsReturnDay;
    const woodInstallSameDay = woodInstallBuildManHours > 0 && woodInstallCanRunSameDay;
    const woodInstallCureWaitLabel = woodInstallPlan.cureWaitCrewHours > 0
      ? formatTaskHours(woodInstallPlan.cureWaitCrewHours)
      : '';
    const wroughtPanelInstallReturnNextDay = wroughtInstallPanelCrewHours > 0 && installPostsNeedingCrew > 0;

    const postHelperManHours =
      postReplacementCrewManHours +
      postInstallManHours +
      cureManHours +
      concreteRealignHelperManHours +
      cutWeldHelperHours +
      woodPostReplaceManHours +
      woodPostRealignDigManHours +
      woodPostCutWeldHelperHours +
      woodPostInstallManHours +
      woodInstallRemovalManHours +
      woodInstallPostManHours;
    const replacePostSummary = compactPostSummary(totals.postsReplace || zeroPostCounts());
    const installPostSummaryConcrete = compactPostSummary(totals.postsInstallConcrete || zeroPostCounts());
    const installPostSummaryAnchored = compactPostSummary(totals.postsInstallAnchored || zeroPostCounts());
    const postTaskParts = [];
    const sentenceCase = (text)=>{
      const raw = String(text || '').trim();
      if(!raw) return '';
      return raw.charAt(0).toUpperCase() + raw.slice(1);
    };
    if(replacePostSummary){
      if(wroughtPostReplacements > 0){
        postTaskParts.push(`identify ${replacePostSummary} posts to replace, cut off existing panels, replace posts, and load old posts/concrete into the truck bed`);
      }else{
        postTaskParts.push(`identify and replace ${replacePostSummary} posts`);
      }
    }
    if(woodInstallScopeSections.length > 0 && woodInstallPlan.totalPosts > 0){
      const woodDayOneSentences = [];
      woodDayOneSentences.push(`${sentenceCase(woodInstallScopePhrase)}.`);
      if(woodInstallPlan.removalLf > 0){
        woodDayOneSentences.push(`Remove and stack ${formatFtValue(woodInstallPlan.removalLf)} lf of existing wood fence for haul away.`);
      }
      woodDayOneSentences.push(`Run strings and mark ${woodInstallPlan.totalPosts} wood post ${plural(woodInstallPlan.totalPosts, 'location', 'locations')}.`);
      woodDayOneSentences.push('Dig post holes, clear out the holes, set your end posts, run a string and set your line posts.');
      if(woodInstallReturnNextDay){
        woodDayOneSentences.push(`Return another day to install ${woodInstallRailsAndPicketsLabel}.`);
      } else if(woodInstallSameDay && woodInstallCureWaitLabel){
        woodDayOneSentences.push(`Wait about ${woodInstallCureWaitLabel} for concrete to cure before installing ${woodInstallRailsAndPicketsLabel}.`);
      }
      postTaskParts.push(woodDayOneSentences.join(' '));
    } else if(woodInstallPlan.totalPosts > 0){
      postTaskParts.push(`run strings and mark ${woodInstallPlan.totalPosts} wood post ${plural(woodInstallPlan.totalPosts, 'location', 'locations')}`);
    }
    if(installPostSummaryConcrete) postTaskParts.push(`set ${installPostSummaryConcrete} new posts in concrete`);
    if(installPostSummaryAnchored) postTaskParts.push(`anchor ${installPostSummaryAnchored} new posts to concrete`);
    if(wroughtPanelInstallReturnNextDay){
      postTaskParts.push('return another day to install panels');
    }
    if(woodInstallPlan.removalLf > 0 && woodInstallScopeSections.length <= 0){
      postTaskParts.push(`remove and stack ${formatFtValue(woodInstallPlan.removalLf)} lf of existing wood fence for haul away`);
    }
    if(concreteRealignCount > 0){
      postTaskParts.push(`realign ${concreteRealignCount} metal posts (dig, straighten, and add concrete)`);
    }
    if(totals.postsRealignCutWeld > 0){
      postTaskParts.push(`assist welder with ${totals.postsRealignCutWeld} cut/weld metal post ${plural(totals.postsRealignCutWeld, 'realignment')}`);
    }
    if((totals.woodPostReplace6 + totals.woodPostReplace8) > 0){
      postTaskParts.push(`replace ${totals.woodPostReplace6 + totals.woodPostReplace8} wood posts`);
    }
    if(totals.woodPostInstall > 0){
      postTaskParts.push(`install ${totals.woodPostInstall} wood posts`);
    }
    if(totals.woodPostRealignDig > 0){
      postTaskParts.push(`realign ${totals.woodPostRealignDig} wood posts (dig/straighten)`);
    }
    if(totals.woodPostRealignCutWeld > 0){
      postTaskParts.push(`assist welder with ${totals.woodPostRealignCutWeld} cut/weld wood post ${plural(totals.woodPostRealignCutWeld, 'realignment')}`);
    }

    const patchWelderHours = totals.wiPatches * (20/60);
    const railReplaceWelderHours = totals.wiRails * (45/60);
    const railGapWelderHours = totals.wiRailGaps * (20/60);
    const diagonalBraceWelderHours = totals.diagonalBraces * (20/60);
    const picketWelderHours = totals.wiPickets * (12/60);
    const puppyPicketWelderHours = totals.puppyPickets * (12/60);
    const weldRedoWelderHours = totals.weldRedos * (5/60);
    const welderTaskGroups = [];
    if(totals.wiPatches > 0){
      welderTaskGroups.push({ hours: patchWelderHours, label: `${totals.wiPatches}x rail ${plural(totals.wiPatches, 'patch', 'patches')}` });
    }
    if(weldedPanelHours > 0){
      const weldedPanelsCount = Math.max(0, (totals.panelsPrefab || 0) + (totals.panelsCustom || 0));
      const panelTaskLabel = weldedPanelsCount > 0
        ? `${weldedPanelsCount} panel weld ${plural(weldedPanelsCount, 'install/repair task', 'install/repair tasks')}`
        : 'panel weld install/repair tasks';
      welderTaskGroups.push({ hours: weldedPanelHours, label: panelTaskLabel });
    }
    if(totals.wiRails > 0){
      welderTaskGroups.push({ hours: railReplaceWelderHours, label: `${totals.wiRails}x full rail ${plural(totals.wiRails, 'replacement')}` });
    }
    if(totals.wiRailGaps > 0){
      welderTaskGroups.push({ hours: railGapWelderHours, label: `${totals.wiRailGaps}x full rail gap ${plural(totals.wiRailGaps, 'filler')}` });
    }
    if(totals.diagonalBraces > 0){
      welderTaskGroups.push({ hours: diagonalBraceWelderHours, label: `${totals.diagonalBraces}x diagonal ${plural(totals.diagonalBraces, 'brace')} addition` });
    }
    if(totals.wiPickets > 0){
      welderTaskGroups.push({ hours: picketWelderHours, label: `${totals.wiPickets}x metal picket ${plural(totals.wiPickets, 'replacement')}` });
    }
    if(totals.puppyPickets > 0){
      welderTaskGroups.push({ hours: puppyPicketWelderHours, label: `${totals.puppyPickets}x puppy picket ${plural(totals.puppyPickets, 'replacement')}` });
    }
    if(totals.weldRedos > 0){
      welderTaskGroups.push({ hours: weldRedoWelderHours, label: `${totals.weldRedos}x weld ${plural(totals.weldRedos, 'redo')}` });
    }
    if(totals.finials > 0){
      welderTaskGroups.push({ hours: finialHours, label: `${totals.finials}x finial ${plural(totals.finials, 'replacement')}` });
    }
    if(totals.puppyInserts > 0){
      welderTaskGroups.push({ hours: puppyInsertWelderHours, label: `${totals.puppyInserts}x puppy insert ${plural(totals.puppyInserts, 'install')}` });
    }
    if(totals.postsRealignCutWeld > 0){
      welderTaskGroups.push({ hours: cutWeldWelderHours, label: `${totals.postsRealignCutWeld}x cut/weld metal post ${plural(totals.postsRealignCutWeld, 'realign')}` });
    }
    if(totals.woodPostRealignCutWeld > 0){
      welderTaskGroups.push({ hours: woodPostCutWeldWelderHours, label: `${totals.woodPostRealignCutWeld}x cut/weld wood post ${plural(totals.woodPostRealignCutWeld, 'realign')}` });
    }
    const welderActiveTaskCount = welderTaskGroups.filter(group=> isFinite(group?.hours) && group.hours > 0).length;
    const maxParallelWelders = Math.max(1, Math.min(maxWeldersConfigured, Math.max(1, ONSITE_CREW_SIZE - 1)));
    const weldLaneCount = Math.max(1, Math.min(maxParallelWelders, welderActiveTaskCount || 1));
    const helperLaneParallel = Math.max(1, ONSITE_CREW_SIZE - Math.min(weldLaneCount, Math.max(0, ONSITE_CREW_SIZE - 1)));

    const postAndWeldLines = [];
    let stageOneEndAt = 0;
    let stageOnePaintConsumedManHours = 0;
    const hasPostLane = postHelperManHours > 0 && postTaskParts.length > 0;
    const woodInstallBuildManHoursInStageOne = woodInstallReturnNextDay ? 0 : woodInstallBuildManHours;
    const productionHelperManHours =
      bracketPanelHours +
      digHours +
      capHours +
      puppyInsertHelperHours +
      woodInstallBuildManHoursInStageOne +
      woodCoreRepairManHours;
    const productionParts = [];
    if(bracketPanelHours > 0){
      const bracketPanelsCount = Math.max(0, (totals.panelsPrefab || 0) + (totals.panelsCustom || 0));
      productionParts.push(bracketPanelsCount > 0
        ? `panel bracket installs/repairs (${bracketPanelsCount} panels)`
        : 'panel bracket installs/repairs');
    }
    if(digHours > 0 && totals.digOut > 0){
      productionParts.push(`dig out ${totals.digOut} lf`);
    }
    if(capHours > 0 && totals.caps > 0){
      productionParts.push(`replace ${totals.caps} post ${plural(totals.caps, 'cap')}`);
    }
    if(puppyInsertHelperHours > 0 && totals.puppyInserts > 0){
      productionParts.push(`fit/secure ${totals.puppyInserts} puppy insert backers`);
    }
    if(woodInstallBuildManHoursInStageOne > 0){
      productionParts.push(`${woodInstallBuildTaskPhrase} (${woodInstallPlan.buildDays} day${woodInstallPlan.buildDays === 1 ? '' : 's'} planned)`);
    }
    if(woodCoreRepairManHours > 0){
      productionParts.push('wood repair production (rails/pickets/panels/trim)');
    }
    const welderBuckets = allocateTasksByLane(welderTaskGroups, weldLaneCount);
    const hasWelderLane = welderBuckets.length > 0;
    const hasHelperProductionLane = productionHelperManHours > 0;
    const postStageWelderNames = assignWelderLaneNames(welderBuckets.length);
    const helperTaskParts = [];
    let helperTaskManHours = 0;
    let helperNamesForStage = [];
    let helperAssistOnly = false;
    let postLaneReadyAt = 0;
    if(hasPostLane){
      helperTaskParts.push(...postTaskParts);
      helperTaskManHours += postHelperManHours;
    }
    if(productionHelperManHours > 0 && productionParts.length){
      helperTaskParts.push(...productionParts);
      helperTaskManHours += productionHelperManHours;
    }
    if(helperTaskParts.length && helperTaskManHours > 0){
      helperAssistOnly = helperTaskParts.every(part=> /^assist welder with /i.test(String(part || '').trim()));
      const helperCount = helperAssistOnly
        ? Math.max(1, Math.min(
          hasWelderLane ? postStageWelderNames.length : 1,
          hasWelderLane ? helperLaneParallel : helperLaneFullCrew
        ))
        : (hasWelderLane ? helperLaneParallel : helperLaneFullCrew);
      helperNamesForStage = pickCrewNames(helperCount, hasWelderLane ? postStageWelderNames : []);
      const helperDuration = helperTaskManHours / helperCount;
      if(hasPostLane && postHelperManHours > 0){
        postLaneReadyAt = postHelperManHours / helperCount;
      }
      reservePeopleUntil(helperNamesForStage, helperDuration);
      stageOneEndAt = Math.max(stageOneEndAt, helperDuration);
      const helperTaskText = helperTaskParts
        .map(part=>{
          if(!/^assist welder with /i.test(String(part || '').trim())) return part;
          const welderLabel = postStageWelderNames.length ? formatNameList(postStageWelderNames) : 'welder';
          const cutWeldMatch = String(part).match(/^assist welder with\s+(\d+)\s+cut\/weld\s+(.+?)\s+realignment(?:s)?$/i);
          if(cutWeldMatch){
            const count = parseInt(cutWeldMatch[1], 10) || 0;
            const targetBase = String(cutWeldMatch[2] || '').trim();
            const targetLabel = count === 1 ? targetBase : `${targetBase}s`;
            return `realign ${count} ${targetLabel} via the cut and weld method`;
          }
          return String(part).replace(/^assist welder with /i, `assist ${welderLabel} with `);
        })
        .join('; ');
      const helperLineNames = helperAssistOnly
        ? Array.from(new Set([...postStageWelderNames, ...helperNamesForStage]))
        : helperNamesForStage;
      postAndWeldLines.push(`${formatNameList(helperLineNames)}: ${helperTaskText} (${formatTaskHours(helperDuration)}).`);
    }
    welderBuckets.forEach((bucket, idx)=>{
      const welderName = postStageWelderNames[idx] || `Welder ${idx + 1}`;
      reservePeopleUntil([welderName], bucket.hours);
      stageOneEndAt = Math.max(stageOneEndAt, bucket.hours);
      const cutWeldPattern = /\bcut\/weld\b/i;
      const hasCutWeldTask = bucket.tasks.some(task=> cutWeldPattern.test(String(task || '')));
      const hasNonCutWeldTask = bucket.tasks.some(task=> !cutWeldPattern.test(String(task || '')));
      if(helperAssistOnly && hasCutWeldTask && !hasNonCutWeldTask){
        return;
      }
      postAndWeldLines.push(`${formatNameList([welderName])}: ${bucket.tasks.join('; ')} (${formatTaskHours(bucket.hours)}).`);
    });
    if(
      hasWelderLane &&
      hasByHandPaintScope &&
      paintLenTotal > 0 &&
      paintPrepEligibleManHours > 0 &&
      stageOneEndAt > 0 &&
      !consolidateByHandPaintProcessNotes
    ){
      const stageOneHelperPaintCandidates = crewNames.filter(name=>
        !postStageWelderNames.includes(name) &&
        !helperNamesForStage.includes(name)
      );
      if(stageOneHelperPaintCandidates.length > 0){
      const stageOneHelperPaintSchedule = scheduleWorkByAvailability({
        names: stageOneHelperPaintCandidates,
        totalHours: paintPrepEligibleManHours,
        earliestStart: 0,
        latestEnd: stageOneEndAt
      });
      stageOnePaintConsumedManHours = stageOneHelperPaintSchedule.workDone;
      if(stageOneHelperPaintSchedule.workDone > 0){
        reserveScheduledPeople(stageOneHelperPaintSchedule);
        const stageOneHelperPaintNames = stageOneHelperPaintSchedule.participants.length
          ? stageOneHelperPaintSchedule.participants
          : stageOneHelperPaintCandidates;
        postAndWeldLines.push(`${formatNameList(stageOneHelperPaintNames)}: scrape loose rust and debris and hand paint ${paintLenTotal} ft of fence (${formatTaskHours(stageOneHelperPaintSchedule.elapsed)}).`);
      }
      }
    }
    if(postAndWeldLines.length){
      let stageTitleBase = 'Fence production';
      const hasStageOneHelperPaint = stageOnePaintConsumedManHours > 0;
      if(hasPostLane && hasWelderLane){
        stageTitleBase = 'Posts + weld repairs in parallel';
      } else if(hasPostLane){
        stageTitleBase = 'Post work';
      } else if(hasWelderLane && hasStageOneHelperPaint){
        stageTitleBase = 'Weld repairs + paint prep in parallel';
      } else if(hasWelderLane && hasHelperProductionLane){
        stageTitleBase = 'Fence production in parallel';
      } else if(hasWelderLane){
        stageTitleBase = 'Weld repairs';
      }
      pushStage(stageTitleBase, postAndWeldLines);
    }
    if(wroughtInstallPanelCrewHours > 0){
      const panelCrewCount = Math.max(1, helperLaneFullCrew);
      const panelCrewNames = pickCrewNames(panelCrewCount, []);
      const panelBaseStartGate = panelCrewNames.reduce((max, name)=>{
        return Math.max(max, getPersonAvailableAt(name));
      }, Math.max(stageOneEndAt, postLaneReadyAt));
      const dayBlock = Math.max(0.25, Number(HOURS_PER_PERSON || CREW_SETTINGS.maxDayHours || 13) || 13);
      let panelStartGate = panelBaseStartGate;
      if(wroughtPanelInstallReturnNextDay){
        panelStartGate = Math.ceil(panelBaseStartGate / dayBlock) * dayBlock;
        if(panelStartGate <= panelBaseStartGate + 1e-9){
          panelStartGate += dayBlock;
        }
      }
      const panelSchedule = scheduleWorkByAvailability({
        names: panelCrewNames,
        totalHours: wroughtInstallPanelCrewHours * panelCrewCount,
        earliestStart: panelStartGate
      });
      const panelLineNames = panelSchedule.participants.length
        ? panelSchedule.participants
        : panelCrewNames;
      if(panelSchedule.workDone > 0){
        reserveScheduledPeople(panelSchedule);
      }
      const panelDuration = panelSchedule.workDone > 0
        ? panelSchedule.elapsed
        : wroughtInstallPanelCrewHours;
      const panelLengthLabel = formatFtValue(wroughtInstallPanelLf);
      const panelTypeParts = [];
      if(totals.panelsInstallCustomShop > 0){
        panelTypeParts.push(`${totals.panelsInstallCustomShop} shop-fabricated custom ${plural(totals.panelsInstallCustomShop, 'panel')}`);
      }
      if(totals.panelsInstallCustomTmi > 0){
        panelTypeParts.push(`${totals.panelsInstallCustomTmi} TMI custom ${plural(totals.panelsInstallCustomTmi, 'panel')}`);
      }
      if(totals.panelsInstallPrefab > 0){
        panelTypeParts.push(`${totals.panelsInstallPrefab} prefab ${plural(totals.panelsInstallPrefab, 'panel')}`);
      }
      const panelTypeLabel = panelTypeParts.length ? joinParts(panelTypeParts) : 'fabricated panels';
      const panelInstallLine = panelLengthLabel
        ? `${formatNameList(panelLineNames)}: install ${panelTypeLabel} on about ${panelLengthLabel}ft of wrought iron fence (${formatTaskHours(panelDuration)}).`
        : `${formatNameList(panelLineNames)}: install ${panelTypeLabel} on the wrought iron fence (${formatTaskHours(panelDuration)}).`;
      pushStage('Wrought panel install', [panelInstallLine]);
    }
    if(woodInstallReturnNextDay && woodInstallBuildManHours > 0 && woodInstallScopeSections.length > 0){
      const woodBuildCrewCount = Math.max(1, helperLaneFullCrew);
      const woodBuildNames = pickCrewNames(woodBuildCrewCount, []);
      const woodBuildStartGate = woodBuildNames.reduce((max, name)=>{
        return Math.max(max, getPersonAvailableAt(name));
      }, 0);
      const woodBuildSchedule = scheduleWorkByAvailability({
        names: woodBuildNames,
        totalHours: woodInstallBuildManHours,
        earliestStart: woodBuildStartGate
      });
      const woodBuildLineNames = woodBuildSchedule.participants.length
        ? woodBuildSchedule.participants
        : woodBuildNames;
      if(woodBuildSchedule.workDone > 0){
        reserveScheduledPeople(woodBuildSchedule);
      }
      const woodBuildDuration = woodBuildSchedule.workDone > 0
        ? woodBuildSchedule.elapsed
        : (woodInstallBuildManHours / woodBuildCrewCount);
      const woodBuildLine = `${formatNameList(woodBuildLineNames)}: ${woodInstallBuildTaskPhrase} (${formatTaskHours(woodBuildDuration)}).`;
      pushStage('Wood build-out', [woodBuildLine]);
    }

    const tieInLines = [];
    const hasPanelTieIns = postPanelTieInWelderHours > 0;
    const hasPaintPrep = paintLenTotal > 0;
    let tieInWelderNames = [];
    let tieInSchedule = null;
    let prepSchedule = null;
    let prepLineNames = [];
    let prepLineAction = '';
    let prepLineHours = 0;
    let prepLineSubIndex = -1;
    const buildPrepLine = ()=>{
      if(!prepLineAction || !prepLineNames.length) return '';
      const prepDurationLabel = prepLineHours > 0 ? ` (${formatTaskHours(prepLineHours)})` : '';
      return `${formatNameList(prepLineNames)}: ${prepLineAction}${prepDurationLabel}.`;
    };
    let paintPrepConsumedManHours = stageOnePaintConsumedManHours;
    if(postPanelTieInWelderHours > 0){
      const tieInWelders = Math.max(1, Math.min(weldLaneCount, wroughtPostReplacements || 1));
      const tieInCandidates = assignWelderLaneNames(tieInWelders);
      const tieInStartGate = hasPostLane ? postLaneReadyAt : 0;
      tieInSchedule = scheduleWorkByAvailability({
        names: tieInCandidates,
        totalHours: postPanelTieInWelderHours,
        earliestStart: tieInStartGate
      });
      tieInWelderNames = tieInSchedule.participants.length ? tieInSchedule.participants : tieInCandidates;
      if(tieInSchedule.workDone > 0){
        reserveScheduledPeople(tieInSchedule);
        const tieInDurationLabel = formatTaskHours(tieInSchedule.elapsed);
        const tieInSplit = contributorSplitNote(tieInSchedule, tieInWelderNames);
        const tieInSuffix = tieInDurationLabel ? ` (${tieInDurationLabel}${tieInSplit})` : '';
        tieInLines.push(`${formatNameList(tieInWelderNames)}: weld panels back to ${wroughtPostReplacements} replacement ${plural(wroughtPostReplacements, 'post')}, trim tops of posts to be 2" above the panel, and put a matching post cap on each post${tieInSuffix}.`);
      }
    }
    const remainingPrepEligibleManHours = Math.max(0, paintPrepEligibleManHours - paintPrepConsumedManHours);
    if(
      hasPanelTieIns &&
      paintLenTotal > 0 &&
      remainingPrepEligibleManHours > 0 &&
      !consolidateByHandPaintProcessNotes
    ){
      const prepCrew = postPanelTieInWelderHours > 0 ? helperLaneParallel : helperLaneFullCrew;
      const prepNames = pickCrewNames(prepCrew, tieInWelderNames);
      const prepStartGate = tieInSchedule ? tieInSchedule.startTime : (hasPostLane ? postLaneReadyAt : 0);
      const prepEndGate = tieInSchedule ? tieInSchedule.endTime : null;
      prepSchedule = scheduleWorkByAvailability({
        names: prepNames,
        totalHours: remainingPrepEligibleManHours,
        earliestStart: prepStartGate,
        latestEnd: prepEndGate
      });
      paintPrepConsumedManHours += prepSchedule.workDone;
      if(prepSchedule.workDone > 0){
        reserveScheduledPeople(prepSchedule);
        prepLineNames = prepSchedule.participants.length ? prepSchedule.participants : prepNames;
        prepLineAction = hasByHandPaintScope
          ? `scrape loose rust and debris and hand paint ${paintLenTotal} ft of fence`
          : `scrape loose rust and debris on ${paintLenTotal} ft to prep for paint`;
        prepLineHours = prepSchedule.elapsed;
        tieInLines.push(buildPrepLine());
      }
    }
    if(tieInLines.length){
      let tieInTitleBase = 'Paint prep';
      if(hasPanelTieIns && hasPaintPrep){
        tieInTitleBase = 'Panel tie-ins and paint prep';
      } else if(hasPanelTieIns){
        tieInTitleBase = 'Panel tie-ins';
      }
      pushStage(tieInTitleBase, tieInLines);
      const prepStageLine = buildPrepLine();
      if(prepStageLine){
        prepLineSubIndex = sub.lastIndexOf(`- ${prepStageLine}`);
      }
    }

    const tieInEndAt = tieInSchedule && tieInSchedule.workDone > 0 ? tieInSchedule.endTime : 0;
    const prepEndAt = prepSchedule && prepSchedule.workDone > 0 ? prepSchedule.endTime : 0;
    const gateStartGate = Math.max(tieInEndAt, prepEndAt);
    const gateOperatorManHours = driveGateOperatorHours + driveGateOperatorInstallHours;
    const gateWelderHours = gateRepairHours + wroughtAddedGateHours;
    const gateHelperManHours = woodAddedGateHours + woodGateRepairManHours + driveGateChainManHours + gateOperatorManHours;
    const gateParallelUnits = Math.max(
      0,
      totals.walkGates || 0,
      totals.walkRealign || 0,
      walkHardwareSummary.total || 0,
      totals.walkRebuild || 0,
      totals.walkGateAdds || 0,
      totals.walkGateAddsSingle || 0,
      totals.walkGateAddsDouble || 0
    );
    const gateWelderSlots = gateWelderHours > 0
      ? Math.max(1, Math.min(maxWeldersConfigured, welderNames.length || 1, gateParallelUnits || 1))
      : 0;
    const gateHelperParallel = gateWelderSlots > 0
      ? Math.max(1, ONSITE_CREW_SIZE - Math.min(gateWelderSlots, Math.max(0, ONSITE_CREW_SIZE - 1)))
      : helperLaneFullCrew;
    const gateLines = [];
    let gateEndAt = gateStartGate;
    const gateWelderScopeParts = [];
    if(totals.walkRealign > 0){
      gateWelderScopeParts.push(`realign ${totals.walkRealign} walk ${plural(totals.walkRealign, 'gate')}`);
    }
    if(walkHardwareSummary.total > 0){
      const hwDetail = walkHardwareSummary.details.length ? ` (${walkHardwareSummary.details.join('; ')})` : '';
      gateWelderScopeParts.push(`replace walk gate hinges/latch${hwDetail}`);
    }
    if(totals.walkRebuild > 0){
      gateWelderScopeParts.push(`rebuild ${totals.walkRebuild} walk ${plural(totals.walkRebuild, 'gate')}`);
    }
    if(totals.walkGateAddsSingle > 0){
      gateWelderScopeParts.push(`add ${totals.walkGateAddsSingle} single swing walk ${plural(totals.walkGateAddsSingle, 'gate')}`);
    }
    if(totals.walkGateAddsDouble > 0){
      gateWelderScopeParts.push(`add ${totals.walkGateAddsDouble} double swing walk ${plural(totals.walkGateAddsDouble, 'gate')}`);
    }
    if(totals.walkGateAdds > 0 && totals.walkGateAddsSingle <= 0 && totals.walkGateAddsDouble <= 0){
      gateWelderScopeParts.push(`add ${totals.walkGateAdds} walk ${plural(totals.walkGateAdds, 'gate')}`);
    }
    const gateWelderScope = gateWelderScopeParts.length ? gateWelderScopeParts.join('; ') : 'gate realign/hardware/rebuild and wrought gate adds';
    let gateWelderNames = [];
    if(gateWelderHours > 0){
      const gateWelderCandidates = assignWelderLaneNames(gateWelderSlots || 1);
      const gateWelderSchedule = scheduleWorkByAvailability({
        names: gateWelderCandidates,
        totalHours: gateWelderHours,
        earliestStart: gateStartGate
      });
      gateWelderNames = gateWelderSchedule.participants.length ? gateWelderSchedule.participants : gateWelderCandidates;
      if(gateWelderSchedule.workDone > 0){
        reserveScheduledPeople(gateWelderSchedule);
        gateEndAt = Math.max(gateEndAt, gateWelderSchedule.endTime);
        const gateWelderDuration = gateWelderSchedule.elapsed;
        const gateWelderSplit = contributorSplitNote(gateWelderSchedule, gateWelderNames);
        gateLines.push(`${formatNameList(gateWelderNames)}: ${gateWelderScope} (${formatTaskHours(gateWelderDuration)}${gateWelderSplit}).`);
      }
    }
    if(gateHelperManHours > 0){
      const gateHelpers = gateWelderHours > 0 ? gateHelperParallel : helperLaneFullCrew;
      const gateHelperCandidates = pickCrewNames(gateHelpers, gateWelderNames);
      const gateHelperSchedule = scheduleWorkByAvailability({
        names: gateHelperCandidates,
        totalHours: gateHelperManHours,
        earliestStart: gateStartGate
      });
      const gateScopeParts = [];
      if(totals.woodWalkGateAdds > 0){
        gateScopeParts.push(`${totals.woodWalkGateAdds} wood walk gate ${plural(totals.woodWalkGateAdds, 'add')}`);
      }
      if((totals.woodGateRepair + totals.woodGateStrengthen + totals.woodGateReplace) > 0){
        gateScopeParts.push(`${totals.woodGateRepair + totals.woodGateStrengthen + totals.woodGateReplace} wood gate ${plural(totals.woodGateRepair + totals.woodGateStrengthen + totals.woodGateReplace, 'repair/replace task', 'repair/replace tasks')}`);
      }
      if(totals.driveGateChainReplacements > 0){
        gateScopeParts.push(`${totals.driveGateChainReplacements} drive gate chain ${plural(totals.driveGateChainReplacements, 'replacement')}`);
      }
      if((totals.driveGateOperators + totals.driveGateOperatorInstalls) > 0){
        gateScopeParts.push(`${totals.driveGateOperators + totals.driveGateOperatorInstalls} drive operator ${plural(totals.driveGateOperators + totals.driveGateOperatorInstalls, 'task')}`);
      }
      const gateScope = gateScopeParts.length ? gateScopeParts.join('; ') : 'gate and operator tasks';
      const gateHelperNames = gateHelperSchedule.participants.length ? gateHelperSchedule.participants : gateHelperCandidates;
      if(gateHelperSchedule.workDone > 0){
        reserveScheduledPeople(gateHelperSchedule);
        gateEndAt = Math.max(gateEndAt, gateHelperSchedule.endTime);
        const gateHelperDuration = gateHelperSchedule.elapsed;
        gateLines.push(`${formatNameList(gateHelperNames)}: ${gateScope} (${formatTaskHours(gateHelperDuration)}).`);
      }
    }
    let gatePaintConsumedManHours = 0;
    let gatePaintNames = [];
    if(
      !hasPanelTieIns &&
      hasByHandPaintScope &&
      paintLenTotal > 0 &&
      gateEndAt > gateStartGate &&
      !consolidateByHandPaintProcessNotes
    ){
      const gatePaintEligibleManHours = Math.max(0, paintPrepEligibleManHours - paintPrepConsumedManHours);
      if(gatePaintEligibleManHours > 0){
        const gatePaintCrew = gateWelderHours > 0 ? gateHelperParallel : helperLaneFullCrew;
        const gatePaintCandidates = pickCrewNames(gatePaintCrew, gateWelderNames);
        const gatePaintSchedule = scheduleWorkByAvailability({
          names: gatePaintCandidates,
          totalHours: gatePaintEligibleManHours,
          earliestStart: gateStartGate,
          latestEnd: gateEndAt
        });
        gatePaintConsumedManHours = gatePaintSchedule.workDone;
        if(gatePaintSchedule.workDone > 0){
          reserveScheduledPeople(gatePaintSchedule);
          gatePaintNames = gatePaintSchedule.participants.length ? gatePaintSchedule.participants : gatePaintCandidates;
          const gatePaintDuration = gatePaintSchedule.elapsed;
          gateLines.push(`${formatNameList(gatePaintNames)}: scrape loose rust and debris and hand paint ${paintLenTotal} ft of fence (${formatTaskHours(gatePaintDuration)}).`);
        }
      }
    }
    if(gateLines.length){
      pushStage('Gate and operator work', gateLines);
    }

    const coatingStartGate = Math.max(tieInEndAt, prepEndAt);
    const remainingPaintManHours = Math.max(0, paintLaborTotalManHours - paintPrepConsumedManHours - gatePaintConsumedManHours);
    const coatingTotalManHours = remainingPaintManHours + washHours + stainManHours;
    if(coatingTotalManHours > 0){
      const coatingLines = [];
      const hasSimpleByHandPaintTail = consolidateByHandPaintProcessNotes;
      let sprayNames = [];
      let paintSchedule = null;
      let paintNames = [];
      if((sprayBaseHours + sprayFinishHours) > 0){
        const sprayCrew = Math.max(1, Math.min(weldLaneCount, 2));
        const sprayCandidates = assignWelderLaneNames(sprayCrew);
        const spraySchedule = scheduleWorkByAvailability({
          names: sprayCandidates,
          totalHours: (sprayBaseHours + sprayFinishHours),
          earliestStart: coatingStartGate
        });
        sprayNames = spraySchedule.participants.length ? spraySchedule.participants : sprayCandidates;
        if(spraySchedule.workDone > 0){
          reserveScheduledPeople(spraySchedule);
          const sprayDuration = spraySchedule.elapsed;
          const spraySplit = contributorSplitNote(spraySchedule, sprayNames);
          coatingLines.push(`${formatNameList(sprayNames)}: spray coats on scheduled metal sections (${formatTaskHours(sprayDuration)}${spraySplit}).`);
        }
      }
      if(paintLenTotal > 0 && remainingPaintManHours > 0){
        const paintCrew = (sprayBaseHours + sprayFinishHours) > 0 ? helperLaneParallel : helperLaneFullCrew;
        const defaultPaintCandidates = pickCrewNames(paintCrew, sprayNames);
        let paintCandidates = defaultPaintCandidates.slice();
        let shortTailWrapUpNames = [];
        if(hasSimpleByHandPaintTail && defaultPaintCandidates.length){
          const shortTailThresholdHours = 20 / 60;
          const estimatedFullCrewDuration = remainingPaintManHours / defaultPaintCandidates.length;
          const preferredByHandTailCrew = (
            (prepSchedule && prepSchedule.workDone > 0 && prepSchedule.participants.length)
              ? prepSchedule.participants.slice()
              : (gatePaintNames.length ? gatePaintNames.slice() : crewNames.filter(name=> !welderNames.includes(name)))
          ).filter(name=> !sprayNames.includes(name));
          if(estimatedFullCrewDuration <= shortTailThresholdHours && preferredByHandTailCrew.length){
            paintCandidates = preferredByHandTailCrew;
            const preferredSet = new Set(preferredByHandTailCrew);
            shortTailWrapUpNames = defaultPaintCandidates.filter(name=> !preferredSet.has(name));
          }
        }
        paintSchedule = scheduleWorkByAvailability({
          names: paintCandidates,
          totalHours: remainingPaintManHours,
          earliestStart: coatingStartGate
        });
        paintNames = paintSchedule.participants.length ? paintSchedule.participants : paintCandidates;
        if(paintSchedule.workDone > 0){
          reserveScheduledPeople(paintSchedule);
          const continuingByHandCrew =
            hasByHandPaintScope &&
            prepSchedule && prepSchedule.workDone > 0 &&
            (sprayBaseHours + sprayFinishHours) <= 0 &&
            washHours <= 0 &&
            stainHours <= 0 &&
            sameNameSet(paintNames, prepSchedule.participants);
          if(continuingByHandCrew){
            if(prepLineSubIndex >= 0){
              prepLineHours += paintSchedule.elapsed;
              sub[prepLineSubIndex] = `- ${buildPrepLine()}`;
            }
          } else {
            const paintDuration = paintSchedule.elapsed;
            const paintSplit = contributorSplitNote(paintSchedule, paintNames);
            const primeNote = primePaintScheduled ? ' (prime + return finish coat)' : '';
            const durationNote = paintDuration > 0 ? ` (${formatTaskHours(paintDuration)}${paintSplit})` : '';
            const paintActionLabel = consolidateByHandPaintProcessNotes
              ? `scrape loose rust and debris and hand paint ${paintLenTotal} ft of fence`
              : `paint ${paintLenTotal} ft of fence`;
            coatingLines.push(`${formatNameList(paintNames)}: ${paintActionLabel}${primeNote}${durationNote}.`);
            if(shortTailWrapUpNames.length && paintDuration > 0){
              reservePeopleUntil(shortTailWrapUpNames, paintSchedule.endTime);
              coatingLines.push(`${formatNameList(shortTailWrapUpNames)}: clean up tools and load everything up (${formatTaskHours(paintDuration)}).`);
            }
          }
        }
      }
      if(washHours > 0){
        const washCrew = helperLaneFullCrew;
        const washCandidates = pickCrewNames(washCrew, sprayNames);
        const washSchedule = scheduleWorkByAvailability({
          names: washCandidates,
          totalHours: washHours,
          earliestStart: coatingStartGate
        });
        const washNames = washSchedule.participants.length ? washSchedule.participants : washCandidates;
        if(washSchedule.workDone > 0){
          reserveScheduledPeople(washSchedule);
          const washDuration = washSchedule.elapsed;
          coatingLines.push(`${formatNameList(washNames)}: power wash wood sections (${formatTaskHours(washDuration)}).`);
        }
      }
      if(stainHours > 0){
        const stainCrew = Math.max(1, peakStainers || 1);
        const stainCandidates = pickCrewNames(stainCrew, sprayNames);
        const stainSchedule = scheduleWorkByAvailability({
          names: stainCandidates,
          totalHours: stainHours,
          earliestStart: coatingStartGate
        });
        const stainNames = stainSchedule.participants.length ? stainSchedule.participants : stainCandidates;
        if(stainSchedule.workDone > 0){
          reserveScheduledPeople(stainSchedule);
          const stainDuration = stainSchedule.elapsed;
          coatingLines.push(`${formatNameList(stainNames)}: stain wood sections (${formatTaskHours(stainDuration)}).`);
        }
      }
      const coatingTitleBase = (paintLenTotal > 0 && !hasWoodStaining && !hasWoodWash)
        ? 'Paint the fence'
        : 'Coatings and finish work';
      pushStage(coatingTitleBase, coatingLines);
    }

    const scheduledOnsiteHours = crewNames.reduce((max, name)=>{
      return Math.max(max, getPersonAvailableAt(name));
    }, 0);
    if(isFinite(scheduledOnsiteHours) && scheduledOnsiteHours > 0){
      // Setup/teardown is static time and should never be overlapped with scoped work.
      estimatedOnsiteHours = scheduledOnsiteHours + setupTeardownHoursPerPerson;
      estimatedOnsiteLabel = formatHours(estimatedOnsiteHours);
    }
    if(crewOnsiteLineIndex >= 0){
      sub[crewOnsiteLineIndex] = buildOnsiteSummaryLabel(estimatedOnsiteLabel);
    }

    if(stageNumber === 1){
      sub.push('- No labor-generating scope items found. Add scope quantities to generate staged crew process.');
      sub.push('');
    }
    sub.push('SCOPE (Totals)');
    const pushPostLinesSub = (label, counts)=>{
      const parts = [];
      const addIfPresent = (key, label)=>{
        const qty = parseInt(counts?.[key], 10) || 0;
        if(qty > 0) parts.push(`${qty} × ${label}`);
      };
      addIfPresent('posts1p5', '1 1/2" x 1 1/2"');
      addIfPresent('posts2x2', '2x2');
      addIfPresent('posts3x3', '3x3');
      addIfPresent('posts4x4', '4x4');
      if(parts.length) sub.push(`- ${label}: ${parts.join(', ')}`);
    };
    pushPostLinesSub('Posts to replace', totals.postsReplace || zeroPostCounts());
    if (totals.postsRealign2x2 > 0) sub.push('- 2x2 posts to realign: '+totals.postsRealign2x2);
    if (totals.postsRealign3x3 > 0) sub.push('- 3x3 posts to realign: '+totals.postsRealign3x3);
    if (totals.postsRealignCutWeld > 0) sub.push('- Posts to realign (cut & weld): '+totals.postsRealignCutWeld);
    if (totals.woodPostRealignCutWeld > 0) sub.push('- Wood posts to realign (cut & weld): '+totals.woodPostRealignCutWeld);
    if (totals.woodPostRealignDig > 0) sub.push('- Wood posts to realign (dig): '+totals.woodPostRealignDig);
    pushPostLinesSub('Posts to set in concrete (new sections)', totals.postsInstallConcrete || zeroPostCounts());
    pushPostLinesSub('Posts to anchor (new sections)', totals.postsInstallAnchored || zeroPostCounts());
    const nonWoodReplacementSections = replacementSectionsOnly.filter(section=> ((section.fenceType || '').toLowerCase() !== 'wood'));
    const nonWoodInstallSections = installSectionsOnly.filter(section=> ((section.fenceType || '').toLowerCase() !== 'wood'));
    const replacementUsingExistingPosts = replacementSectionsOnly.filter(section=> shouldUseExistingPostsForReplacement(section));
    if (nonWoodReplacementSections.length > 0) sub.push('- Sections to replace: '+nonWoodReplacementSections.length);
    if (nonWoodInstallSections.length > 0) sub.push('- New sections to install: '+nonWoodInstallSections.length);
    if (replacementUsingExistingPosts.length > 0) sub.push('- Replacement sections using existing posts: '+replacementUsingExistingPosts.length);
    const woodScopeServiceLines = [];
    const woodReplacementSections = replacementGroups.get('wood') || [];
    if (woodReplacementSections.length > 0){
      const detail = buildInstallServiceDescription(woodReplacementSections, true) || fenceTypeDefaultDetail('wood', true);
      const sentence = ensureSentence(detail);
      if(sentence) woodScopeServiceLines.push(sentence);
    }
    const woodInstallSections = installGroups.get('wood') || [];
    if (woodInstallSections.length > 0){
      const detail = buildInstallServiceDescription(woodInstallSections, false) || fenceTypeDefaultDetail('wood', false);
      const sentence = ensureSentence(detail);
      if(sentence) woodScopeServiceLines.push(sentence);
    }
    woodScopeServiceLines.forEach(detail=> sub.push(`- ${detail}`));
    if (totals.removalLf > 0){
      const removalCrewLf = Math.max(0, parseFloat(woodInstallPlan.removalLf || 0) || 0);
      const removalSubLfBase = Math.max(0, totals.removalLf - removalCrewLf);
      const removalSubLfWood = Math.max(0, parseFloat(woodInstallPlan.removalSubLf || 0) || 0);
      const removalSubLf = removalSubLfWood > 0
        ? (removalSubLfWood + removalSubLfBase)
        : removalSubLfBase;
      if(removalSubLf > 0 && totals.removalCost > 0 && removalCrewLf > 0){
        sub.push(`- Removal & haul away: ${totals.removalLf} lf (${formatFtValue(removalCrewLf)} lf crew labor included; sub paid $${money(totals.removalCost)} for ${formatFtValue(removalSubLf)} lf)`);
      } else if(totals.removalCost > 0){
        sub.push(`- Removal & haul away: ${totals.removalLf} lf (sub paid $${money(totals.removalCost)})`);
      } else {
        sub.push(`- Removal & haul away: ${totals.removalLf} lf (crew labor included)`);
      }
    }
    if (totals.wiPickets > 0)       sub.push('- Pickets to replace: '+totals.wiPickets);
    if (totals.puppyPickets > 0){
      const detailParts = [];
      if(totals.puppyPicketDetails && typeof totals.puppyPicketDetails.forEach === 'function'){
        totals.puppyPicketDetails.forEach((count, label)=>{
          if(count>0){ detailParts.push(`${count} × ${label}`); }
        });
      }
      const detail = detailParts.length ? ` (${detailParts.join('; ')})` : '';
      sub.push(`- Puppy pickets to replace: ${totals.puppyPickets}${detail}`);
    }
    if (totals.weldRedos > 0)       sub.push('- Weld redos: '+totals.weldRedos);
    if (totals.wiPatches > 0)       sub.push('- Rail patches: '+totals.wiPatches);
    if (totals.wiRails > 0)         sub.push('- Full rail replacements: '+totals.wiRails);
    if (totals.wiRailGaps > 0)      sub.push('- Full rail gap fillers: '+totals.wiRailGaps);
    if (totals.walkRealign > 0) {
      sub.push(`- Realign ${describeCount(totals.walkRealign, 'walk gate', 'walk gates')}`);
    }
    walkHardwareActionLines(walkHardwareSummary).forEach(line=> sub.push(`- ${line}`));
    if (totals.walkRebuild > 0)     sub.push('- Walk gates to rebuild: '+totals.walkRebuild);
    if (totals.walkGateAddsSingle > 0) {
      const gateLabel = totals.walkGateAddsSingle === 1 ? 'walk gate' : 'walk gates';
      sub.push(`- Add ${totals.walkGateAddsSingle} single swing ${gateLabel} into the existing fence`);
    }
    if (totals.walkGateAddsDouble > 0) sub.push('- Double swing gates to add: '+totals.walkGateAddsDouble);
    if (totals.woodWalkGateAddsSingle > 0) sub.push('- Wood single swing walk gates to add: '+totals.woodWalkGateAddsSingle);
    if (totals.woodWalkGateAddsDouble > 0) sub.push('- Wood double swing gates to add: '+totals.woodWalkGateAddsDouble);
    if (totals.driveGateOperators > 0){
      const comboLines = [];
      if(totals.driveGateOperatorCombos && typeof totals.driveGateOperatorCombos.forEach === 'function'){
        totals.driveGateOperatorCombos.forEach((count, key)=>{
          if(count<=0) return;
          const [type, power] = String(key||'').split('|||');
          const typeRaw = (type || 'drive').trim();
          const typeLabel = typeRaw.toLowerCase() || 'drive';
          const powerLabel = (power || '').trim().toLowerCase();
          const operatorLabel = count === 1 ? 'gate operator' : 'gate operators';
          const operatorModel = getDriveGateOperatorLabel(typeRaw);
          const modelSuffix = operatorModel ? ` (${operatorModel})` : '';
          const powerSuffix = powerLabel ? `, using ${powerLabel}` : '';
          comboLines.push(`- Replace ${count} ${typeLabel} ${operatorLabel}${modelSuffix}${powerSuffix}`);
        });
      }
      if(comboLines.length){
        comboLines.forEach(line=> sub.push(line));
      } else {
        sub.push('- Drive gate operators to replace: '+totals.driveGateOperators);
      }
    }
    if (totals.driveGateOperatorInstalls > 0){
      const comboLines = [];
      if(totals.driveGateOperatorInstallCombos && typeof totals.driveGateOperatorInstallCombos.forEach === 'function'){
        totals.driveGateOperatorInstallCombos.forEach((count, key)=>{
          if(count<=0) return;
          const [type, power, platform] = String(key||'').split('|||');
          const typeRaw = (type || 'drive').trim();
          const typeLabel = typeRaw.toLowerCase() || 'drive';
          const powerLabel = (power || '').trim().toLowerCase();
          const operatorLabel = count === 1 ? 'gate operator' : 'gate operators';
          const operatorModel = getDriveGateOperatorLabel(typeRaw);
          const modelSuffix = operatorModel ? ` (${operatorModel})` : '';
          const powerSuffix = powerLabel ? `, using ${powerLabel}` : '';
          const platformSuffix = platform === 'platform' ? ', with platform' : '';
          comboLines.push(`- Install ${count} ${typeLabel} ${operatorLabel}${modelSuffix}${powerSuffix}${platformSuffix}`);
        });
      }
      if(comboLines.length){
        comboLines.forEach(line=> sub.push(line));
      } else {
        sub.push('- Drive gate operators to install: '+totals.driveGateOperatorInstalls);
      }
    }
    if (totals.driveGateChainReplacements > 0){
      sub.push('- Sliding drive gate chains to replace: '+totals.driveGateChainReplacements);
    }
    if (totals.finials > 0)         sub.push('- Finials to replace: '+totals.finials);
    if (totals.puppyInserts > 0)    sub.push('- Puppy picket inserts: '+totals.puppyInserts);
    if (totals.caps > 0)            sub.push('- Post caps to replace: '+totals.caps);
    if (installCapsByLabel.size > 0){
      installCapsByLabel.forEach((qty, label)=>{
        const m = label.match(CAP_LABEL_RE);
        if(m){
          const material = m[1];
          const style = m[2];
          const postSize = m[3];
          sub.push(`- Post caps to install: ${qty} × ${material} ${style} (${postSize})`);
        }else{
          sub.push(`- Post caps to install: ${qty}`);
        }
      });
    }
    if (totals.diagonalBraces > 0)  sub.push('- Diagonal braces to add: '+totals.diagonalBraces);
    if (totals.digOut > 0)          sub.push('- Dig out: '+totals.digOut+' lf');
    if (prefabReplacementCount > 0){
      const detailSuffix = prefabReplacementDetail ? ` (${prefabReplacementDetail})` : '';
      sub.push(`- Prefab panel replacements: ${prefabReplacementCount}${detailSuffix}`);
    }
    if (totals.panelsCustom > 0)    sub.push('- Panels requiring custom fabrication: '+totals.panelsCustom);
    if (totals.panelsInstallPrefab > 0) sub.push('- New prefab panels: '+totals.panelsInstallPrefab);
    if (totals.panelsInstallCustomShop > 0) sub.push('- New custom panels (shop fabricated): '+totals.panelsInstallCustomShop);
    if (totals.panelsInstallCustomOnSite > 0) sub.push('- New custom panels (fabricated on site): '+totals.panelsInstallCustomOnSite);
    if (totals.panelsInstallCustomTmi > 0) sub.push('- New custom panels (ordered from TMI): '+totals.panelsInstallCustomTmi);
    if (totals.panelsInstallCustom > 0 && totals.panelsInstallCustomShop <= 0 && totals.panelsInstallCustomOnSite <= 0 && totals.panelsInstallCustomTmi <= 0){
      sub.push('- New custom panels: '+totals.panelsInstallCustom);
    }
    if (totals.powderCoatPanels > 0) sub.push('- Panels to powder coat: '+totals.powderCoatPanels);
    if (totals.powderCoatPosts > 0) sub.push('- Posts to powder coat: '+totals.powderCoatPosts);
    if (totals.retainingWallSqft > 0) sub.push(`- Retaining wall: ${totals.retainingWallSqft.toFixed(2)} sq ft ($${money(totals.retainingWallCost)}). In-House 4 pours the wall (wall materials & labor included; post materials separate) and Jesus' crew installs the fence. Posts on the wall set in the pour—no extra concrete bags.`);
    const paintedSections = state.sections.filter(section=>{
      const fenceType = (section.fenceType || '').toLowerCase();
      if(fenceType && fenceType !== 'wrought iron') return false;
      return isAnyWroughtPaintMode(effectiveWroughtPaintingSelection(section));
    });
    const sectionPaintColorSections = paintedSections.filter(section=>{
      return isFullWroughtSectionPaintMode(effectiveWroughtPaintingSelection(section));
    });
    let singleTargetPaintColor = '';
    let paintColorChangeDetected = false;
    const targetColorCounts = new Map();
    paintedSections.forEach(section=>{
      const targetColor = normalizeLabelText(section.paintingTargetColor || WROUGHT_PAINT_COLOR_OPTIONS[0]) || WROUGHT_PAINT_COLOR_OPTIONS[0];
      targetColorCounts.set(targetColor, (targetColorCounts.get(targetColor) || 0) + 1);
    });
    sectionPaintColorSections.forEach(section=>{
      if(paintCoatCountForSection(section) > 1){
        paintColorChangeDetected = true;
      }
    });
    if(targetColorCounts.size === 1){
      singleTargetPaintColor = Array.from(targetColorCounts.keys())[0] || '';
    }
    if (paintLenTotal > 0){
      const targetPhrase = singleTargetPaintColor
        ? paintColorPhrase(singleTargetPaintColor, paintColorChangeDetected)
        : '';
      const colorSuffix = targetPhrase ? ` with ${targetPhrase}` : '';
      const coatSuffix = paintColorChangeDetected ? ' May need 2 coats.' : '';
      sub.push(`- Scrape off loose rust and debris, then paint ${paintLenTotal} ft of fence${colorSuffix}.${coatSuffix}`);
    }
    if (totalLenPrimePaint > 0)     sub.push('- Prime with red oxide primer and schedule a return visit after cure to apply the finish coat');
    if (totals.woodPicketReplace > 0) sub.push('- Wood pickets to replace: '+totals.woodPicketReplace);
    if (totals.woodPicketInstall > 0) sub.push('- Wood pickets to install: '+totals.woodPicketInstall);
    if (totals.woodRailReplace > 0) sub.push('- Wood rails to replace: '+totals.woodRailReplace);
    if (totals.woodRailInstall > 0) sub.push('- Wood rails to install: '+totals.woodRailInstall);
    const woodPostReplaceByType = new Map();
    state.sections.forEach(section=>{
      if((section.fenceType || '').toLowerCase() !== 'wood') return;
      if((section.scopeType || 'repair') !== 'repair') return;
      const count = parseInt(section.woodRepairPostReplace || 0, 10) || 0;
      if(count <= 0) return;
      const rawType = String(section.woodPost || 'wood post').trim();
      const typeLabel = rawType ? rawType.toLowerCase() : 'wood';
      woodPostReplaceByType.set(typeLabel, (woodPostReplaceByType.get(typeLabel) || 0) + count);
    });
    woodPostReplaceByType.forEach((count, typeLabel)=>{
      const postLabel = count === 1 ? 'post' : 'posts';
      sub.push(`- Replace ${count} ${typeLabel} ${postLabel}`);
    });
    const woodMethodLabel = (method)=>{
      const match = WOOD_POST_INSTALL_METHODS.find(item=>item.value === method);
      return match ? match.label : method;
    };
    const pushWoodPostMethodLines = (label, counts)=>{
      if(!counts) return;
      Object.entries(counts).forEach(([method, count])=>{
        const qty = parseInt(count,10) || 0;
        if(qty <= 0) return;
        sub.push(`- ${label} (${woodMethodLabel(method)}): ${qty}`);
      });
    };
    pushWoodPostMethodLines('Wood posts to install', totals.woodPostInstallMethods);
    if (totals.woodPanels > 0) sub.push('- Wood panels to replace: '+totals.woodPanels);
    if (totals.woodWalkGateAdds > 0) sub.push('- Wood walk gates to add: '+totals.woodWalkGateAdds);
    if (totals.woodGateRepair > 0) sub.push('- Wood walk gates to repair: '+totals.woodGateRepair);
    if (totals.woodGateStrengthen > 0) sub.push('- Wood gates to strengthen: '+totals.woodGateStrengthen);
    if (totals.woodGateReplace > 0) sub.push('- Wood gates to replace: '+totals.woodGateReplace);
    if (totals.woodTopCapLf > 0) sub.push('- Wood top cap to replace: '+totals.woodTopCapLf+' lf');
    if (totals.woodTrimLf > 0) sub.push('- Wood trim to replace: '+totals.woodTrimLf+' lf');
    if (totals.woodKickLf > 0) sub.push('- Wood kick board to replace: '+totals.woodKickLf+' lf');
    const stainScopeLines = [];
    const summarizeStainLengths = (details)=>{
      const totalsBySide = new Map();
      details.forEach(detail=>{
        const sideRaw = String(detail.sideLabel || '').trim().toLowerCase();
        const sideLabel = sideRaw || 'side';
        const length = isFinite(detail.lengthFt) ? detail.lengthFt : 0;
        if(length <= 0) return;
        totalsBySide.set(sideLabel, (totalsBySide.get(sideLabel) || 0) + length);
      });
      if(!totalsBySide.size) return '';
      const parts = [];
      const order = ['both sides', 'outside', 'inside'];
      order.forEach(side=>{
        if(!totalsBySide.has(side)) return;
        const len = totalsBySide.get(side);
        const rounded = Math.round(len * 10) / 10;
        const lenLabel = Math.abs(rounded - Math.round(rounded)) < 0.05 ? `${Math.round(rounded)}` : `${rounded.toFixed(1)}`;
        parts.push(`${side} of ${lenLabel} linear ft`);
      });
      totalsBySide.forEach((len, side)=>{
        if(order.includes(side)) return;
        const rounded = Math.round(len * 10) / 10;
        const lenLabel = Math.abs(rounded - Math.round(rounded)) < 0.05 ? `${Math.round(rounded)}` : `${rounded.toFixed(1)}`;
        parts.push(`${side} of ${lenLabel} linear ft`);
      });
      return parts.join('; ');
    };
    if (woodWashDetails.length){
      const summary = summarizeStainLengths(woodWashDetails);
      if(summary){
        stainScopeLines.push(`- Power wash the fence to clean off dirt and debris (${summary})`);
        stainScopeLines.push(`- Return after a couple of days to stain the fence (${summary})`);
      } else if (hasWoodWashSelection) {
        stainScopeLines.push('- Wood wash & stain selected; add section length and height to estimate wash time.');
      }
    } else if (hasWoodWashSelection) {
      stainScopeLines.push('- Wood wash & stain selected; add section length and height to estimate wash time.');
    } else if (woodStainDetails.length){
      const summary = summarizeStainLengths(woodStainDetails);
      if(summary){
        stainScopeLines.push(`- Stain the fence (${summary})`);
      } else if (hasWoodStaining) {
        stainScopeLines.push('- Wood staining selected; add section length and height to estimate area.');
      }
    } else if (hasWoodStaining) {
      stainScopeLines.push('- Wood staining selected; add section length and height to estimate area.');
    }
    stainScopeLines.forEach(line => sub.push(line));
    sub.push('');
    sub.push('MATERIALS');
    materialEntries.forEach(({ label, qty }) => {
      sub.push(`- ${qty}x ${label}`);
    });
    const reorderProcessAfterMaterials = (lines)=>{
      const arr = Array.isArray(lines) ? lines.slice() : [];
      const processIdx = arr.indexOf('PROCESS');
      const scopeIdx = arr.indexOf('SCOPE (Totals)');
      const materialsIdx = arr.indexOf('MATERIALS');
      if(processIdx < 0 || scopeIdx < 0 || materialsIdx < 0) return arr;
      if(processIdx >= scopeIdx) return arr;
      if(materialsIdx <= scopeIdx) return arr;

      let processBlock = arr.slice(processIdx, scopeIdx);
      while(processBlock.length && processBlock[processBlock.length - 1] === ''){
        processBlock.pop();
      }

      const base = [...arr.slice(0, processIdx), ...arr.slice(scopeIdx)];
      if(base.length && base[base.length - 1] !== ''){
        base.push('');
      }
      return [...base, ...processBlock];
    };
    const orderedSub = reorderProcessAfterMaterials(sub);
    if (notesSubEl) { notesSubEl.value = orderedSub.join('\n'); }

    const laborHoursOnsite = isFinite(estimatedOnsiteHours) ? estimatedOnsiteHours : 0;
    const laborHoursShop = Math.max(0, Number(shopFabricationLaborHours || 0) || 0);
    const laborHoursBillable = laborHoursOnsite + laborHoursShop;
    const laborRate = getActiveLaborRate();
    const laborCost = laborHoursBillable * laborRate;
    const baseConsumablesCost = scheduleEntries.length * 50;
    const shopFabricationConsumablesCost = Math.max(0, parseInt(totals.panelsInstallCustomShop || 0, 10) || 0) * 10;
    const consumablesCost = baseConsumablesCost + shopFabricationConsumablesCost;
    const removalCost = totals.removalCost || 0;
    const travelCostResult = await computeTravelCost({ crewSchedule, jobAddress, travelDayInfo });
    const travelCost = travelCostResult.cost || 0;
    const travelHours = isFinite(travelCostResult.hours) ? travelCostResult.hours : 0;
    const totalHours = laborHoursBillable + travelHours;
    const pricingDayCount = Math.max(1, Array.isArray(crewSchedule)
      ? crewSchedule.filter(day => (day?.crew || 0) > 0).length
      : 0);
    const directCosts = laborCost + travelCost + costMaterials + removalCost + consumablesCost;
    const revenueRes = computeChargeRevenue(directCosts, totalHours, { dayCount: pricingDayCount });
    const revenue = revenueRes && isFinite(revenueRes.revenue) ? revenueRes.revenue : NaN;
    const revenueExcludingMcor = revenue * (1 - RATES.mcor);
    const overheadAmount = overheadAmountForRevenue(revenue);
    const overheadAmountForCommission = overheadAmountForRevenue(revenueExcludingMcor);
    const commissionFormula$ = isFinite(revenue)
      ? (RATES.commission * (revenueExcludingMcor - overheadAmountForCommission - directCosts))
      : NaN;

    const cost = [];
    cost.push('ESTIMATED COST');
    const crewScheduleDetail = scheduleEntries.map(entry => {
      const dayTitle = entry.suffix ? `Day ${entry.number}${entry.suffix}` : `Day ${entry.number}`;
      return `${dayTitle}: ${entry.crewLabel}`;
    });
    const shopFabricationHoursLabel = formatHours(laborHoursShop);
    const laborTimeParts = [];
    if(estimatedOnsiteLabel){
      laborTimeParts.push(`${estimatedOnsiteLabel} onsite`);
    }
    if(shopFabricationHoursLabel){
      laborTimeParts.push(`${shopFabricationHoursLabel} shop fabrication`);
    }
    const laborTimeDetail = laborTimeParts.length ? laborTimeParts.join(' + ') : 'time TBD';
    const laborScheduleDetail = crewScheduleDetail.length ? `; ${crewScheduleDetail.join('; ')}` : '';
    cost.push(`- Labor ($${money(laborRate)}/hr, crew): $${money(laborCost)} (${laborTimeDetail}${laborScheduleDetail})`);
    const travelHoursLabel = formatHours(travelHours);
    const totalHoursLabel = formatHours(totalHours);
    const totalLaborHoursOverallLabel = formatHours(Math.max(
      0,
      (Number(manHours) || 0) + ((Number(shopFabricationLaborHours || 0) || 0) * shopFabricationCrewSize)
    ));
    if (estimatedOnsiteLabel) {
      const timeDetail = (shopFabricationHoursLabel && totalLaborHoursOverallLabel)
        ? `${estimatedOnsiteLabel} onsite (~${totalLaborHoursOverallLabel} of labor time total, including ${shopFabricationHoursLabel} shop fabrication)`
        : totalLaborHoursLabel
          ? `${estimatedOnsiteLabel} onsite (~${totalLaborHoursLabel} of labor time)`
          : estimatedOnsiteLabel;
      cost.push(`- Estimated time (onsite): ${timeDetail}`);
    }
    if (shopFabricationHoursLabel){
      cost.push(`- Estimated time (shop fabrication): ${shopFabricationHoursLabel}`);
    }
    if (travelHoursLabel){
      cost.push(`- Estimated time (travel): ${travelHoursLabel}`);
    } else if (!travelCostResult.included){
      cost.push('- Estimated time (travel): not included (missing address or schedule).');
    }
    if (totalHoursLabel){
      const totalLabel = travelCostResult.included ? 'total' : 'total, travel excluded';
      cost.push(`- Estimated time (${totalLabel}): ${totalHoursLabel}`);
    }
    travelCostResult.breakdown.forEach(line => cost.push(line));
    cost.push('- Consumables: $'+money(consumablesCost));
    if(shopFabricationConsumablesCost > 0){
      cost.push(`  - Includes shop panel fabrication consumables: ${totals.panelsInstallCustomShop} panel${totals.panelsInstallCustomShop === 1 ? '' : 's'} × $10.00 = $${money(shopFabricationConsumablesCost)}`);
    }
    cost.push('- Materials: $'+money(costMaterials));
    if(removalCost>0){ cost.push('- Removal & disposal (paid to sub): $'+money(removalCost)); }
    matBreak.forEach(line=> cost.push(line));
    cost.push('- Total: $'+money(laborCost + travelCost + costMaterials + removalCost + consumablesCost));
    if (unpriced) cost.push('  - Note: Some sizes have no price mapping and were counted as $0.');

    cost.push('');
    cost.push('WHAT TO CHARGE');
    if (!isFinite(revenue)){
      cost.push('⚠️ Pricing inputs produced an invalid result. Check overhead, margin target, and costs.');
    } else {
      const grossProfit = revenue - directCosts - overheadAmount;
      const netProfit = grossProfit - commissionFormula$;
      const netProfitPct = revenue !== 0 ? (netProfit / revenue) * 100 : NaN;
      cost.push('- Price to charge: $'+money(revenue));
      cost.push('- Total direct costs: $'+money(directCosts));
      if(isFinite(revenueRes?.targetMargin) && revenueRes.targetMargin > 0){
        const targetMarginLabel = formatPercentLabel(revenueRes.targetMargin);
        cost.push(`- Target gross margin after overhead: ${targetMarginLabel}%`);
      }
      if(isFinite(revenueRes?.minimumMargin) && revenueRes.minimumMargin > 0){
        const minimumMarginLabel = formatPercentLabel(revenueRes.minimumMargin);
        cost.push(`- Minimum gross margin after overhead: ${minimumMarginLabel}%`);
      }
      if(isFinite(revenueRes?.grossProfitCapPerDay) && revenueRes.grossProfitCapPerDay > 0){
        const capDays = Math.max(1, parseInt(revenueRes.grossProfitCapDays || 0, 10) || 1);
        const capTotal = Number(revenueRes.grossProfitCap);
        if(isFinite(capTotal) && capDays > 1){
          cost.push(`- Gross profit cap: $${money(revenueRes.grossProfitCapPerDay)}/day × ${capDays} days = $${money(capTotal)}`);
        }else{
          cost.push(`- Gross profit cap: $${money(revenueRes.grossProfitCapPerDay)} per day`);
        }
      }
      if(isFinite(revenueRes?.grossMarginAchieved) && revenueRes.grossMarginAchieved >= 0){
        const achievedMarginLabel = formatPercentLabel(revenueRes.grossMarginAchieved);
        cost.push(`- Estimated gross margin after overhead: ${achievedMarginLabel}%`);
      }
      if(revenueRes?.grossCapApplied && revenueRes?.minimumGrossMarginApplied){
        cost.push('- Applied the higher guardrail between gross cap and minimum gross margin floor.');
      } else if(revenueRes?.grossCapApplied){
        cost.push('- Gross profit cap applied to final price.');
      } else if(revenueRes?.minimumGrossMarginApplied){
        cost.push('- Minimum gross margin floor applied to final price.');
      }
      if(isFinite(revenueRes?.revenueMinimum) && revenueRes.revenueMinimum > 0 && Math.abs(revenue - revenueRes.revenueMinimum) < 0.01){
        cost.push(`- Minimum charge floor applied: $${money(revenueRes.revenueMinimum)}`);
      }
      cost.push('- Overhead amount: $'+money(overheadAmount));
      cost.push('- Gross profit: $'+money(grossProfit));
      cost.push('- Commission (per formula): $'+money(commissionFormula$));
      cost.push('- Net profit: $'+money(netProfit));
      cost.push('- Net profit %: '+(isFinite(netProfitPct) ? netProfitPct.toFixed(1) : 'Invalid')+'%');
    }

    renderQuickCosts({
      charge: revenue,
      travel: travelCost,
      materials: costMaterials,
      consumables: consumablesCost,
      labor: laborCost,
      overhead: overheadAmount,
      commission: commissionFormula$,
      travelIncluded: !!travelCostResult.included
    });

    const idxTotals = lines.indexOf('TOTALS');
    const outLines = (idxTotals >= 0)
      ? [...lines.slice(idxTotals), '', ...lines.slice(0, idxTotals)]
      : lines;
    const fullNotes = [...outLines, '', ...cost];

    const snapshot = snapshotForNotes();
    const encodedSnapshot = encodePayloadForNotes(snapshot);
    if(encodedSnapshot){
      fullNotes.push('');
      fullNotes.push('Reload key (for Scope Generator, do not edit)');
      fullNotes.push(`${NOTES_DATA_START}${encodedSnapshot}${NOTES_DATA_END}`);
    }

    notesEl.value = fullNotes.join('\n');
    outputEl.style.display = 'grid';
    if (window.parentIFrame && typeof window.parentIFrame.size === 'function') {
      try { window.parentIFrame.size(); } catch(e){}
    }
    if(shouldScroll){
      scrollTo(outputEl);
    }
    persist();
    } finally {
      isGeneratingNotes = false;
      if(pendingNotesRegeneration){
        pendingNotesRegeneration = false;
        scheduleAutoGenerateNotes();
      }
    }
  }

  function buildServiceLinesPayload(){
    if(!Array.isArray(lastServiceLines)){
      return [];
    }
    return lastServiceLines
      .map(item=>{
        const name = item && item.name ? String(item.name).trim() : '';
        const description = item && item.desc ? String(item.desc).trim() : '';
        if(!name && !description){
          return null;
        }
        return {
          name: name || 'Service Line Item',
          description
        };
      })
      .filter(Boolean);
  }

  function updateServiceLinePushControls(hasItems){
    const hasServiceItems = !!hasItems;
    if(serviceOptionInput){
      if(!parsePositiveInt(serviceOptionInput.value || '')){
        serviceOptionInput.value = '1';
      }
      serviceOptionInput.disabled = !hasServiceItems || isPushingServiceLineItems;
    }
    if(pushServiceHcpBtn){
      pushServiceHcpBtn.disabled = !hasServiceItems || isPushingServiceLineItems;
      if(!isPushingServiceLineItems){
        pushServiceHcpBtn.textContent = 'Push Line Items to HCP';
      }
    }
  }

  function autoSizeTextarea(textarea){
    if(!textarea || textarea.tagName !== 'TEXTAREA'){
      return;
    }
    textarea.style.height = 'auto';
    const minHeight = parseFloat(window.getComputedStyle(textarea).minHeight) || 0;
    const nextHeight = Math.max(minHeight, textarea.scrollHeight || 0);
    textarea.style.height = `${nextHeight}px`;
  }

  function autoSizeServiceLineDescriptions(){
    if(!serviceListEl){
      return;
    }
    const textareas = serviceListEl.querySelectorAll('.sp-service-line .sp-textarea');
    textareas.forEach(autoSizeTextarea);
    if (window.parentIFrame && typeof window.parentIFrame.size === 'function') {
      try { window.parentIFrame.size(); } catch(e){}
    }
  }

  function renderServiceLineNotes(items){
    lastServiceLines = Array.isArray(items) ? items.map(item=>({ ...item })) : [];
    updateServiceLinePushControls(lastServiceLines.length);

    if(!serviceListEl || !serviceCardEl){
      return;
    }

    serviceListEl.innerHTML = '';

    if(!lastServiceLines.length){
      serviceCardEl.style.display = 'none';
      if(serviceCopyAllBtn){
        serviceCopyAllBtn.disabled = true;
        serviceCopyAllBtn.textContent = 'Copy All';
      }
      return;
    }

    serviceCardEl.style.display = 'block';
    if(serviceCopyAllBtn){
      serviceCopyAllBtn.disabled = false;
      serviceCopyAllBtn.textContent = 'Copy All';
    }

    lastServiceLines.forEach((item, index)=>{
      const lineEl = document.createElement('div');
      lineEl.className = 'sp-service-line';
      lineEl.dataset.index = String(index);

      const titleField = document.createElement('div');
      titleField.className = 'sp-field';
      const titleLabel = document.createElement('label');
      titleLabel.className = 'sp-label';
      titleLabel.textContent = 'Line Item Title';
      const titleRow = document.createElement('div');
      titleRow.className = 'sp-copy-row';
      const titleInput = document.createElement('input');
      titleInput.className = 'sp-input';
      titleInput.readOnly = true;
      titleInput.value = item.name || '';
      const titleBtn = document.createElement('button');
      titleBtn.className = 'sp-btn ghost sp-copy-service';
      titleBtn.type = 'button';
      titleBtn.textContent = 'Copy';
      titleBtn.dataset.text = item.name || '';
      titleBtn.dataset.kind = 'title';
      titleBtn.addEventListener('click', copyServiceLineButton);
      titleRow.appendChild(titleInput);
      titleRow.appendChild(titleBtn);
      titleField.appendChild(titleLabel);
      titleField.appendChild(titleRow);

      const descField = document.createElement('div');
      descField.className = 'sp-field';
      const descLabel = document.createElement('label');
      descLabel.className = 'sp-label';
      descLabel.textContent = 'Description';
      const descRow = document.createElement('div');
      descRow.className = 'sp-copy-row';
      const descTextarea = document.createElement('textarea');
      descTextarea.className = 'sp-textarea';
      descTextarea.readOnly = true;
      descTextarea.value = item.desc || '';
      const descBtn = document.createElement('button');
      descBtn.className = 'sp-btn ghost sp-copy-service';
      descBtn.type = 'button';
      descBtn.textContent = 'Copy';
      descBtn.dataset.text = item.desc || '';
      descBtn.dataset.kind = 'description';
      descBtn.addEventListener('click', copyServiceLineButton);
      descRow.appendChild(descTextarea);
      descRow.appendChild(descBtn);
      descField.appendChild(descLabel);
      descField.appendChild(descRow);

      lineEl.appendChild(titleField);
      lineEl.appendChild(descField);

      serviceListEl.appendChild(lineEl);
    });
    window.requestAnimationFrame(autoSizeServiceLineDescriptions);
  }

  function quickCostRows(){
    return [
      { key: 'charge', label: 'Price to Charge', input: quickCostChargeInput, button: quickCostChargeBtn },
      { key: 'travel', label: 'Travel', input: quickCostTravelInput, button: quickCostTravelBtn },
      { key: 'materials', label: 'Materials', input: quickCostMaterialsInput, button: quickCostMaterialsBtn },
      { key: 'consumables', label: 'Consumables', input: quickCostConsumablesInput, button: quickCostConsumablesBtn },
      { key: 'labor', label: 'Labor', input: quickCostLaborInput, button: quickCostLaborBtn },
      { key: 'overhead', label: 'Overhead', input: quickCostOverheadInput, button: quickCostOverheadBtn },
      { key: 'commission', label: 'Commission', input: quickCostCommissionInput, button: quickCostCommissionBtn },
    ];
  }

  function resetQuickCostRow(row){
    if(row.input){
      row.input.value = '—';
    }
    if(row.button){
      row.button.disabled = true;
      row.button.dataset.text = '';
    }
  }

  function renderQuickCosts(costs){
    const rows = quickCostRows();
    if(!quickCostsCardEl || !rows.length){
      lastQuickCosts = null;
      return;
    }
    if(!costs || typeof costs !== 'object'){
      rows.forEach(resetQuickCostRow);
      if(quickCostsCopyAllBtn){
        quickCostsCopyAllBtn.disabled = true;
      }
      quickCostsCardEl.style.display = 'none';
      lastQuickCosts = null;
      return;
    }

    const normalized = {
      charge: Number(costs.charge),
      travel: Number(costs.travel),
      materials: Number(costs.materials),
      consumables: Number(costs.consumables),
      labor: Number(costs.labor),
      overhead: Number(costs.overhead),
      commission: Number(costs.commission),
      travelIncluded: costs.travelIncluded !== false
    };
    let hasCopyable = false;
    rows.forEach(row=>{
      if(row.key === 'travel' && normalized.travelIncluded === false){
        if(row.input){
          row.input.value = 'Not included';
        }
        if(row.button){
          row.button.disabled = true;
          row.button.dataset.text = '';
        }
        return;
      }
      const value = normalized[row.key];
      if(!isFinite(value)){
        resetQuickCostRow(row);
        return;
      }
      const text = `$${money(value)}`;
      if(row.input){
        row.input.value = text;
      }
      if(row.button){
        row.button.disabled = false;
        row.button.dataset.text = text;
      }
      hasCopyable = true;
    });

    if(quickCostsCopyAllBtn){
      quickCostsCopyAllBtn.disabled = !hasCopyable;
    }
    quickCostsCardEl.style.display = hasCopyable ? 'block' : 'none';
    lastQuickCosts = hasCopyable ? normalized : null;
  }

  function copyQuickCostButton(event){
    const btn = event?.currentTarget;
    const text = btn?.dataset?.text || '';
    if(!btn || !text) return;
    copyTextToClipboard(text)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copyAllQuickCosts(){
    if(!quickCostsCopyAllBtn || !lastQuickCosts){
      return;
    }
    const lines = [
      `Price to charge: $${money(lastQuickCosts.charge)}`,
      lastQuickCosts.travelIncluded === false ? 'Travel: Not included' : `Travel: $${money(lastQuickCosts.travel)}`,
      `Materials: $${money(lastQuickCosts.materials)}`,
      `Consumables: $${money(lastQuickCosts.consumables)}`,
      `Labor: $${money(lastQuickCosts.labor)}`,
      `Overhead: $${money(lastQuickCosts.overhead)}`,
      `Commission: $${money(lastQuickCosts.commission)}`
    ];
    const text = lines.join('\n');
    copyTextToClipboard(text)
      .then(()=>flashButton(quickCostsCopyAllBtn))
      .catch(()=>flashButton(quickCostsCopyAllBtn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copyTextToClipboard(text){
    const value = (typeof text === 'string') ? text : String(text || '');
    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function'){
      return navigator.clipboard.writeText(value);
    }

    return new Promise((resolve, reject)=>{
      const textarea = document.createElement('textarea');
      textarea.value = value;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.top = '-9999px';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        const ok = document.execCommand('copy');
        document.body.removeChild(textarea);
        if(ok) resolve();
        else reject(new Error('Copy command was rejected.'));
      } catch(err){
        document.body.removeChild(textarea);
        reject(err);
      }
    });
  }

  function flashButton(btn, message='Copied!', options){
    if(!btn) return;
    const opts = Object.assign({ revertMs: 1200, disable: true }, options || {});
    const originalText = btn.textContent;
    const originalDisabled = btn.disabled;
    btn.textContent = message;
    if(opts.disable){
      btn.disabled = true;
    }
    window.setTimeout(()=>{
      btn.textContent = originalText;
      if(opts.disable){
        btn.disabled = originalDisabled;
      }
    }, opts.revertMs);
  }

  function copyAllServiceLines(){
    if(!lastServiceLines.length || !serviceCopyAllBtn){
      return;
    }
    const text = lastServiceLines.map(item=>`${item.name}: ${item.desc}`).join('\n');
    copyTextToClipboard(text)
      .then(()=>flashButton(serviceCopyAllBtn))
      .catch(()=>flashButton(serviceCopyAllBtn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copyServiceLineButton(event){
    if(event){
      event.preventDefault();
      event.stopPropagation();
    }
    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
      autoGenerateTimer = null;
    }
    const btn = event?.currentTarget;
    if(!btn || btn.disabled){
      return;
    }
    const sourceField = btn.closest('.sp-copy-row')?.querySelector('.sp-input, .sp-textarea');
    const fieldText = sourceField && typeof sourceField.value === 'string' ? sourceField.value : '';
    const text = fieldText || (btn.dataset && typeof btn.dataset.text !== 'undefined' ? btn.dataset.text : '');
    if(!text){
      flashButton(btn, 'Nothing to copy', { revertMs: 1200, disable: false });
      return;
    }

    // Prefer synchronous copy from the visible field for maximum reliability.
    const copiedFromField = (()=>{
      if(!sourceField) return false;
      const previousActive = document.activeElement;
      const prevStart = typeof sourceField.selectionStart === 'number' ? sourceField.selectionStart : null;
      const prevEnd = typeof sourceField.selectionEnd === 'number' ? sourceField.selectionEnd : null;
      try{
        if(typeof sourceField.focus === 'function'){
          try{
            sourceField.focus({ preventScroll: true });
          }catch(_err){
            sourceField.focus();
          }
        }
        if(typeof sourceField.select === 'function'){
          sourceField.select();
        }
        if(typeof sourceField.setSelectionRange === 'function'){
          sourceField.setSelectionRange(0, sourceField.value.length);
        }
        const ok = document.execCommand('copy');
        if(prevStart !== null && prevEnd !== null && typeof sourceField.setSelectionRange === 'function'){
          sourceField.setSelectionRange(prevStart, prevEnd);
        }
        if(previousActive && previousActive !== sourceField && typeof previousActive.focus === 'function'){
          try{
            previousActive.focus({ preventScroll: true });
          }catch(_err){
            previousActive.focus();
          }
        }
        return !!ok;
      }catch(_err){
        return false;
      }
    })();
    if(copiedFromField){
      flashButton(btn);
      return;
    }

    copyTextToClipboard(text)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function numOrDash(v){ const n = parseInt(v,10); return isNaN(n)?'—':n; }
  function scrollTo(el){ el.scrollIntoView({behavior:'smooth', block:'start'}); }

  function copyNotes(){
    const btn = document.getElementById('sp-copy');
    if(!notesEl || !btn) return;
    notesEl.select();
    copyTextToClipboard(notesEl.value)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copyReloadKey(){
    const btn = document.getElementById('sp-copy-reload');
    if(!notesEl || !btn) return;
    const notesText = notesEl.value || '';
    const encodedData = extractEmbeddedNotesData(notesText);
    if(!encodedData){
      flashButton(btn, 'No key found', { revertMs: 1600, disable: false });
      return;
    }
    const keyBlock = [
      'Reload key (for Scope Generator, do not edit)',
      `${NOTES_DATA_START}${encodedData}${NOTES_DATA_END}`,
    ].join('\n');
    copyTextToClipboard(keyBlock)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function copySubNotes(){
    const btn = document.getElementById('sp-copy-sub');
    if(!notesSubEl || !btn) return;
    notesSubEl.select();
    copyTextToClipboard(notesSubEl.value)
      .then(()=>flashButton(btn))
      .catch(()=>flashButton(btn, 'Copy failed', { revertMs: 1600, disable: false }));
  }

  function getPriceToChargeValue(){
    const quickCharge = Number(lastQuickCosts && lastQuickCosts.charge);
    if(isFinite(quickCharge) && quickCharge >= 0){
      return quickCharge;
    }
    const raw = quickCostChargeInput && typeof quickCostChargeInput.value === 'string'
      ? quickCostChargeInput.value
      : '';
    if(!raw || raw === '—'){
      return null;
    }
    const parsed = Number(String(raw).replace(/[^0-9.-]/g, ''));
    return isFinite(parsed) ? parsed : null;
  }

  function getEstimateIdForPayload(estimateNumber){
    const normalizedEstimateNumber = sanitizeEstimateNumber(estimateNumber || '');
    if(!normalizedEstimateNumber || normalizedEstimateNumber !== lastEstimateLookupNumber){
      return '';
    }
    return normalizeEstimateId(lastEstimateId);
  }

  async function pushServiceLineItemsToHcp(){
    if(!pushServiceHcpBtn || !estimateNumberInput || !serviceOptionInput){
      return;
    }

    const rawNumber = (estimateNumberInput.value || '').trim();
    if(!rawNumber){
      alert('Please enter the Housecall Pro estimate number.');
      estimateNumberInput.focus();
      return;
    }

    const estimateNumber = rawNumber.replace(/[^0-9]/g, '');
    if(!estimateNumber){
      alert('The estimate number must contain at least one digit.');
      estimateNumberInput.focus();
      return;
    }

    const optionNumber = parsePositiveInt(serviceOptionInput.value || '');
    if(!optionNumber){
      alert('Please enter a valid estimate option number (Option 1, 2, 3, etc).');
      serviceOptionInput.focus();
      return;
    }

    const serviceLines = buildServiceLinesPayload();
    if(!serviceLines.length){
      alert('There are no service line items to send yet. Generate notes first.');
      return;
    }

    const confirmMessage = `Send ${serviceLines.length} service line item${serviceLines.length === 1 ? '' : 's'} to Housecall Pro (Estimate ${estimateNumber}, Option ${optionNumber})?`;
    if(!confirm(confirmMessage)){
      return;
    }

    if(typeof fetch !== 'function'){
      alert('This browser does not support automatic line item sending. Please copy the service line items manually.');
      return;
    }

    if(isPushingServiceLineItems){
      return;
    }

    const lineItemsPayload = serviceLines.map(item=>({
      name: item.name,
      description: item.description,
      quantity: 1,
      kind: 'labor',
      taxable: true,
    }));
    const priceToCharge = getPriceToChargeValue();

    isPushingServiceLineItems = true;
    updateServiceLinePushControls(serviceLines.length);
    const originalText = pushServiceHcpBtn.textContent;
    pushServiceHcpBtn.textContent = 'Pushing...';

    try{
      const estimateId = getEstimateIdForPayload(estimateNumber);
      const payload = {
        estimateNumber,
        optionNumber,
        optionId: String(optionNumber),
        optionLabel: `Option ${optionNumber}`,
        serviceLines,
        lineItems: lineItemsPayload,
        line_items: lineItemsPayload,
        priceToCharge,
        price_to_charge: priceToCharge,
      };
      if(estimateId){
        payload.id = estimateId;
        payload.estimateId = estimateId;
        payload.estimate_id = estimateId;
      }

      const response = await fetch('https://api.strongclicks.io/webhook/service-line-items', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if(!response.ok){
        const text = await response.text();
        throw new Error(text || `Request failed with status ${response.status}`);
      }

      alert(`Service line items sent to Housecall Pro option ${optionNumber}.`);
    }catch(err){
      console.error('Failed to push service line items to HCP', err);
      alert('Failed to push service line items to Housecall Pro. Please try again.');
    }finally{
      isPushingServiceLineItems = false;
      updateServiceLinePushControls(lastServiceLines.length);
      if(pushServiceHcpBtn){
        pushServiceHcpBtn.textContent = originalText;
      }
    }
  }

  async function pushNotesToHcp(){
    if(!pushHcpBtn || !estimateNumberInput){ return; }

    const rawNumber = (estimateNumberInput.value || '').trim();
    if(!rawNumber){
      alert('Please enter the Housecall Pro estimate number.');
      estimateNumberInput.focus();
      return;
    }

    const estimateNumber = rawNumber.replace(/[^0-9]/g, '');
    if(!estimateNumber){
      alert('The estimate number must contain at least one digit.');
      estimateNumberInput.focus();
      return;
    }

    const notes = (notesEl && notesEl.value || '').trim();
    const notesSub = (notesSubEl && notesSubEl.value || '').trim();
    const serviceLinesPayload = buildServiceLinesPayload()
      .map(item=>({
        title: item.name,
        description: item.description,
      }));
    if(!notes){
      alert('There are no notes to send yet. Generate notes first.');
      return;
    }

    if(typeof fetch !== 'function'){
      alert('This browser does not support automatic note sending. Please copy the notes manually.');
      return;
    }

    const originalText = pushHcpBtn.textContent;
    pushHcpBtn.disabled = true;
    pushHcpBtn.textContent = 'Pushing...';

    try{
      const encodedReloadKey = extractEmbeddedNotesData(notes);
      const reloadKey = encodedReloadKey
        ? `${NOTES_DATA_START}${encodedReloadKey}${NOTES_DATA_END}`
        : '';
      const estimateId = getEstimateIdForPayload(estimateNumber);
      const payload = {
        estimateNumber,
        notes,
        notesSub,
        reloadKey,
      };
      if(estimateId){
        payload.id = estimateId;
        payload.estimateId = estimateId;
        payload.estimate_id = estimateId;
      }

      if(serviceLinesPayload.length){
        payload.serviceLines = serviceLinesPayload;
      }

      const response = await fetch('https://api.strongclicks.io/webhook/add-notes-to-hcp-estimate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if(!response.ok){
        const text = await response.text();
        throw new Error(text || `Request failed with status ${response.status}`);
      }

      alert('Notes sent to Housecall Pro.');
    }catch(err){
      console.error('Failed to push notes to HCP', err);
      alert('Failed to push notes to Housecall Pro. Please try again.');
    }finally{
      pushHcpBtn.disabled = false;
      pushHcpBtn.textContent = originalText;
    }
  }

  const KEY = 'sp_scope_v1';

  function handleNotesImport(){
    if(!importTextEl){
      return;
    }
    const raw = (importTextEl.value || '').trim();
    if(!raw){
      updateImportStatus('Paste notes to reload.', 'warn');
      return;
    }

    const encoded = extractEmbeddedNotesData(raw);
    const payload = encoded ? decodePayloadFromNotes(encoded) : null;

    if(!payload){
      const legacySnapshot = parseLegacyNotesSnapshot(raw);
      if(!legacySnapshot){
        updateImportStatus('No embedded scope data found in the pasted notes.', 'error');
        return;
      }
      try{
        applySnapshotToState(legacySnapshot);
        updateImportStatus('Scope restored from pasted notes (legacy format).', 'success');
        setGateUnlocked(true);
        return;
      }catch(err){
        console.error('Failed to apply legacy snapshot', err);
        updateImportStatus('Embedded data was invalid or incomplete.', 'error');
        return;
      }
    }

    try{
      applySnapshotToState(payload);
      updateImportStatus('Scope restored from pasted notes.', 'success');
      setGateUnlocked(true);
    }catch(err){
      console.error('Failed to apply snapshot', err);
      updateImportStatus('Embedded data was invalid or incomplete.', 'error');
    }
  }

  function clearImportField(){
    if(importTextEl){
      importTextEl.value = '';
    }
    updateImportStatus('', '');
  }

  function scheduleAutoGenerateNotes(){
    if(isGeneratingNotes){
      pendingNotesRegeneration = true;
      return;
    }
    if(autoGenerateTimer){
      clearTimeout(autoGenerateTimer);
    }
    autoGenerateTimer = window.setTimeout(()=>{
      autoGenerateTimer = null;
      if(isGeneratingNotes){
        return;
      }
      try{
        generateNotes({ skipScroll: true });
      }catch(err){
        console.error('Auto note generation failed', err);
      }
    }, 250);
  }

  function persist(){
    scheduleAutoGenerateNotes();
  }

  function restore(){
    try { localStorage.removeItem(KEY); } catch(e){}
    return false;
  }
  function resetAll(){
    if(!confirm('Clear all sections?')) return;
    clearMapDrawing({ skipSections: true });
    state.sections = [];
    localStorage.removeItem(KEY);
    render();
    outputEl.style.display='none';
    renderServiceLineNotes([]);
    renderQuickCosts(null);
  }
  window._spInitializeMap = initializeMap;
  if(window._spGoogleMapsReady){
    initializeMap();
  }
  updateMapControlsUI();

  const mapClearBtn = document.getElementById('sp-map-clear');
  if(mapClearBtn){
    mapClearBtn.addEventListener('click', ()=>{
      syncStateFromDOM();
      const hasLinkedSections = state.sections.some(sec=>sec.mapGenerated);
      if(!mapState.polylines.length && !hasLinkedSections) return;
      if(!confirm('Remove all map drawings and linked sections?')) return;
      clearMapDrawing();
    });
  }

  if(mapToggleBtn && mapCardEl){
    setMapCollapsed(mapCardEl.classList.contains('is-collapsed'));
    mapToggleBtn.addEventListener('click', ()=>{
      const next = !mapCardEl.classList.contains('is-collapsed');
      setMapCollapsed(next);
    });
  }

  if(manualOpenBtn && manualModal){
    manualOpenBtn.addEventListener('click', ()=> setManualModal(true));
  }
  if(manualCloseBtn){
    manualCloseBtn.addEventListener('click', ()=> setManualModal(false));
  }
  if(importOpenBtn && importModal){
    importOpenBtn.addEventListener('click', ()=> setImportModal(true));
  }
  if(importCloseBtn){
    importCloseBtn.addEventListener('click', ()=> setImportModal(false));
  }

  if(manualCalcBtn){
    manualCalcBtn.addEventListener('click', updateManualQuote);
  }
  if(manualCostInput){
    manualCostInput.addEventListener('input', ()=> updateManualQuote());
    manualCostInput.addEventListener('keydown', evt=>{
      if(evt.key === 'Enter'){
        evt.preventDefault();
        updateManualQuote();
      }
    });
  }
  if(manualHoursInput){
    manualHoursInput.addEventListener('input', ()=> {
      const raw = manualHoursInput.value || '';
      const cleaned = raw.replace(/[^0-9.]/g, '');
      const parts = cleaned.split('.');
      const normalized = parts.length > 1
        ? `${parts[0]}.${parts.slice(1).join('')}`
        : cleaned;
      if(raw !== normalized){
        manualHoursInput.value = normalized;
      }
      updateManualQuote();
    });
  }
  if(crewMemberInputs.length){
    crewMemberInputs.forEach(input=>{
      input.addEventListener('change', ()=>{
        const selectedMembers = crewMemberInputs
          .filter(item=> item.checked)
          .map(item=> String(item.dataset.crewMember || '').trim())
          .filter(Boolean);
        if(!selectedMembers.length){
          const fallbackName = String(input.dataset.crewMember || '').trim() || DEFAULT_CREW_MEMBERS[0];
          input.checked = true;
          applyCrewMembersSelection([fallbackName], { skipDomSync: true });
        }else{
          applyCrewMembersSelection(selectedMembers, { skipDomSync: true });
        }
        updateManualQuote();
        persist();
      });
    });
  }

  if(customerTypeSelect){
    customerTypeSelect.addEventListener('change', ()=>{
      customerTypeSelect.value = normalizeCustomerType(customerTypeSelect.value);
      state.customerType = customerTypeSelect.value;
      updatePricingMinimumUI();
      setCustomerTypeConfirmed(false);
      generateNotes({ skipScroll: true });
    });
  }
  if(customerTypeSelect){
    customerTypeSelect.value = normalizeCustomerType(customerTypeSelect.value);
    state.customerType = customerTypeSelect.value;
  }
  updatePricingMinimumUI();
  if(customerConfirmBtn){
    customerConfirmBtn.addEventListener('click', ()=> setCustomerTypeConfirmed(true));
  }

  const quickAddBtn = document.getElementById('sp-quick-add');
  if(quickAddBtn){ quickAddBtn.addEventListener('click', ()=>{ addSection(); persist(); }); }
  const quickDupFirstBtn = document.getElementById('sp-quick-dup-first');
  if(quickDupFirstBtn){ quickDupFirstBtn.addEventListener('click', ()=>{ duplicateFirstSectionStyle(); persist(); }); }
  const quickDupLastBtn = document.getElementById('sp-quick-dup-last');
  if(quickDupLastBtn){ quickDupLastBtn.addEventListener('click', ()=>{ duplicateLatestSectionStyle(); persist(); }); }
  document.getElementById('sp-copy').addEventListener('click', copyNotes);
  document.getElementById('sp-copy-reload').addEventListener('click', copyReloadKey);
  document.getElementById('sp-copy-sub').addEventListener('click', copySubNotes);
  if(quickCostsCopyAllBtn){ quickCostsCopyAllBtn.addEventListener('click', copyAllQuickCosts); }
  if(quickCostChargeBtn){ quickCostChargeBtn.addEventListener('click', copyQuickCostButton); }
  if(quickCostTravelBtn){ quickCostTravelBtn.addEventListener('click', copyQuickCostButton); }
  if(quickCostMaterialsBtn){ quickCostMaterialsBtn.addEventListener('click', copyQuickCostButton); }
  if(quickCostConsumablesBtn){ quickCostConsumablesBtn.addEventListener('click', copyQuickCostButton); }
  if(quickCostLaborBtn){ quickCostLaborBtn.addEventListener('click', copyQuickCostButton); }
  if(quickCostOverheadBtn){ quickCostOverheadBtn.addEventListener('click', copyQuickCostButton); }
  if(quickCostCommissionBtn){ quickCostCommissionBtn.addEventListener('click', copyQuickCostButton); }
  if(estimateNumberInput){
    estimateNumberInput.addEventListener('input', ()=>{
      const digits = sanitizeEstimateNumber(estimateNumberInput.value || '');
      if(!digits){
        if(estimateLookupController && typeof estimateLookupController.abort === 'function'){
          estimateLookupController.abort();
          estimateLookupController = null;
        }
        lastEstimateLookupNumber = '';
        lastEstimateAddress = '';
        lastEstimateId = '';
        lastEstimateExists = false;
        updateEstimateStatus('', '');
      }else if(digits !== lastEstimateLookupNumber){
        lastEstimateId = '';
      }
    });
    estimateNumberInput.addEventListener('keydown', evt=>{
      if(evt.key === 'Enter'){
        evt.preventDefault();
        runEstimateLookup();
      }
    });
  }
  if(estimateLookupBtn){
    estimateLookupBtn.addEventListener('click', ()=>runEstimateLookup());
  }
  if(proceedWithoutEstimateBtn){
    proceedWithoutEstimateBtn.addEventListener('click', ()=>{
      updateEstimateStatus('Proceeding without estimate.', 'info');
      setGateUnlocked(true);
    });
  }
  if(pushHcpBtn){
    pushHcpBtn.addEventListener('click', pushNotesToHcp);
  }
  if(pushServiceHcpBtn){
    pushServiceHcpBtn.addEventListener('click', pushServiceLineItemsToHcp);
  }
  if(serviceOptionInput){
    serviceOptionInput.addEventListener('input', ()=>{
      const value = serviceOptionInput.value || '';
      if(!value){
        return;
      }
      const normalized = parsePositiveInt(value);
      serviceOptionInput.value = normalized > 0 ? String(normalized) : '';
    });
    serviceOptionInput.addEventListener('keydown', evt=>{
      if(evt.key === 'Enter'){
        evt.preventDefault();
        pushServiceLineItemsToHcp();
      }
    });
  }
  if(serviceCopyAllBtn){ serviceCopyAllBtn.addEventListener('click', copyAllServiceLines); }
  window.addEventListener('resize', autoSizeServiceLineDescriptions);
  if(importBtn){
    importBtn.addEventListener('click', handleNotesImport);
  }
  if(importClearBtn){
    importClearBtn.addEventListener('click', clearImportField);
  }
  document.getElementById('sp-reset').addEventListener('click', resetAll);

  const backTopBtn = document.getElementById('sp-top-btn');
  if (backTopBtn){
    backTopBtn.addEventListener('click', ()=> window.scrollTo({ top: 0, behavior: 'smooth' }));
  }

  const backBottomBtn = document.getElementById('sp-bottom-btn');
  if (backBottomBtn){
    backBottomBtn.addEventListener('click', ()=> window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' }));
  }

  updateManualQuote();

  if(estimateNumberInput){
    window.setTimeout(()=>{
      const active = document.activeElement;
      if(active && active !== document.body && active !== estimateNumberInput){
        return;
      }
      if(typeof estimateNumberInput.focus === 'function'){
        try{
          estimateNumberInput.focus({ preventScroll: true });
        }catch(_err){
          estimateNumberInput.focus();
        }
      }
      if(typeof estimateNumberInput.setSelectionRange === 'function'){
        const cursorAt = estimateNumberInput.value ? estimateNumberInput.value.length : 0;
        estimateNumberInput.setSelectionRange(cursorAt, cursorAt);
      }
    }, 0);
  }

  if(estimateNumberInput && estimateNumberInput.value){
    runEstimateLookup();
  }

  if(!restore()){ addSection(); }
})();
});
</script>
<script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDW2GCWGKbnbA9lA2wPJSmciyMcghOZlxc&libraries=geometry,places,drawing&callback=initMap&loading=async"></script>
</body>
</html>
